{"meta":{"title":"当然要记笔记啊","subtitle":"嗯……总之欢迎啊","description":null,"author":"红色鲱鱼","url":"https://tipwheal.github.io/blog"},"pages":[{"title":"","date":"2018-10-09T12:08:49.508Z","updated":"2018-10-09T12:08:49.508Z","comments":true,"path":"hexo-admin-ehc-images.json","permalink":"https://tipwheal.github.io/blog/hexo-admin-ehc-images.json","excerpt":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]"},{"title":"about","date":"2018-10-21T06:15:47.000Z","updated":"2018-10-21T06:16:23.136Z","comments":true,"path":"about/index.html","permalink":"https://tipwheal.github.io/blog/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-21T06:12:28.000Z","updated":"2018-10-26T06:17:26.861Z","comments":true,"path":"categories/index.html","permalink":"https://tipwheal.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"schedule","date":"2018-10-21T06:16:02.000Z","updated":"2018-10-21T06:16:34.367Z","comments":true,"path":"schedule/index.html","permalink":"https://tipwheal.github.io/blog/schedule/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-21T06:13:34.000Z","updated":"2018-10-21T06:14:05.738Z","comments":true,"path":"tags/index.html","permalink":"https://tipwheal.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"草稿和素材","slug":"draft","date":"2018-11-06T14:08:46.000Z","updated":"2018-11-13T02:59:08.722Z","comments":true,"path":"2018/11/06/draft/","link":"","permalink":"https://tipwheal.github.io/blog/2018/11/06/draft/","excerpt":"Docker命令相关创建一个网络1docker networt create --subnet=172.18.0.0/16 mynetwork 列出网络1docker network ls","text":"Docker命令相关创建一个网络1docker networt create --subnet=172.18.0.0/16 mynetwork 列出网络1docker network ls 查看镜像信息1docker inspect imageid docker内网访问的问题在一个容器中使用反向代理，代理到其它容器的服务，此容器使用公网，其他容器只能在内网访问。 即比如有如下三个容器A, B, C 然后A容器暴露80端口到公网 B和C暴露各自的服务端口如8080或3000等到内网 然后在A容器中使用反向代理，代理容器B和C中的服务，使得公网可以通过访问A来访问B和C的服务 方案A容器A: 0.0.0.0:80:80容器B: 172.17.0.1:8080:8080容器C: 172.17.0.1:8081:8080 这个方案是可以的 方案B使用172.18.0.0/16网络，分配固定ip，并直接访问也是可以的。比如容器A依旧是 0.0.0.0:80:80容器B使用ip和端口: 172.18.0.10:8080这时也是可以使用的 尝试-p参数-p参数的作用是什么呢，可以的选项是什么呢？0.0.0.0可以用，那么127.0.0.1呢我需要搞清楚这个 如果指派一个ip给容器，就不能再把对应的ip用来映射了比如172.18.0.10:5000:5000 还同时把172.18.0.10分配给一个容器，这是不行的 EXPOSE的作用（去搜索） EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务 –摘自https://yeasy.gitbooks.io/docker_practice/image/dockerfile/expose.html 所以它实际上并不能暴露端口。 如果EXPOSE和-P参数一起使用，则会使用随机映射的策略进行映射，这估计是EXPOSE的唯一作用。 -p 参数则用于手动指定端口映射。 格式大致如ip:宿主机port:容器port 那么这个ip的限制呢？ –link这个命令似乎有神奇的作用，但是我们需要 啊 我只是想让某个docker服务只暴露在内网，为何总是无法访问 难道我需要iptables吗 对应的文档或者源码能不能看一下呢 -p的原理使用iptables可以查看实际上的操作 看起来docker里面应该填网络名。先使用iptables看看效果 Docker的笔记 Docker使用Go语言开发，对进程进行封装隔离，属于操作系统层面的虚拟化技术。比虚拟机技术更加轻便，快捷。 和虚拟机的区别 虚拟机技术在所有在虚拟机之上使用Hypervisor，然后每一个虚拟机包含了应用，库文件以及整个操作系统 Docker技术则使用Docker Engine对所有的容器进行管理，每一个容器中只有应用的库文件 Docker的好处 更高效地利用系统资源（不需要完整的操作系统） 更快的启动时间（比起虚拟机，不需要一个操作系统，所以很快） 一致的运行环境（同样的Dockerfile，不用担心换环境导致错误） 持续交付和部署（使用Dockerfile，CI/CD） 轻松迁移（保证执行环境的一致性） 更轻松的维护和扩展（什么是分层存储和镜像技术？）（有很多官方镜像可以使用） 镜像，容器和仓库镜像Docker镜像相当于一个root文件系统。Linux内核启动后会挂载root文件系统为其提供用户空间支持。 不是很懂这个 分层存储 分层存储利用了Union FS技术,docker的镜像并不是一个单一的文件，而是由一组文件组成。 镜像构建时会一层一层地构建。而在后面的层将无法改动前面的层，删除上一层的文件的操作实际上是将其标志为删除。 好处是在镜像复用或者定制时更加容易。 容器一个镜像可以有多个容器实例，就像面向对象的类和实例的关系一样。 容器可以进行的操作有： 创建 启动 停止 删除 暂停 跟虚拟机可以进行的操作很类似。 特性： 容器的实质是进程，这个进程运行于独立的命名空间 每一个容器运行时，会在镜像上面创建一层容器存储层，最佳实践推荐不要向存储层写入任何数据。 文件操作： 应该使用数据卷或者绑定宿主目录的方式对宿主进行读写，在这种操作方式下，容器消亡时数据并不会消亡。 仓库Docker Registry是一个集中存储、分发镜像的服务 一个Registry里面可以包含多个仓库(Repository),每个仓库可以包含多喝标签(tag); 每个标签对应一个镜像。 比如: ubuntu:16.04 ubuntu:latest 如果在docker pull时不指定标签，使用默认标签latest 常用的公开registry服务： Docker Hub Quay.io Google Container Registry 常见的加速器(Registry Mirror): 阿里云加速器 DaoCloud加速器 (配置方式呢) Dockerfile的操作 每一个指令，都会建立一层存储 FROM选择基础镜像，如果从空白开始则是FROM scratch 使用Go开发的应用很多会使用这种方式来制作镜像，体积更加小巧 RUN用于执行命令行命令，注意进行一个完整的操作时应该将命令行命令写在同一个RUN中，用\\换行 举例如下: (摘自 https://yeasy.gitbooks.io/docker_practice/image/build.html) 1234567891011121314FROM debian:jessieRUN buildDeps='gcc libc6-dev make' \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ &amp;&amp; wget -O redis.tar.gz \"http://download.redis.io/releases/redis-3.2.5.tar.gz\" \\ &amp;&amp; mkdir -p /usr/src/redis \\ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ &amp;&amp; make -C /usr/src/redis \\ &amp;&amp; make -C /usr/src/redis install \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm redis.tar.gz \\ &amp;&amp; rm -r /usr/src/redis \\ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 这样可以避免出无意义的层并且增加镜像的体积(因为后面的层无法真正地删除前面的层的文件) COPYADDCMDENTRYPOINTENVARGVOLUMEEXPOSEWORKDIRUSERHEALTHCHECKONBUILD Docker依旧是一种虚拟化的方式 curl的笔记1curl -X POST http://balabala.com/balabala -d &#123;\\\"param1\\\":\\\"value\\\"&#125; -X可以指定请求方式，比如POST或者GET. -d可以指定参数，但是似乎默认的参数格式是&quot;a=sss&amp;b=c&quot;这种格式 似乎需要额外的参数指定json格式呢 找到了 1curl -H \"Content-Type:application/json\" -X POST http://balabala.com/balabala -d &#123;\\\"param1\\\":\\\"value\\\"&#125; DevOps Development and Operations 特点？好处都有啥？缺点？采用的技术？啊容器和虚拟机是不一样的，曾经有人问我他们的区别 VSCode很好，vscode很好vscode很奇怪 不是很好 材料 md编辑时打开preview关闭很迷 terminal放到右边时如何回到下方 草稿需要的时候从草稿中取出素材已经学过的东西需要被记录 反复反复记录阅读反复阅读记录阅读强化 等待，我总是在等待 我需要把所有的额外的东西先打包一个docker image,而不是每次都操作一次,这太蠢了 人在等待的时候应该做什么 零样本学习pycryptodome什么是pycryptodome呢 源码为什么不看一看源码呢 iptables1iptables -t nat -nL iptables好像很有趣 收藏一个关于docker的gitbook: https://yeasy.gitbooks.io/docker_practice/ gitbook?#的作用比如#test可以访问这里 docker的网络模型导出word的方案telnet使用Spring boot中使用redis做缓存一篇文章： https://www.cnblogs.com/gdpuzxs/p/7222309.html另一篇： https://www.cnblogs.com/badboyf/p/6995202.html?utm_source=itdadao&amp;utm_medium=referral 读读书，涨涨姿势中文文案排版指南https://github.com/mzlogin/chinese-copywriting-guidelines#%E8%B0%81%E5%9C%A8%E8%BF%99%E6%A0%B7%E5%81%9A Go方法以及简单的Hello World1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello, World!\")&#125; 用scratch来制作一个go应用镜像摘自菜鸟教程。 package main代表是一个可独立执行的程序。 fmt是一个IO库。 Println竟然是大写 {的位置1234func main()&#123; fmt.Println(\"Hello, Wolrd\")&#125; 这样写会报错。。。。真的有这个必要吗 调试1go run filename.go 新问题在docker里面启动的东西能不能把命令行的日志放到日志文件里啊 试一下吧 docker启动一个redis12docker pull redisdocker run -d --name myredis -p 16379:6379 redis --requirepass \"mypassword\" Arduino注释可以使用 舵机使用Servo控制舵机 Serial1Serial.begin(); （Arduino高亮是不是有bug） css3动画真好玩 vue中操作cookieaxios默认不允许请求携带cookie 需要使用 1axios.defaults.withCredetials = true; 接收不到cookie不要使用mock即可 RedisRedis在互联网公司一般有以下应用: String：缓存、限流、计数器、分布式锁、分布式Session Hash：存储用户信息、用户主页访问量、组合查询 List：微博关注人时间轴列表、简单队列 Set：赞、踩、标签、好友关系 Zset：排行榜 Ant Design","categories":[{"name":"草稿","slug":"草稿","permalink":"https://tipwheal.github.io/blog/categories/草稿/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"草稿","slug":"草稿","permalink":"https://tipwheal.github.io/blog/tags/草稿/"},{"name":"素材","slug":"素材","permalink":"https://tipwheal.github.io/blog/tags/素材/"},{"name":"乱贴标签","slug":"乱贴标签","permalink":"https://tipwheal.github.io/blog/tags/乱贴标签/"}]},{"title":"git分支操作笔记","slug":"git-branch","date":"2018-11-05T11:19:38.000Z","updated":"2018-11-05T11:34:30.448Z","comments":true,"path":"2018/11/05/git-branch/","link":"","permalink":"https://tipwheal.github.io/blog/2018/11/05/git-branch/","excerpt":"","text":"创建本地分支1git checkout -b new_branch 相当于 12git branch new_branchgit checkout new_branch","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://tipwheal.github.io/blog/tags/git/"}]},{"title":"$\\mathtt{B\\acute{e}zier}$曲线","slug":"bezier-curve","date":"2018-10-26T04:01:44.000Z","updated":"2018-10-26T06:31:04.414Z","comments":true,"path":"2018/10/26/bezier-curve/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/26/bezier-curve/","excerpt":"$\\mathtt{B\\acute{e}zier}$曲线的定义$$P(t)=\\sum_{i=0}^nB_{i,n}(t)P_i,0\\le{t}\\le{1}$$ 其中， $$B_{i,n}(t)=C_n^it^i(1-t)^{n-i}=\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i},i=0,1,\\dots,n$$","text":"$\\mathtt{B\\acute{e}zier}$曲线的定义$$P(t)=\\sum_{i=0}^nB_{i,n}(t)P_i,0\\le{t}\\le{1}$$ 其中， $$B_{i,n}(t)=C_n^it^i(1-t)^{n-i}=\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i},i=0,1,\\dots,n$$ 当$n=1$时,式子成为 $$\\begin{split}P(t)&amp;=B_{0,1}(t)P_0+B_{1,1}(t)P_1,0\\le{t}\\le{1} \\\\&amp;=(1-t)P_0+tP_1 \\\\&amp;=\\begin{pmatrix}t &amp; 1 \\\\\\end{pmatrix}\\begin{pmatrix}-1 &amp; 1 \\\\1 &amp; 0 \\\\\\end{pmatrix}\\begin{pmatrix}P_0 \\\\P_1 \\\\\\end{pmatrix}\\end{split}$$ 这个式子意味着这是一条从$P_0$连到$P_1$的直线段. 当$n=2$时,式子成为 $$\\begin{split}P(t)&amp;=(1-t)^2P_0+2t(1-t)P_1+t^2P_2 \\\\&amp;=\\begin{pmatrix}t^2 &amp; t &amp; 1 \\\\\\end{pmatrix}\\begin{pmatrix}1 &amp; -2 &amp; 1 \\\\-2 &amp; 2 &amp; 0 \\\\1 &amp; 0 &amp; 0 \\\\\\end{pmatrix}\\begin{pmatrix}P_0 \\\\P_1 \\\\P_2 \\\\\\end{pmatrix}\\end{split}$$ 这次是一个抛物线. 当$n=3$时，式子成为 $$\\begin{split}P(t)&amp;=(1-t)^3P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3 \\\\&amp;=\\begin{pmatrix}t^3 &amp; t^2 &amp; t &amp; 1 \\\\\\end{pmatrix}\\begin{pmatrix}-1 &amp; 3 &amp; -3 &amp; 1 \\\\3 &amp; -6 &amp; 3 &amp; 0 \\\\-3 &amp; 3 &amp; 0 &amp; 0 \\\\1 &amp; 0 &amp; 0 &amp; 0 \\\\\\end{pmatrix}\\begin{pmatrix}P_0 \\\\P_1 \\\\P_2 \\\\P_3 \\\\\\end{pmatrix}\\end{split}$$ 曲线的性质","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://tipwheal.github.io/blog/categories/计算机图形学/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://tipwheal.github.io/blog/tags/计算机图形学/"}]},{"title":"使用docker搭建jenkins","slug":"jenkins","date":"2018-10-25T05:30:31.000Z","updated":"2018-11-06T15:32:15.280Z","comments":true,"path":"2018/10/25/jenkins/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/25/jenkins/","excerpt":"记录一下在CentOS7中使用docker运行一个jenkins…","text":"记录一下在CentOS7中使用docker运行一个jenkins… 环境使用CentOS7 前置条件 需要有tomcat 123docker pull jenkinsmkdir /home/jenkinsdocker run -d --name myjenkins -p 15000:50000 -p 18080:8080 -v /home/jenkins:/home/jenkins jenkins -v和使用copy的效果是如何不同的此处占坑 然后需要找密码了，访问服务器的10080端口可以看到jenkins的登陆界面。该界面会告诉我们密码放在/var/jenkins_home/secrets/initialAdminPassword里面，但我们的jenkins是在docker容器中启动的，所以我们需要到容器内对应的路径去找。 12docker exec -it myjenkins /bin/bash # 进入容器cat /var/jenkins_home/secrets/initialAdminPassword 拿到密码a704538e730d4acda43343383718377c 退出容器 1logout 登陆进去选插件，发现有一堆安装失败了pipeline 后续操作并没有学会…… 自己写一个吧","categories":[{"name":"持续集成","slug":"持续集成","permalink":"https://tipwheal.github.io/blog/categories/持续集成/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://tipwheal.github.io/blog/tags/jenkins/"},{"name":"持续集成","slug":"持续集成","permalink":"https://tipwheal.github.io/blog/tags/持续集成/"}]},{"title":"学习Spring Cloud","slug":"springngcloud","date":"2018-10-24T06:11:57.000Z","updated":"2018-10-25T12:48:13.508Z","comments":true,"path":"2018/10/24/springngcloud/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/24/springngcloud/","excerpt":"Eureka结构有服务注册中心、服务生产者和服务消费者 流程 服务生产者启动时，向服务注册中心注册服务 服务消费者(启动时？)向服务注册中心订阅服务 服务注册中心向服务消费者返回服务生产者的地址 服务消费者调用所需服务","text":"Eureka结构有服务注册中心、服务生产者和服务消费者 流程 服务生产者启动时，向服务注册中心注册服务 服务消费者(启动时？)向服务注册中心订阅服务 服务注册中心向服务消费者返回服务生产者的地址 服务消费者调用所需服务 用途 这是一段话所以注册的服务只是告诉注册中心自己的地址，让注册中心转告给消费者？ 启动方式服务注册中心是一个eureka-server建议禁用client功能 服务生产者是一个eureka-client bus Spring Cloud Bus被翻译为消息总线看起来可以在多个服务中互相传递消息 用途 这也是一段用途，但他不能教我数学 结构 服务A启动，连接总线 服务B启动，连接总线 服务C启动，连接总线 服务A发送消息 服务B、C收到消息 举个栗子 ActiveMQ Kafka RabbitMQ RocketMQ 比较吗？需要比较一下吗？ 使用RabiitMQzuul zuul是一个网关 配置中心spring cloud config/ zoo keeperredis断路器/熔断/Hystrixdevops和aiopsdubbo/zookeeper读论文 我们需要读论文学习","categories":[{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/categories/编程/"},{"name":"Java","slug":"编程/Java","permalink":"https://tipwheal.github.io/blog/categories/编程/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://tipwheal.github.io/blog/tags/SpringCloud/"}]},{"title":"Arduino怎么写呢","slug":"arduino","date":"2018-10-21T12:46:41.000Z","updated":"2018-10-25T03:14:50.618Z","comments":true,"path":"2018/10/21/arduino/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/21/arduino/","excerpt":"但是这里是空的呀……","text":"但是这里是空的呀…… 空的就空的，这个东西好无聊的 为什么打开Arduino放着不动，cpu占用率高达30%?","categories":[{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/categories/编程/"},{"name":"arduino","slug":"编程/arduino","permalink":"https://tipwheal.github.io/blog/categories/编程/arduino/"}],"tags":[{"name":"aruduino","slug":"aruduino","permalink":"https://tipwheal.github.io/blog/tags/aruduino/"}]},{"title":"在c++中使用opengl","slug":"opengl","date":"2018-10-20T16:14:20.000Z","updated":"2018-10-21T12:46:25.355Z","comments":true,"path":"2018/10/21/opengl/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/21/opengl/","excerpt":"Shaders哪里放more,这里放more","text":"Shaders哪里放more,这里放more 如何偷懒，如何不偷懒关键字in和out是一个Shaders文件的输入和输出 vertex和fragment shader有一些不同 123in type in_variable_name;out type out_variable_name; 我们惊奇地发现，这个主题还支持glsl uniform是全局变量，后面的shader可以使用 1uniform type variable_name; Sampler通常在fragment shader中定义，是一个uniform类型的变量，但我不是很懂uniform了 取整和插值texelFetch1texelFetch(Sampler, vec2, lod); textureSizelod是什么意思呢level of detail, 有机会试试 百度百科： 多细节层次 LOG技术根据物体模型的节点在显示环境中所处的位置和重要度 给人一种放大缩小的感觉 12345uniform sampler2D texSlot;void main() &#123; vec2 texSize = textureSize(texSlot, 1);&#125; opengl很强","categories":[{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/categories/编程/"},{"name":"c++","slug":"编程/c","permalink":"https://tipwheal.github.io/blog/categories/编程/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://tipwheal.github.io/blog/tags/c/"},{"name":"opengl","slug":"opengl","permalink":"https://tipwheal.github.io/blog/tags/opengl/"},{"name":"图形学","slug":"图形学","permalink":"https://tipwheal.github.io/blog/tags/图形学/"}]},{"title":"如何学习python","slug":"learning-py3","date":"2018-10-16T08:09:30.000Z","updated":"2018-10-21T07:11:53.629Z","comments":true,"path":"2018/10/16/learning-py3/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/16/learning-py3/","excerpt":"这个很难, python很难 Queue是一个线程安全的类吗","text":"这个很难, python很难 Queue是一个线程安全的类吗 wrapper的一个用处，给函数打日志 12345678910111213141516171819import timefrom functools import wrapsdef log(func): @wraps(func) def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print(\"func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;\".format(func.__name__, (args, kwargs), end_time - start_time, result)) return result return wrapper @logdef bar(): return \"hello\" if __name__ == '__main__': bar() 运行结果： 1func bar, param ((), &#123;&#125;), time 0.0, return hello function的属性 1__name__ 偏函数 Partial, 柯里化 Currying 补充一下刚才的代码 123456789101112131415161718192021222324252627import timefrom functools import wraps, partialdef logger(func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(\"func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;\".format(func.__name__, (args, kwargs), end - start, result)) return result return wrapper@loggerdef add(a, b): return a + badd3 = partial(add, 3)if __name__ == '__main__': print(add3.__class__) add3(2) 12&lt;class 'functools.partial'&gt;func add, param ((3, 2), &#123;&#125;), time 0.0, return 5 Uncurrying 1234567891011121314@loggerdef add(a): @logger def add(b): @logger def add(c): return a + b + c return add return addif __name__ == '__main__': print(add(1)(2)(3)) 1234func add, param ((1,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add at 0x0000001567C500D0&gt;func add, param ((2,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add.&lt;locals&gt;.add at 0x00000015678267B8&gt;func add, param ((3,), &#123;&#125;), time 0.0, return 66 如何写一个满足add(2)至无穷个括号的函数？0x0000001567C500D0是内存地址?可以操作内存吗? Generator 123456789a_generator = (item**2 for item in range(200))if __name__ == '__main__': print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) 12345014916 生成质数 1234567891011121314151617181920log_next = logger(next)def prime(): base = 2 while True: is_prime = True for j in range(2, int(math.sqrt(base)) + 1): if base % j == 0: is_prime = False break if is_prime: yield base base += 1if __name__ == '__main__': prime_generator = prime() for i in range(10): log_next(prime_generator) 12345678910func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 2func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 3func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 5func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 7func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 11func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 13func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 17func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 19func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 23func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 29 eval, compile,code ?","categories":[{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/categories/编程/"}],"tags":[{"name":"python","slug":"python","permalink":"https://tipwheal.github.io/blog/tags/python/"}]},{"title":"tcp中的一些细节","slug":"tcp","date":"2018-10-10T11:20:14.000Z","updated":"2018-10-18T09:04:08.469Z","comments":true,"path":"2018/10/10/tcp/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/10/tcp/","excerpt":"RTT(往返时延)RTT的估计和超时 tcp像很多其他的协议一样，超时的时候会重发，但是如何估计往返时间和设定超时时间是一个需要考虑的问题 估计往返时延segment里面有SampleRTT，计算方式是一个segment发出的时间，到ack收到的时间，对于重发的segment则不进行计算 显然这个值会因为网络状况产生一些波动，为了估计一个典型的RTT. TCP维护一个平均值，EstimatedRTT: $$\\mathtt{EstimatedRTT}=(1-\\alpha)·\\mathtt{EstimatedRTT}+\\alpha·\\mathtt{SampleRTT}$$ 其中常用的$\\alpha$值为$0.125$","text":"RTT(往返时延)RTT的估计和超时 tcp像很多其他的协议一样，超时的时候会重发，但是如何估计往返时间和设定超时时间是一个需要考虑的问题 估计往返时延segment里面有SampleRTT，计算方式是一个segment发出的时间，到ack收到的时间，对于重发的segment则不进行计算 显然这个值会因为网络状况产生一些波动，为了估计一个典型的RTT. TCP维护一个平均值，EstimatedRTT: $$\\mathtt{EstimatedRTT}=(1-\\alpha)·\\mathtt{EstimatedRTT}+\\alpha·\\mathtt{SampleRTT}$$ 其中常用的$\\alpha$值为$0.125$ DevRTTDevRTT是用来衡量SampleRTT波动程度的值，公式如下： $$\\mathtt{DevRTT}=(1-\\beta)·\\mathtt{DevRTT}+\\beta·\\mid\\mathtt{SampleRTT}-\\mathtt{EstimatedRTT}\\mid$$ EstimatedRTT和DevRTT都是一个EWMA(指数加权移动平均值) 计算重发间隔有了EstimateRTT和DevRTT，超时时间应当如何计算？首先它需要不小于EstimateRTT，但是又不能太大，防止延迟过高。所以设置方式通常是在EstimateRTT上加一个margin，这个margin的值需要根据SampleRTT的波动情况来设置。因此TCP采用的方式是: $$\\mathtt{TimeoutInterval}=\\mathtt{EstimatedRTT}+4·\\mathtt{DevRTT}$$ 推荐使用的初始值则是1秒，当发生超时时，TimeoutInterval会倍增，直到它被重新计算。 可靠的数据传输TCP在IP协议的基础上提供了可靠的数据传输，解决了数据错误，丢包，重复和顺序错乱的问题。 TCP推荐只维护一个重发的计时器，尽管可能有很多还没有收到ACK的包 一个简化的模型123456789101112131415161718192021222324252627282930NextSeqNum=InitialSeqNumberSendBase=InitialSeqNumberloop (forever) &#123; switch(event) event: data received from application above create TCP segment with sequence number NextSeqNum if (timer currently not running) start timer pass segment to IP NextSeqNum=NextSeqNum+length(data) break; event: timer timeout retransmit not-yet-acknowledged segment with smallest sequence number start timer break; event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase = y if (there are currently any not-yet-acknowledged segments) &#123; start timer &#125; &#125; break;&#125; 有了上述的简化模型我们就可以进行一些场景模拟了 场景一 Host A向Host B发了一个包，seq=92, length=8 bytes, Host B向Host A发了一个ack=100,但是丢了 timer时间到了，Host A重发了这个包 Host B发现是收过的，直接给Host A发了ack=100 Host A收到，继续正常工作 场景二 Host A向Host B发了一个包，seq=92,length=8 bytes Host A向Host B发了一个包, seq=100,length=20 bytes Host B收到seq=92的包，发了一个ack=100 Host B收到seq=100的包，发了一个ack=120 两个ack包没能在超时前收到，Host A重发了seq=92的包 Host B收到seq=92的包，发了一个ack=120 Host A开始发seq=120的包，继续正常工作 场景三 Host A向Host B发了上述1.2.中的两个包 Host B发了一个ack=100，丢了 Host B发了一个ack=120 Host A在超时前收到了sck=120 Host A发送seq=120，继续正常工作 添加翻倍机制在上述的简化模型中，加入如下机制： 每当timeout重发时，将TimeoutInterval翻倍，可以在网络拥塞时产生一些效果 在CSMA/CD中你会看到类似的做法。 快速重传在简单的模型上进行修改，已达到如下效果： Host A向Host B连发了5个包 Host B收到了第一个包，并发送了ack=100 第二个包丢了 Host B在收到3,4,5时连发了三个ack=100 Host A的timer还没有超时，但收到三个duplicated ack了 Host A重发seq=100 12345678910111213event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase=y if (there are currently any not yet acknowledged segments) &#123; start timer &#125; &#125; else &#123; increment number of duplicate ACKs received for y if (number of duplicate ACKs received for y==3) &#123; resend segment with sequence number y &#125; &#125; break; 流控制(暂时略过)TCP连接管理这部分关注的是TCP连接的建立和断开 三次握手Step1客户端向服务端发起请求，带有SYN，并且随机选择一个Seq值x，把报文段发到服务端 Step2服务端收到报文段，分配TCP连接的缓冲区，初始化一些变量。服务端发送一个SYN报文给客户端，ack=x+1，seq为随机值y此报文称为SYNACK报文 Step3客户端收到SYNACK，分配缓冲区，初始化一些变量。向服务端发送ack=y+1,seq=x+1 四次挥手Step1客户端向服务端发送FIN报文 Step2服务端向客户端发送ACK报文 Step3服务端向客户端发送FIN报文 Step4客户端向服务端发送ACK报文。服务端收到ACK后将关闭，客户端等待一段时间后关闭 TCP的生命周期客户端","categories":[],"tags":[{"name":"tcp","slug":"tcp","permalink":"https://tipwheal.github.io/blog/tags/tcp/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://tipwheal.github.io/blog/tags/计算机网络/"}]},{"title":"常见排序算法及应用","slug":"sort","date":"2018-10-09T16:30:55.000Z","updated":"2018-10-10T12:03:35.427Z","comments":true,"path":"2018/10/10/sort/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/10/sort/","excerpt":"","text":"占坑","categories":[],"tags":[]},{"title":"bochs的安装和使用","slug":"bochs","date":"2018-10-09T16:21:07.000Z","updated":"2018-10-10T12:02:30.666Z","comments":true,"path":"2018/10/10/bochs/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/10/bochs/","excerpt":"","text":"占坑","categories":[],"tags":[]},{"title":"java实现一个简单的apriori算法","slug":"apriori","date":"2018-10-09T16:00:09.000Z","updated":"2018-10-10T12:02:47.729Z","comments":true,"path":"2018/10/10/apriori/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/10/apriori/","excerpt":"","text":"占坑","categories":[],"tags":[]},{"title":"计算PageRank","slug":"page-rank","date":"2018-10-09T15:59:05.000Z","updated":"2018-11-06T15:38:12.857Z","comments":true,"path":"2018/10/09/page-rank/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/page-rank/","excerpt":"","text":"这就是我什么都没写的原因吗？","categories":[{"name":"算法","slug":"算法","permalink":"https://tipwheal.github.io/blog/categories/算法/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"算法","slug":"算法","permalink":"https://tipwheal.github.io/blog/tags/算法/"}]},{"title":"奇异值分解的计算方式","slug":"singular-value-decomposition","date":"2018-10-09T15:58:37.000Z","updated":"2018-11-06T15:57:11.598Z","comments":true,"path":"2018/10/09/singular-value-decomposition/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/singular-value-decomposition/","excerpt":"特征值方阵$A$,向量$v$,值$\\lambda$有如下关系 $$Av=\\lambda v$$ 此时称$v$为方阵$A$的特征向量,$\\lambda$则是此特征向量对应的特征值。","text":"特征值方阵$A$,向量$v$,值$\\lambda$有如下关系 $$Av=\\lambda v$$ 此时称$v$为方阵$A$的特征向量,$\\lambda$则是此特征向量对应的特征值。 奇异值分解","categories":[],"tags":[]},{"title":"如何学习ruby","slug":"ruby-learning","date":"2018-10-09T15:46:56.000Z","updated":"2018-11-06T15:38:14.098Z","comments":true,"path":"2018/10/09/ruby-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/ruby-learning/","excerpt":"开发环境搭建windows下的安装这个不难，有时候installer可能被墙","text":"开发环境搭建windows下的安装这个不难，有时候installer可能被墙 CentOS7我需要一个消息队列拯救服务器记笔记一个类1234567class Demo def initialize end def func1 endend","categories":[{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/categories/编程/"},{"name":"草稿","slug":"编程/草稿","permalink":"https://tipwheal.github.io/blog/categories/编程/草稿/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"ruby","slug":"ruby","permalink":"https://tipwheal.github.io/blog/tags/ruby/"},{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/tags/编程/"}]},{"title":"如何学习汉语","slug":"chinese-learning","date":"2018-10-09T15:29:02.000Z","updated":"2018-11-07T02:32:21.694Z","comments":true,"path":"2018/10/09/chinese-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/chinese-learning/","excerpt":"","text":"大学1大学之道，在明明德，在亲民，在止於至善。知止而後有定，定而後能静，静而後能安，安而後能虑，虑而後能得。物有本末，事有终始，知所先後，则近道矣","categories":[{"name":"草稿","slug":"草稿","permalink":"https://tipwheal.github.io/blog/categories/草稿/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"汉语","slug":"汉语","permalink":"https://tipwheal.github.io/blog/tags/汉语/"}]},{"title":"如何学习英语","slug":"english-learning","date":"2018-10-09T15:28:48.000Z","updated":"2018-11-12T12:10:28.943Z","comments":true,"path":"2018/10/09/english-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/english-learning/","excerpt":"","text":"","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"英语","slug":"英语","permalink":"https://tipwheal.github.io/blog/tags/英语/"}]},{"title":"如何学习算法","slug":"algorithm-learning","date":"2018-10-09T15:28:38.000Z","updated":"2018-10-25T12:49:31.908Z","comments":true,"path":"2018/10/09/algorithm-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/algorithm-learning/","excerpt":"我需要学习如下算法需要在45天内完成，那就11.14完成吧 完了 时间已经快到了","text":"我需要学习如下算法需要在45天内完成，那就11.14完成吧 完了 时间已经快到了 快速排序 堆排序 归并排序 选择排序 并查集算法 图的遍历 有向图的DFS 无向图的DFS 最小生成树 图的最短路径 贪心算法 动态规划 NP完全问题 KMP算法 BM算法 近似匹配算法 传递闭包算法 中间值算法 对抗方法 分治算法 哈希算法 快速排序顺便学习C 并查集","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"算法","slug":"算法","permalink":"https://tipwheal.github.io/blog/tags/算法/"}]},{"title":"如何学习c++","slug":"cpp-learning","date":"2018-10-09T15:28:24.000Z","updated":"2018-10-20T16:03:48.162Z","comments":true,"path":"2018/10/09/cpp-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/cpp-learning/","excerpt":"","text":"to do list下面是我计划关注的方面 多态和继承 运算符重载 常用的库 函数模板和类模板 元编程 指针和引用 IO 网络编程 多线程 数据库 开发环境搭建打算使用windows上的能看文件结构的编辑器+在linux上编译执行 搭完了 最后还是用了mingw","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"c++","slug":"c","permalink":"https://tipwheal.github.io/blog/tags/c/"}]},{"title":"如何学习Java","slug":"java-learning","date":"2018-10-09T15:28:08.000Z","updated":"2018-10-09T15:30:21.246Z","comments":true,"path":"2018/10/09/java-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/java-learning/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"如何学习后端","slug":"back-end-learning","date":"2018-10-09T15:27:58.000Z","updated":"2018-10-10T01:14:21.292Z","comments":true,"path":"2018/10/09/back-end-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/back-end-learning/","excerpt":"","text":"我需要学习这些东西有时间做一个思维导图 数据库 hibernate redis 分布式 中间件 linux 网络协议 jvm 设计模式 消息队列","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://tipwheal.github.io/blog/tags/后端/"},{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"}]},{"title":"如何学习前端","slug":"front-end-learning","date":"2018-10-09T15:27:48.000Z","updated":"2018-10-10T01:08:55.399Z","comments":true,"path":"2018/10/09/front-end-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/front-end-learning/","excerpt":"","text":"我需要学习这些东西 CSS JS CSS3 H5 Ajax Grunt Gulp eslint Vue React React Native Angular babel Promise","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://tipwheal.github.io/blog/tags/前端/"},{"name":"web","slug":"web","permalink":"https://tipwheal.github.io/blog/tags/web/"}]},{"title":"三角级数相关","slug":"trigonometric-series","date":"2018-10-09T15:05:27.000Z","updated":"2018-10-20T16:14:05.951Z","comments":true,"path":"2018/10/09/trigonometric-series/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/trigonometric-series/","excerpt":"三角级数$\\quad$一般地，以$A_k\\sin(kx+\\varphi_k)$为项作成的无穷级数 $$\\sum\\limits_{k=0}^{\\infty}A_k\\sin(kx+\\varphi_k)$$ 称为三角级数.（所以首先三角级数都是无穷级数）","text":"三角级数$\\quad$一般地，以$A_k\\sin(kx+\\varphi_k)$为项作成的无穷级数 $$\\sum\\limits_{k=0}^{\\infty}A_k\\sin(kx+\\varphi_k)$$ 称为三角级数.（所以首先三角级数都是无穷级数） 但是有时候也会取如下形式： $$\\frac{a_0}{2}+\\sum\\limits_{k=1}^{\\infty}(a_k\\cos{kx}+b_k\\sin{kx})。$$ 周期函数周期函数有初相,振幅,频率 正弦级数给三角级数中所有的$a_k$取$0$，可以得到如下的正弦级数: $$\\sum\\limits_{k=1}^{\\infty}b_k\\sin{kx}$$ 余弦级数类似的操作可以得到余弦级数 $$\\frac{a_0}{2}+\\sum\\limits_{k=1}^{\\infty}a_k\\cos{kx}$$ 傅里叶级数$$\\begin{split}A_n&amp;=\\frac{1}{\\pi}\\int_0^{2\\pi}f(x)\\cos{nx}\\mathtt{d}x \\\\B_n&amp;=\\frac{1}{\\pi}\\int_0^{2\\pi}f(x)\\sin{nx}\\mathtt{d}x\\end{split}$$ 这里用的符号和上面不一样呢 应该打屁股","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://tipwheal.github.io/blog/tags/数学/"},{"name":"微积分","slug":"微积分","permalink":"https://tipwheal.github.io/blog/tags/微积分/"},{"name":"级数","slug":"级数","permalink":"https://tipwheal.github.io/blog/tags/级数/"}]},{"title":"曲线积分的意义","slug":"curve-line-integral","date":"2018-10-09T14:20:31.000Z","updated":"2018-10-10T02:01:30.335Z","comments":true,"path":"2018/10/09/curve-line-integral/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/curve-line-integral/","excerpt":"曲线积分第一类曲线积分第一类曲线积分用来求一个曲线物体的质量.当物体的密度是一个常值时，只需要将密度乘以弧长就可以得到质量.当物体的密度不均匀时，我们将密度表示为函数$f$，并对函数在曲线上积分，称为第一类曲线积分或者对弧长的曲线积分,记为$\\int_Cf(x,y)\\mathtt{d}s$，即 $$\\int_Cf(x,y)\\mathtt{d}s=\\lim_{\\lambda\\to{0}}\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta{s_i}$$ 其中$f(x,y)$称为被积函数,$C$称为积分曲线,$\\mathtt{d}s$成为弧微分.","text":"曲线积分第一类曲线积分第一类曲线积分用来求一个曲线物体的质量.当物体的密度是一个常值时，只需要将密度乘以弧长就可以得到质量.当物体的密度不均匀时，我们将密度表示为函数$f$，并对函数在曲线上积分，称为第一类曲线积分或者对弧长的曲线积分,记为$\\int_Cf(x,y)\\mathtt{d}s$，即 $$\\int_Cf(x,y)\\mathtt{d}s=\\lim_{\\lambda\\to{0}}\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta{s_i}$$ 其中$f(x,y)$称为被积函数,$C$称为积分曲线,$\\mathtt{d}s$成为弧微分. 我们可以把这个概念扩展到三维空间或者更高维的空间中： $$\\int_Cf(x,y,z)\\mathtt{d}s=\\lim_{\\lambda\\to{0}}\\sum_{i=1}^nf(\\xi_i,\\eta_i,\\zeta_i)\\Delta{s_i}$$ 第二类曲线积分和第一类曲线积分不同，第二类曲线积分可以用来表示变力沿曲线做的功，是有方向的.第二类曲线积分记为: $$\\int_CP(x,y)dx+Q(x,y)dy\\quad或\\quad\\int_C\\boldsymbol{F}(x,y)·\\mathtt{d}\\boldsymbol{r}$$ 特别地，还可以有对某个方向的曲线积分 沿曲线$C$对坐标$x$的曲线积分$$\\int_CP(x,y)dx=\\lim_{\\lambda\\to{0}}\\sum_{i=1}^nP(\\xi_i,\\eta_i)\\Delta{x_i}$$ 沿曲线$C$对坐标$y$的曲线积分$$\\int_CQ(x,y)dy=\\lim_{\\lambda\\to{0}}\\sum_{i=1}^nQ(\\xi_i,\\eta_i)\\Delta{y_i}$$ 既然如此，应该还可以对一个特定的方向积分，就是不知道怎么表示. 如果曲线$C$为闭曲线，则记第二类曲线积分为 $$\\oint_CP(x,y)dx+Q(x,y)dy\\quad或\\quad\\oint_C\\boldsymbol{F}(x,y)·\\mathtt{d}\\boldsymbol{r}$$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://tipwheal.github.io/blog/tags/数学/"},{"name":"微积分","slug":"微积分","permalink":"https://tipwheal.github.io/blog/tags/微积分/"}]},{"title":"格林公式","slug":"Green-Formula","date":"2018-10-09T08:05:23.000Z","updated":"2018-10-10T05:34:44.372Z","comments":true,"path":"2018/10/09/Green-Formula/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/Green-Formula/","excerpt":"格林公式的定义和一些练习学习一下格林公式~","text":"格林公式的定义和一些练习学习一下格林公式~ 简单闭曲线$\\quad$设曲线$C$的参数方程为 $$\\begin{cases}x=\\varphi(t), \\\\y=\\psi(t)\\end{cases}\\quad(\\alpha\\le{t}\\le\\beta).$$ 如果$\\varphi,\\psi$连续，且对不同的参数$t_1,t_2\\in[\\alpha,\\beta]$(不妨设$t_1\\le{t_2}$),$(\\varphi(t_1),\\psi(t_1))=(\\varphi(t_2),\\psi(t_2))$当且仅当$t_1=\\alpha,t_2=\\beta$,则称$C$为简单闭曲线 单连通区域$\\quad$设有一个平面区域$D$,若$D$内的任意一条简单闭曲线所围的部分仍属于$D$，则称$D$为单连通区域，否则称为多连通区域. 格林公式$\\quad$设有界闭区域$D$由逐段光滑曲线$C$围成，函数$P(x,y)$及$Q(x,y)$在$D$上具有一阶连续偏导数，则 $$\\begin{split}\\oint_C{P}\\mathtt{d}x+Q\\mathtt{d}y=\\iint\\limits_D\\left(\\frac{\\partial{Q}}{\\partial{x}}-\\frac{\\partial{P}}{\\partial{y}}\\right)\\mathtt{d}x\\mathtt{d}y\\end{split}$$ 用途通常这些东西总是有用的，我们观察上面的式子。 左边一部分是对光滑曲线$C$的第二类曲线积分，格林公式告诉我们它会与在由曲线围成的平面区域$D$上对两个方向的分量在另一个方向的偏导之差的积分相等. 证明为了加深理解，我们来看一下证明.证明格林公式的时候是拆开证的，也就是 $$\\oint_CP\\mathtt{d}x=-\\iint\\limits_D\\frac{\\partial{P}}{\\partial{y}}\\mathtt{d}x\\mathtt{d}y, \\quad\\oint_CQ\\mathtt{d}y=\\iint\\frac{\\partial{Q}}{\\partial{x}}\\mathtt{d}x\\mathtt{d}y$$ 分以下三种情况讨论: $D$由曲线$y=\\varphi_1(x),y=\\varphi_2(x)$，及直线$x=a,x=b$围成，即 $$D=\\{(x,y)\\mid\\varphi_1(x)\\le{y}\\le\\varphi_2(x),a\\le{x}\\le{b}\\}$$ $D$是单连通区域，且与某些与$y$轴平行的直线相交多于两点 $D$是多联通区域 做题环节题目1求椭圆$x=a\\cos\\theta,y=b\\sin\\theta$所围图形面积. 解： 我们可以从格林公式中得到一个简单的应用： 当$P=-y,Q=x$时，公式就变成了 $$\\begin{split}\\oint_C{-y}\\mathtt{d}x+x\\mathtt{d}y=2\\iint\\limits_D\\mathtt{d}x\\mathtt{d}y\\end{split}$$ 也就是闭区域$D$的面积$A$为: $$\\begin{split}A=\\frac{1}{2}\\oint_C{-y}\\mathtt{d}x+x\\mathtt{d}y\\end{split}$$ 那么求椭圆面积就变为了求解上述式子,有: $$\\begin{split}A&amp;=\\frac{1}{2}\\oint_C{-y}\\mathtt{d}x+x\\mathtt{d}y \\\\&amp;=\\frac{1}{2}\\int_0^{2\\pi}{-b\\sin\\theta}\\mathtt{d}{a\\cos\\theta}+a\\cos\\theta\\mathtt{d}b\\sin\\theta \\\\&amp;=\\frac{1}{2}\\int_0^{2\\pi}{ab\\sin^2\\theta}\\mathtt{d}{\\theta}+ab\\cos^2\\theta\\mathtt{d}\\theta \\\\&amp;=\\frac{1}{2}ab·2\\pi \\\\&amp;=ab\\pi\\end{split}$$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://tipwheal.github.io/blog/tags/数学/"},{"name":"微积分","slug":"微积分","permalink":"https://tipwheal.github.io/blog/tags/微积分/"}]}]}