{"meta":{"title":"当然要记笔记啊","subtitle":"嗯……总之欢迎啊","description":null,"author":"红色鲱鱼","url":"https://tipwheal.github.io/blog"},"pages":[{"title":"","date":"2018-10-09T12:08:49.508Z","updated":"2018-10-09T12:08:49.508Z","comments":true,"path":"hexo-admin-ehc-images.json","permalink":"https://tipwheal.github.io/blog/hexo-admin-ehc-images.json","excerpt":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]"},{"title":"categories","date":"2018-10-21T06:12:28.000Z","updated":"2018-10-26T06:17:26.861Z","comments":true,"path":"categories/index.html","permalink":"https://tipwheal.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"关于这个博客","date":"2018-10-21T06:15:47.000Z","updated":"2018-11-15T06:17:38.675Z","comments":true,"path":"about/index.html","permalink":"https://tipwheal.github.io/blog/about/index.html","excerpt":"","text":"嗨…作为一个害羞的人我不知道怎么打招呼… 欢迎来到我的博客… 我会在这里记一些笔记,分享一些我认为有趣的东西… 有时候也会更新这边的介绍内容… 如果你关注编程,数学或者其他的一些东西… 希望会喜欢~ 如果在南京大学的朋友发现电脑有问题可以点击友情链接进入IT侠公益协会预约维修… 我打算在这里添加一些: 微积分 机器学习算法 方言语音表示 各种编程语言的简单语法 相关的内容，希望可以有一些更深入的东西… 感谢每一位的来访~"},{"title":"schedule","date":"2018-10-21T06:16:02.000Z","updated":"2018-10-21T06:16:34.367Z","comments":true,"path":"schedule/index.html","permalink":"https://tipwheal.github.io/blog/schedule/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-21T06:13:34.000Z","updated":"2018-10-21T06:14:05.738Z","comments":true,"path":"tags/index.html","permalink":"https://tipwheal.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LSTM-CRF模型","slug":"lstm-crf","date":"2018-11-24T06:39:28.000Z","updated":"2018-11-24T07:03:32.251Z","comments":true,"path":"2018/11/24/lstm-crf/","link":"","permalink":"https://tipwheal.github.io/blog/2018/11/24/lstm-crf/","excerpt":"介绍LSTM-CRF是一个用于命名实体识别的内嵌CRF的LSTM模型。 好处呢循环神经网络解决了传统神经网络只依赖于当前输入的问题。长短时记忆网络模型解决了循环神经网络由于梯度爆炸或消失只能学习到短周期的依赖关系问题。","text":"介绍LSTM-CRF是一个用于命名实体识别的内嵌CRF的LSTM模型。 好处呢循环神经网络解决了传统神经网络只依赖于当前输入的问题。长短时记忆网络模型解决了循环神经网络由于梯度爆炸或消失只能学习到短周期的依赖关系问题。 记忆单元LSTM模型通过引入一组记忆单元使得神经网络具有学习遗忘历史信息的能力。 在时刻$t$，记忆单元$c_t$记录了当前时刻为止的所有历史信息，并受三个门的控制： 输入门$i_t$ 遗忘门$c_t$ 输出门$o_t$ 有下列一组计算公式 $$\\begin{split}i_t&amp;=\\sigma(W_ix_t+U_ih_{t-1}+V_ic{t-1}), \\\\f_t&amp;=\\sigma(W_ix_t+U_fh_{t-1}+V_fc{t-1}), \\\\o_t&amp;=\\sigma(W_ox_t+U_oh_{t-1}+V_oc{t}), \\\\\\widetilde{c}_t&amp;=\\tanh(W_cx_t+U_ch{t-1}), \\\\c_t&amp;=f_t\\odot{c}_{t-1}+i_t\\odot\\widetilde{c}_t, \\\\h_t&amp;=o_t\\odot\\tanh(c_t)\\end{split}$$ 其中，$x_t$是当前时刻的输入，$\\sigma$是$\\mathrm{logistic}$函数，$V_i$,$V_f$,$V_o$是对角矩阵。 那么$W$和$U$又是什么呢？","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"https://tipwheal.github.io/blog/categories/自然语言处理/"}],"tags":[{"name":"神经网络","slug":"神经网络","permalink":"https://tipwheal.github.io/blog/tags/神经网络/"},{"name":"LSTM","slug":"LSTM","permalink":"https://tipwheal.github.io/blog/tags/LSTM/"},{"name":"深度学习","slug":"深度学习","permalink":"https://tipwheal.github.io/blog/tags/深度学习/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"https://tipwheal.github.io/blog/tags/自然语言处理/"}]},{"title":"命名实体识别","slug":"name-entities-recognition","date":"2018-11-24T03:00:15.000Z","updated":"2018-11-24T08:48:37.476Z","comments":true,"path":"2018/11/24/name-entities-recognition/","link":"","permalink":"https://tipwheal.github.io/blog/2018/11/24/name-entities-recognition/","excerpt":"收集一些命名实体识别相关的知识 收集一下名词 条件随机场CRF 召回率 F值 viterbi算法 序列标注任务 最大似然迭代算法 MEMM标记偏置 线性条件随机场 层叠条件随机场 前向后向算法 N-最短路径的切分排歧策略 互信息 二值特征函数 L-BGFS算法 牛顿方法 收集一些工具 CRF++","text":"收集一些命名实体识别相关的知识 收集一下名词 条件随机场CRF 召回率 F值 viterbi算法 序列标注任务 最大似然迭代算法 MEMM标记偏置 线性条件随机场 层叠条件随机场 前向后向算法 N-最短路径的切分排歧策略 互信息 二值特征函数 L-BGFS算法 牛顿方法 收集一些工具 CRF++ 收集一些言论文本信息抽取是自然语言处理及文本挖掘领域的一个研究热点。命名实体识别是信息抽取的子任务 主要任务 人名 地名 时间、日期 主要方法 基于规则的方法 基于统计的方法 基于神经网络的方法 语料库 《人民日报》语料库 基于规则的方法构建词规则及句法规则，采用匹配算法自动识别。 基于统计的方法 最大熵模型 隐马尔科夫模型 条件随机场模型 条件随机场模型条件随机场模型(Conditional Random Field,CRF)是一种概率无向图模型。属于判别模型。 摘抄一个 线性链条件随机场模型 在序列标注任务中，随机变量$X=X_1,\\dots,X_{n-1},X_n$是观察序列，随机变量$Y=Y_1,\\dots,Y_{n-1},Y_n$表示与观察序列相对应的标记序列。 引入两个函数$t_k$和$s_k$ $t_k(y_{i-1},y_i,x,i)$是从位置$i$到位置$i-1$的转移特征函数，$s_k(y_i,x,i)$是位置$i$的状态特征函数，$\\lambda_k$、$\\mu_k$是相应的权重。 下面一个是随机变量$Y$的链接条件概率分布： $$P(Y\\vert{X})=\\frac{1}{Z(x)}\\exp\\left(\\sum\\limits_i\\sum\\limits_k\\lambda_kt_k(y_{i-1},y_i,x,i)+\\sum\\limits_i\\sum\\limits_k\\mu_ks_k(y_i,x,i)\\right)$$ 其中 $$Z(x)=\\sum\\limits_y\\exp\\left(\\sum\\limits_i\\sum\\limits_k\\lambda_kt_k(y_{i-1},y_i,x,i)+\\sum\\limits_i\\sum\\limits_k\\mu_ks_k(y_i,x,i)\\right)$$ $\\lambda_k$和$s_k$需要从训练样本中学习得出。 $Z(x)$是一个仅依赖于观测序列$X$的归一化函数。 在序列标注的过程中，条件随机场模型使用$\\mathrm{Viterbi}$方法寻找使$P(Y\\vert{X})$最大的$Y^*$,即$Y^*=\\max_YP(Y\\vert{X})$ 这两个东西看起来有一、复杂 依存句法分析依存句法分析（Dependency Parsing）是一种语言结构，它通过分析语言单位内成分之间的依存关系揭示其语法结构，描述句中词和词之间存在的支配与被支配的依存关系，鉴于依存分析可以找出句子各成分之间的语义修饰关系，因此，可以得到长距离的搭配信息，而且依存分析和句子成分的物理位置无关，更倾向于人的语言直觉，能够提供更精确的结果，因此，依存分析技术得到人们的广泛关注。 P,R,F的关系准确率$P$,就是$\\frac{其中预测正确的数量}{预测是某个类型的实体的数量}$召回率$R$,就是$\\frac{预测到的正确的数量}{所有的正确的数量}$$F$值,计算方式:$\\frac{2\\times{P}\\times{R}}{P+R}$ 新词的发现方式主要有两类方法： 在大规模训练语料的基础上，使用统计方法确定新的单词边界，从而获得候选的单词 在缺乏大规模训练语料，对实验数据文本中的字符串进行频率统计，词频高于阈值的词语作为候选新词 条件随机场中的层叠模型和层次模型 层叠模型(CCRFs)是将多个模型进行线性组合 层次模型采用递归方式将低层模型嵌入高层模型 层次模型训练复杂度和解码复杂度远远高于层叠模型。 参考文献： [1]杨晓燕,徐戈,谢安,庄泽彬.基于词典与条件随机场的中文菜名识别研究[J].电脑知识与技术,2018,17:91-93.[2]周俊生,戴新宇,尹存燕,陈家骏.基于层叠条件随机场模型的中文机构名自动识别[J].电子学报,2006,5:804-809","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"https://tipwheal.github.io/blog/categories/自然语言处理/"}],"tags":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"https://tipwheal.github.io/blog/tags/自然语言处理/"},{"name":"解决方案","slug":"解决方案","permalink":"https://tipwheal.github.io/blog/tags/解决方案/"}]},{"title":"假装复习软件过程管理","slug":"software-process-management","date":"2018-11-23T13:06:13.000Z","updated":"2018-11-23T16:31:30.437Z","comments":true,"path":"2018/11/23/software-process-management/","link":"","permalink":"https://tipwheal.github.io/blog/2018/11/23/software-process-management/","excerpt":"下面是一堆垃圾内容","text":"下面是一堆垃圾内容 常见词汇和术语 软件项目管理 软件生命周期 软件过程 软件过程管理 敏捷软件开发 CMM 瀑布模型 什么是软件开发软件开发的本质困难 复杂性 不可见性 可变性 一致性 这些都是啥 课程目标 理解项目管理的基本概念，掌握项目管理的常用方法。例如估算和计划跟踪，配置管理，风险管理等。 掌握产品质量和过程质量的基本概念，理解通过过程质量管理来保障最终产品质量或服务质量的手段。 掌握软件过程的基本概念，了解常用软件过程方法。理解进行个人级、小组级和组织级软件过程的评价与改进方法。 面临复杂项目的时候，能够选择适用的软件过程，对其进行合理组合和裁剪，并在此基础上合理组织和管理项目开发，达到预先设定的质量要求。 内容安排 概述 基本概念 软件过程的历史演变和经典工作 软件开发和应用特征驱动 当前挑战和未来 不同阶段的经典（瀑布、CMM、敏捷） 技术热点ABC和DevOps 后面的东西 PSP/TSP 敏捷方法 XP、SCRUM DevOps CMM/CMMI 过程组合和裁剪 关键实践讨论 估算、计划和跟踪 质量管理 风险管理 这个内容安排 很乱 很垃圾 教材和参考书 《DevOps原理、方法与实践》机械工业出版社 《软件过程与管理》机械工业出版社 概述软件工程的核心问题软件工程的管理视角成功是否可以复制？ 软件工程的技术视角问题是否可以解决得更好？ 软件项目管理概念管理的三大关键要素 目标 状态 纠偏 软件项目管理 典型的三大目标： 成本、质量、工期 软件项目管理是应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。 估算、计划、跟踪、风险管理、范围管理、人员管理、沟通管理，等等 软件项目管理的管理视角成功是否可以复制？ 软件过程 软件过程是为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合 这组实践之间往往有一定的先后顺序，作为一个整体来实现事先定义的一个或多个目标。 生命周期模型 对软件过程的一种人为划分 广义软件过程理论基石：软件产品和服务的质量，很大程度上取决于生产和维护该软件或者服务的过程的质量。 广义软件过程包括技术、人员以及狭义过程 广义软件过程的同义词：软件开发方法、软件开发过程 包含以下内容： 净室Cleanroom方法、极限编程方法、SCRUM方法、Gate方法 而更一般的，敏捷软件过程/方法、轻量型过程/方法以及重型过程/方法等描述也是恰当的 生命周期模型与软件过程区别和联系 生命周期模型是对一个软件开发过程的人为划分 生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分 生命周期模型往往不包括技术实践 典型的生命周期模型 瀑布模型、迭代式模型、增量模型、螺旋模型、原型法等等 软件过程管理 管理对象是软件过程 管理的目的是为了让软件过程在开发效率、质量等方面有着更好性能绩效（preformance） 软件项目管理： 产品生产管理软件过程管理： 流水线的设计、建设、维护、优化以及升级改造 软件过程管理与软件过程改进两者意思接近 软件过程管理参考模型CMM/CMMI，SPICE等 软件过程改进参考模型PDCA，IDEAL 此处需要一张图 戴明的PCDA循环示意图 思考问题n 是否正确 软件过程管理是软件项目管理应该要实现目标。 在公司导入敏捷过程是我们今年过程改进的主要目标。 XP和CMM是对立的两种软件开发方法 CMM不适合当今互联网环境的项目管理需求 PCDA和IDEAL不适合在敏捷环境中使用 不同的软件开发过程应该使用不同的生命周期模型。反之呢 什么狗屁问题 软件过程的历史演变和经典工作（一）再读《没有银弹》这是一本书，好像讲了不错的东西 软件开发有很多困难，但本质难题是 不可见性 复杂性 可变性 一致性 进一步分析 三个本质难题因项目而异(哪三个) 四大本质难题相互促进 本质难题变化带动软件方法（过程）演变 软件发展三大阶段 软硬件一体化阶段（50年代~70年代） 软件完全依附于硬件 软件作坊 软件成为独立的产品（70年代~90年代） 网络化和服务化（90年代中期迄今） 软件完全依附于硬件软件应用典型特征 软件支持硬件完成计算任务 功能单一 复杂度有限 几乎不需要需求变更 软件开发典型特征 硬件太贵 团队以硬件工程师和数学家为主","categories":[],"tags":[{"name":"呵呵","slug":"呵呵","permalink":"https://tipwheal.github.io/blog/tags/呵呵/"}]},{"title":"余弦相似度计算","slug":"consine-similarity","date":"2018-11-23T11:25:29.000Z","updated":"2018-11-23T13:05:31.317Z","comments":true,"path":"2018/11/23/consine-similarity/","link":"","permalink":"https://tipwheal.github.io/blog/2018/11/23/consine-similarity/","excerpt":"先来一段废话为了计算文本的相似度，我们需要一些算法，比如这个余弦相似度算法。 具体怎么算呢？ 简单一点就是如下: 分词 将所有的词放在一个集合中 根据集合位置给词编码 将两个语句化为向量，维度为所有词的数量，每个维度的数值为这个词在此句子中出现的次数 计算两个向量的余弦值，越大代表越接近","text":"先来一段废话为了计算文本的相似度，我们需要一些算法，比如这个余弦相似度算法。 具体怎么算呢？ 简单一点就是如下: 分词 将所有的词放在一个集合中 根据集合位置给词编码 将两个语句化为向量，维度为所有词的数量，每个维度的数值为这个词在此句子中出现的次数 计算两个向量的余弦值，越大代表越接近 具体操作分词我们可以用jieba分词，因为它分得一定比我好 把所有的词放在集合中遍历一下即可 根据集合位置给词编码变为一个dict并且对应的位置置为数量 转向量先将分词结果替换为数字数组，数字为dict中的值。统计不同位置出现的次数，存在向量中。 计算余弦值使用如下式子计算： $$\\cos(\\theta)=\\frac{\\sum\\limits_{i=1}^n(x_i\\times{y_i})}{\\sqrt{\\sum\\limits_{i=1}^n(x_i)^2}\\times\\sqrt{\\sum\\limits_{i=1}^n(y_i)^2}}$$ 其实就是点积和长度的乘积的比值。 具体影响： 如果两个句子相同的词越多，点积就会越大，相似度也会越高。如果两个句子在相同的词不变的情况下，句子长度越长，相似度则会越低。 如果动脑子想一想，确实还是有道理的，但是似乎有点太简单了一些。 举个栗子首先我们拿到两句话： 这里有一根比较长的棍子这里有一根比较短的棍子 使用jiaba分词的结果： 12[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;长&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;][&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;短&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;] (所以标点符号也算进去了) 然后我们变成这样的集合： 1[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;长&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;, &apos;短&apos;] 然后标个号: 1234567891011&#123; &apos;这里&apos;: 0, &apos;有&apos;: 1, &apos;一根&apos;: 2, &apos;比较&apos;: 3, &apos;长&apos;: 4, &apos;的&apos;: 5, &apos;棍子&apos;: 6, &apos;。&apos;: 7, &apos;短&apos; 8&#125; 然后我们变成两个向量： [1, 1, 1, 1, 1, 1, 1, 1, 0],[1, 1, 1, 1, 0, 1, 1, 1, 1], 最后求得余弦值为$0.875$ 此时我们再掏出一个句子： 这里有一根棍子，它有点长 分个词： 1[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;棍子&apos;, &apos;，&apos;, &apos;它&apos;, &apos;有点&apos;, &apos;长&apos;, &apos;。&apos;] 我们用第一个句子和第二个句子来计算相似度，那么我们得到的集合是: 1[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;长&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;, &apos;，&apos;, &apos;它&apos;, &apos;有点&apos;] 向量: 12[1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0][1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1] 余弦值约等于$0.707$ 结果也就是说，比较和第二，第三句的相似度，第一句和第二句的相似度是比较高的。 虽然它们结构上确实是……比较接近的 但是意思显然…不太对 一个可能有效的改进假设我们有一个反义词集，里面有记录 长/短 是一对反义词，那么我们似乎可以记录一个负值： 比如在计算前两句的相似度时，我们认为长和短在同一个维度，但方向相反，我们如下的位置集合： 1234567891011&#123; &apos;这里&apos;: [0, 1], &apos;有&apos;: [1, 1], &apos;一根&apos;: [2, 1], &apos;比较&apos;: [3, 1], &apos;长&apos;: [4, 1], &apos;的&apos;: [5, 1], &apos;棍子&apos;: [6, 1], &apos;。&apos;: [7, 1], &apos;短&apos; [4, -1]&#125; 那么我们在这个情况下，计算的两个向量为： [1, 1, 1, 1, 1, 1, 1, 1][1, 1, 1, -1, 1, 1, 1, 1] 余弦值只有$0.75$了…感觉总归是有一点效果的，对于当前这种，一个位置意思相反的情况。 要是冒出一个双重否定怎么办呢…也许我们需要加入一些结构分析 感觉会有人用了一些考虑了不同的词的相关性的算法…而不是这样简单粗暴地分成多个维度 或者只是加一个反向 不过暂时应该是够用了 代码实现没有实现","categories":[{"name":"算法","slug":"算法","permalink":"https://tipwheal.github.io/blog/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://tipwheal.github.io/blog/tags/算法/"},{"name":"文本分析","slug":"文本分析","permalink":"https://tipwheal.github.io/blog/tags/文本分析/"},{"name":"相似度计算","slug":"相似度计算","permalink":"https://tipwheal.github.io/blog/tags/相似度计算/"}]},{"title":"常微分方程及解法","slug":"ordinary-differential-equation","date":"2018-11-15T05:07:20.000Z","updated":"2018-11-19T04:34:02.120Z","comments":true,"path":"2018/11/15/ordinary-differential-equation/","link":"","permalink":"https://tipwheal.github.io/blog/2018/11/15/ordinary-differential-equation/","excerpt":"微分方程先整理一些在下面会出现的概念或者定义… 微分方程指一个表示未知函数、未知函数的导数以及自变量之间的关系的方程. 微分方程的阶指微分方程中出现的最高阶导数或偏导数的阶. 常微分方程指自变量个数只有一个的微分方程. 偏微分方程指自变量个数大于一个的微分方程. 举个栗子: $\\frac{\\partial^2{u}}{\\partial{x^2}}+\\frac{\\partial^2{u}}{\\partial{y^2}}+\\frac{\\partial^2{u}}{\\partial{z^2}}=0$是一个二阶偏微分方程， 形如$$F(x,y,y’,…,y^{(n)})=0$$的等式称作一个以$x$为自变量,以$y(x)$为未知函数的n阶常微分方程","text":"微分方程先整理一些在下面会出现的概念或者定义… 微分方程指一个表示未知函数、未知函数的导数以及自变量之间的关系的方程. 微分方程的阶指微分方程中出现的最高阶导数或偏导数的阶. 常微分方程指自变量个数只有一个的微分方程. 偏微分方程指自变量个数大于一个的微分方程. 举个栗子: $\\frac{\\partial^2{u}}{\\partial{x^2}}+\\frac{\\partial^2{u}}{\\partial{y^2}}+\\frac{\\partial^2{u}}{\\partial{z^2}}=0$是一个二阶偏微分方程， 形如$$F(x,y,y’,…,y^{(n)})=0$$的等式称作一个以$x$为自变量,以$y(x)$为未知函数的n阶常微分方程 下面关注的是一些关于常微分方程和它的解法的内容,以及一些常见的问题.偏微分方程不会涉及. 解和通解微分方程有解和通解两个概念, 如果一个函数如$y=x^2+3$带入方程$\\frac{\\mathtt{d}y}{\\mathtt{d}x}=2x$,可以使得方程恒成立，此时称$y=x^2+3$是该方程的一个解. 如果一个$n$阶微分方程有解$y=\\varphi(x, C_1, C_2, …, C_n)$, 并且其中$C_1, C_2, … C_n$是相互独立的任意常数，我们称$y=\\varphi(x,C_1,C_2,…,C_n)$为该方程的通解. 如果一个方程的通解需要使用隐函数来表示，那么我们称这个通解为方程的隐式通解或者通积分 然后我们看一下一阶微分方程的初等解法，出于方便下面描述中的微分方程均指常微分方程. 一阶微分方程的初等解法并不是所有的一阶方程都可以求得由初等函数表示的解,如 $$y’=x^2+y^2$$ 这个方程就不行，至于为什么不行，这个在1838年被刘维尔证明了. 在实际应用中有很多的微分方程都没有可以用初等函数表示的解，但我们还是要讨论一些能解的情况的解放，比如对于一些一阶微分方程我们可以用分离变量的方式来求解，对于一些不可以直接分离变量的方程，我们也可以把它化为可以分离变量的方式再求解……所以分离变量是一个比较有用的方法. 变量分离方程变量分离方程就是形如 $$\\frac{\\mathtt{d}y}{\\mathtt{d}x}=f(x)g(y)$$ 的微分方程，其中$f, g$都是连续函数. 对于这种形式的方程我们可以把与$x$和$y$有关的部分分别放到等号的两边，然后两边同时进行积分操作，就可以得到它的解. 具体如下: $$\\frac{\\mathtt{d}y}{\\mathtt{d}x}=f(x)g(y)$$交换一下x,y的位置$$\\frac{\\mathtt{d}y}{g(y)}=f(x)\\mathtt{d}x$$两边积分$$\\int{\\frac{\\mathtt{d}y}{g(y)}}=\\int{f(x)\\mathtt{d}x}+C$$ 我们得到的式子即为原方程的隐式通解或者通积分，如果我们能求出该式子确定的函数$y=\\phi(x,C)$,那么$y=\\phi(x,C)$是原方程的通解. 注意的是我们在第二行移项的时候将$g(y)$挪到了分母位置，如果有一个$y=y_0$使得$g(y_0)=0$,我们会发现它同样是方程的一个解,但不在上述的通解当中，我们应该将它补上. 也就是如果我们在运算过程中发现了一些使得某些函数定义域或者值域发生改变的情况，我们需要把这个被去除掉的部分补上. 可以化为变量分离方程的情况有一些情况虽然不是可以变量分离的形式，但经过一些简单的变换可以化为上述的$\\frac{\\mathtt{d}y}{\\mathtt{d}x}=f(x)g(y)$的形式, 比如下面的几个: 1. 形如$\\frac{\\mathtt{d}y}{\\mathtt{d}x}=f(ax+by+c)$的微分方程这时候我们设$u=ax+by+c$,则有 $$\\mathtt{d}u=a\\mathtt{d}x+b\\mathtt{d}y$$ 我们需要将$\\mathtt{d}y$和$\\mathtt{d}x$放在一起变为$\\frac{\\mathtt{d}y}{\\mathtt{d}x}$的形式，然后把方程左边的$\\frac{\\mathtt{d}y}{\\mathtt{d}x}$替换掉，从而使方程变为$u$和$x$的变量分离方程,因此有: $$\\frac{\\mathtt{d}u}{\\mathtt{d}x}=a+b\\frac{\\mathtt{d}y}{\\mathtt{d}x}$$ 即 $$\\frac{\\mathtt{d}u}{\\mathtt{d}x}=a+bf(u)$$ 此时式子是一个变量分离方程，那么我们可以根据变量分离方程的方法试着求得通解，然后再将$u$替换为$ax+by+c$即可。比如我们求得通解$u=\\varphi(x,C)$,则原方程的通解为$ax+by+c=\\varphi(x,C)$ 2. 形如$\\frac{\\mathtt{d}y}{\\mathtt{d}x}=f(\\frac{y}{x})$的微分方程此时替换的是$\\frac{y}{x}$,也就是令$u=\\frac{y}{x}$,有: $$x\\mathtt{d}u+u\\mathtt{d}x=dy$$ 还是同样的套路，我们把上式化成: $$\\frac{\\mathtt{d}y}{\\mathtt{d}x}=x\\frac{\\mathtt{d}u}{\\mathtt{d}x}+u$$ 有 $$x\\frac{\\mathtt{d}u}{\\mathtt{d}x}+u=f(u)$$ 我们也可以看出这个方程可以化为变量分离方程，如果我们可以得到通解$u=\\varphi(x,C)$,那么原式通解为$\\frac{y}{x}=\\varphi(x,C)$ 3. 形如$\\frac{\\mathtt{d}y}{\\mathtt{d}x}=f\\left(\\frac{a_1x+b_1x+c}{a_2x+b_2y+c}\\right)$的微分方程一阶线性微分方程一阶线性微分方程指形如 $$\\frac{\\mathtt{d}y}{\\mathtt{d}x}+P(x)y=Q(x)$$ 的方程 一阶齐次线性微分方程当$Q(x)\\equiv0$时，成为一阶齐次线性方程. 一阶非齐次线性微分方程当然是$Q(x)\\not\\equiv0$时了 全微分方程与积分因子全微分方程我们可以将一阶微分方程$y’=f(x,y)$写成如下的形式 $$P(x,y)\\mathtt{d}x+Q(x,y)\\mathtt{d}y=0$$ 此时如果存在可微函数$\\lambda(x,y)$使得$d\\lambda(x,y)=P(x,y)\\mathtt{d}x+Q(x,y)\\mathtt{d}y$,则$P(x,y)\\mathtt{d}x+Q(x,y)\\mathtt{d}y=0$称为恰当微分,该方程称为全微分方程或恰当方程 积分因子有的方程虽然不是全微分方程，但在等式左右两边乘上一个连续可微函数$\\mu(x,y)$,可以化为全微分方程,此时我们称这个$\\mu(x,y)$为这个方程的积分因子. 解的存在唯一性定理我并没有看懂这一整个皮卡存在唯一性定理的证明 利普希兹(Lipschitz)条件我正在试图找一个函数绘图软件画一下… 利普希兹条件是指: 如果存在一个常数$L$，使得一个函数$f(x,y)$在区域$D$内,$\\mid f(x,y_1)-f(x,y_2)\\mid\\le L\\mid(y_1-y_2)\\mid$对所有的$(x,y_1),(x,y_2)\\in{D}$都成立. 我们称$L$是利普希兹常数，称$f(x,y)$在区域$D$上关于$y$满足利普希兹条件. 皮卡存在唯一性定理如果$f(x,y)$在闭区域$D$：$\\mid x-x_0\\mid\\le{a},\\mid y-y_0\\mid\\le{b}$上连续且关于$y$满足利普希兹条件，则方程$\\frac{\\mathtt{d}y}{\\mathtt{d}x}=f(x,y)$存在唯一的解$y=\\phi(x)$,它在区间$\\mid x-x_0\\mid\\le{h}$上连续，且满足初始条件$\\phi(x_0)=y_0$,这里$h=\\min(a,\\frac{b}{M}),M=\\max\\limits_{(x,y)\\in{D}}\\mid f(x,y)\\mid$. 上面的定理描述是针对一阶微分方程的,那么高阶的时候是否成立或者如何描述呢？ 证明起来步骤似乎很长，首先证明有解等价于一个式子，然后构造一个函数序列，证明对于每个n，函数都存在，然后证明函数序列一致收敛，求极限后等于我们要求的式子，最后再证明解的唯一性… 定理的证明我们分五个引理来证明这个定理。方便起见区间$\\mid x-x_0\\mid\\le{h}$取$x_0\\le{x}\\le{x_0+h}$部分来证明. 引理1$y=\\phi(x)$是方程$\\frac{\\mathtt{d}y}{\\mathtt{d}x}=f(x,y)$定义在区间$x_0\\le{x}\\le{x_0+h}$上,且满足初始条件$\\phi(x_0)=y_0$的解，当且仅当$y=\\phi(x)$在$x_0\\le{x}\\le{x_0+h}$上连续且满足 $$\\phi(x)=y_0+\\int_{x_0}^xf(x,y)\\mathtt{d}x,(x_0\\le{x}\\le{x_0+h})$$ (看起来是这样，既满足初始条件，求个导也是$f(x,y)$) 证明: 由于$y=\\phi(x)$是方程的解，有: $$\\frac{\\mathtt{d}\\phi(x)}{\\mathtt{d}x}=f(x,\\phi(x))$$ (直接写y不好吗)那么我们对两边从$x_0$到$x$求定积分就可以得到: $$\\phi(x)-\\phi(x_0)=\\int_{x_0}^xf(x,\\phi(x))\\mathtt{d}x,(x_0\\le{x}\\le{x_0+h})$$ 整理一下就是上面写的式子了. 反过来我们对$\\phi(x)=y_0+\\int_{x_0}^xf(x,y)\\mathtt{d}x,(x_0\\le{x}\\le{x_0+h})$两边求导,可得 $$\\frac{\\mathtt{d}\\phi(x)}{\\mathtt{d}x}=f(x,\\phi(x))$$ (所以$y$和$\\phi$混着写令人非常难受)证明了这个引理就是告诉我们在这个区间上，有解和这个条件是等价的，那我们后面需要证这个条件就可以得出有解. 引理2我们首先构造一个皮卡逐步逼近函数序列: $$\\begin{cases}\\phi_0(x)=y_0 \\\\\\phi_n(x)=y_0+\\int_{x_0}^xf(t,\\phi_{n-1}(t))\\mathtt{d}t,(x_0\\le{x}\\le{x_0+h})\\end{cases}$$ 引理2的内容是： 对于所有的$n$，式中的函数$\\phi_n(x)$在区间$x_0\\le{x}\\le{x_0+h}$都有定义且满足: $$\\mid{\\phi_n(x)-y_0}\\mid\\le{b}$$ 证明： 我们用数学归纳法可以证明。当$n=1$时，$\\phi_1(x)=y_0+\\int_{x_0}^xf(t,y_0)\\mathtt{d}t$，易见这个函数在$x_0\\le{x}\\le{x_0+h}$上有定义，连续且有: $$\\begin{split}\\mid\\phi_1(x)-y_0\\mid&amp;=\\left\\vert\\int_{x_0}^xf(t,y_0)\\mathtt{d}t\\right\\vert \\\\&amp;\\le\\int_{x_0}^x\\vert{f(t,y_0)}\\vert\\mathtt{d}t \\\\&amp;\\le{M(x-x_0)}\\le{Mh}\\le{b}\\end{split}$$ 引理3引理4引理5高阶微分方程这一部分主要是二阶齐次和非齐次微分方程，有时候虽然不好解，但我们的问题可能只是需要一个解，或者由一些条件来计算通解.因此这里是一些性质和定理，可以直接使用. 应用举例emmm,似乎没有那么必要","categories":[{"name":"数学","slug":"数学","permalink":"https://tipwheal.github.io/blog/categories/数学/"},{"name":"微积分","slug":"数学/微积分","permalink":"https://tipwheal.github.io/blog/categories/数学/微积分/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://tipwheal.github.io/blog/tags/数学/"},{"name":"微积分","slug":"微积分","permalink":"https://tipwheal.github.io/blog/tags/微积分/"},{"name":"常微分方程","slug":"常微分方程","permalink":"https://tipwheal.github.io/blog/tags/常微分方程/"}]},{"title":"草稿和素材","slug":"draft","date":"2018-11-06T14:08:46.000Z","updated":"2018-11-24T03:08:54.561Z","comments":true,"path":"2018/11/06/draft/","link":"","permalink":"https://tipwheal.github.io/blog/2018/11/06/draft/","excerpt":"Docker命令相关创建一个网络1docker networt create --subnet=172.18.0.0/16 mynetwork 列出网络1docker network ls","text":"Docker命令相关创建一个网络1docker networt create --subnet=172.18.0.0/16 mynetwork 列出网络1docker network ls 查看镜像信息1docker inspect imageid docker内网访问的问题在一个容器中使用反向代理，代理到其它容器的服务，此容器使用公网，其他容器只能在内网访问。 即比如有如下三个容器A, B, C 然后A容器暴露80端口到公网 B和C暴露各自的服务端口如8080或3000等到内网 然后在A容器中使用反向代理，代理容器B和C中的服务，使得公网可以通过访问A来访问B和C的服务 方案A容器A: 0.0.0.0:80:80容器B: 172.17.0.1:8080:8080容器C: 172.17.0.1:8081:8080 这个方案是可以的 方案B使用172.18.0.0/16网络，分配固定ip，并直接访问也是可以的。比如容器A依旧是 0.0.0.0:80:80容器B使用ip和端口: 172.18.0.10:8080这时也是可以使用的 尝试-p参数-p参数的作用是什么呢，可以的选项是什么呢？0.0.0.0可以用，那么127.0.0.1呢我需要搞清楚这个 如果指派一个ip给容器，就不能再把对应的ip用来映射了比如172.18.0.10:5000:5000 还同时把172.18.0.10分配给一个容器，这是不行的 EXPOSE的作用（去搜索） EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务 –摘自https://yeasy.gitbooks.io/docker_practice/image/dockerfile/expose.html 所以它实际上并不能暴露端口。 如果EXPOSE和-P参数一起使用，则会使用随机映射的策略进行映射，这估计是EXPOSE的唯一作用。 -p 参数则用于手动指定端口映射。 格式大致如ip:宿主机port:容器port 那么这个ip的限制呢？ –link这个命令似乎有神奇的作用，但是我们需要 啊 我只是想让某个docker服务只暴露在内网，为何总是无法访问 难道我需要iptables吗 对应的文档或者源码能不能看一下呢 -p的原理使用iptables可以查看实际上的操作 看起来docker里面应该填网络名。先使用iptables看看效果 Docker的笔记 Docker使用Go语言开发，对进程进行封装隔离，属于操作系统层面的虚拟化技术。比虚拟机技术更加轻便，快捷。 和虚拟机的区别 虚拟机技术在所有在虚拟机之上使用Hypervisor，然后每一个虚拟机包含了应用，库文件以及整个操作系统 Docker技术则使用Docker Engine对所有的容器进行管理，每一个容器中只有应用的库文件 Docker的好处 更高效地利用系统资源（不需要完整的操作系统） 更快的启动时间（比起虚拟机，不需要一个操作系统，所以很快） 一致的运行环境（同样的Dockerfile，不用担心换环境导致错误） 持续交付和部署（使用Dockerfile，CI/CD） 轻松迁移（保证执行环境的一致性） 更轻松的维护和扩展（什么是分层存储和镜像技术？）（有很多官方镜像可以使用） 镜像，容器和仓库镜像Docker镜像相当于一个root文件系统。Linux内核启动后会挂载root文件系统为其提供用户空间支持。 不是很懂这个 分层存储 分层存储利用了Union FS技术,docker的镜像并不是一个单一的文件，而是由一组文件组成。 镜像构建时会一层一层地构建。而在后面的层将无法改动前面的层，删除上一层的文件的操作实际上是将其标志为删除。 好处是在镜像复用或者定制时更加容易。 容器一个镜像可以有多个容器实例，就像面向对象的类和实例的关系一样。 容器可以进行的操作有： 创建 启动 停止 删除 暂停 跟虚拟机可以进行的操作很类似。 特性： 容器的实质是进程，这个进程运行于独立的命名空间 每一个容器运行时，会在镜像上面创建一层容器存储层，最佳实践推荐不要向存储层写入任何数据。 文件操作： 应该使用数据卷或者绑定宿主目录的方式对宿主进行读写，在这种操作方式下，容器消亡时数据并不会消亡。 仓库Docker Registry是一个集中存储、分发镜像的服务 一个Registry里面可以包含多个仓库(Repository),每个仓库可以包含多喝标签(tag); 每个标签对应一个镜像。 比如: ubuntu:16.04 ubuntu:latest 如果在docker pull时不指定标签，使用默认标签latest 常用的公开registry服务： Docker Hub Quay.io Google Container Registry 常见的加速器(Registry Mirror): 阿里云加速器 DaoCloud加速器 (配置方式呢) Dockerfile的操作 每一个指令，都会建立一层存储 FROM选择基础镜像，如果从空白开始则是FROM scratch 使用Go开发的应用很多会使用这种方式来制作镜像，体积更加小巧 RUN用于执行命令行命令，注意进行一个完整的操作时应该将命令行命令写在同一个RUN中，用\\换行 举例如下: (摘自 https://yeasy.gitbooks.io/docker_practice/image/build.html) 1234567891011121314FROM debian:jessieRUN buildDeps='gcc libc6-dev make' \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ &amp;&amp; wget -O redis.tar.gz \"http://download.redis.io/releases/redis-3.2.5.tar.gz\" \\ &amp;&amp; mkdir -p /usr/src/redis \\ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ &amp;&amp; make -C /usr/src/redis \\ &amp;&amp; make -C /usr/src/redis install \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm redis.tar.gz \\ &amp;&amp; rm -r /usr/src/redis \\ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 这样可以避免出无意义的层并且增加镜像的体积(因为后面的层无法真正地删除前面的层的文件) COPYADDCMDENTRYPOINTENVARGVOLUMEEXPOSEWORKDIRUSERHEALTHCHECKONBUILD Docker依旧是一种虚拟化的方式 curl的笔记1curl -X POST http://balabala.com/balabala -d &#123;\\\"param1\\\":\\\"value\\\"&#125; -X可以指定请求方式，比如POST或者GET. -d可以指定参数，但是似乎默认的参数格式是&quot;a=sss&amp;b=c&quot;这种格式 似乎需要额外的参数指定json格式呢 找到了 1curl -H \"Content-Type:application/json\" -X POST http://balabala.com/balabala -d &#123;\\\"param1\\\":\\\"value\\\"&#125; DevOps Development and Operations 特点？好处都有啥？缺点？采用的技术？啊容器和虚拟机是不一样的，曾经有人问我他们的区别 VSCode很好，vscode很好vscode很奇怪 不是很好 材料 md编辑时打开preview关闭很迷 terminal放到右边时如何回到下方 草稿需要的时候从草稿中取出素材已经学过的东西需要被记录 反复反复记录阅读反复阅读记录阅读强化 等待，我总是在等待 我需要把所有的额外的东西先打包一个docker image,而不是每次都操作一次,这太蠢了 人在等待的时候应该做什么 零样本学习pycryptodome什么是pycryptodome呢 源码为什么不看一看源码呢 iptables1iptables -t nat -nL iptables好像很有趣 收藏一个关于docker的gitbook: https://yeasy.gitbooks.io/docker_practice/ gitbook?#的作用比如#test可以访问这里 docker的网络模型导出word的方案telnet使用Spring boot中使用redis做缓存一篇文章： https://www.cnblogs.com/gdpuzxs/p/7222309.html另一篇： https://www.cnblogs.com/badboyf/p/6995202.html?utm_source=itdadao&amp;utm_medium=referral 读读书，涨涨姿势中文文案排版指南https://github.com/mzlogin/chinese-copywriting-guidelines#%E8%B0%81%E5%9C%A8%E8%BF%99%E6%A0%B7%E5%81%9A Go方法以及简单的Hello World1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello, World!\")&#125; 用scratch来制作一个go应用镜像摘自菜鸟教程。 package main代表是一个可独立执行的程序。 fmt是一个IO库。 Println竟然是大写 {的位置1234func main()&#123; fmt.Println(\"Hello, Wolrd\")&#125; 这样写会报错。。。。真的有这个必要吗 for循环12345var list = []int32&#123;1, 2, 3&#125;for i := 0; i &lt; len(list); i++ &#123; fmt.Println(i)&#125; 变量命名使用单驼峰命名方式，不是下划线或者双驼峰 调试1go run filename.go 新问题在docker里面启动的东西能不能把命令行的日志放到日志文件里啊 试一下吧 docker启动一个redis12docker pull redisdocker run -d --name myredis -p 16379:6379 redis --requirepass \"mypassword\" Arduino注释可以使用 舵机使用Servo控制舵机 Serial1Serial.begin(); （Arduino高亮是不是有bug） css3动画真好玩 vue中操作cookieaxios默认不允许请求携带cookie 需要使用 1axios.defaults.withCredetials = true; 接收不到cookie不要使用mock即可 RedisRedis在互联网公司一般有以下应用: String：缓存、限流、计数器、分布式锁、分布式Session Hash：存储用户信息、用户主页访问量、组合查询 List：微博关注人时间轴列表、简单队列 Set：赞、踩、标签、好友关系 Zset：排行榜 Ant DesignKite安装先翻个墙： 123go get -u github.com/gpmgo/gopmgopm get -g -v github.com/koding/kite 创建Project如果使用goland,不要把目录放在GOROOT下面 哈夫曼编码glsl点乘是dot 叉乘是cross 圈乘$\\otimes$是把对应位置乘起来，可以用matrixCompMult 叉乘假设有向量$\\mathrm{A}=(x_1,y_1,z_1),\\mathrm{B}=(x_2,y_2,z_2)$,那么 $$\\mathrm{A}\\times\\mathrm{B}=(y_1\\times{z_2}-y_2\\times{z_1},z_1\\times{x_2}-z_2\\times{x_1},x_1\\times{y_2}-x_2\\times{y_1})$$ 酷Q docker测试一下 123docker pull coolq/wine-coolqmkdir /root/coolq-datadocker run --name=coolq -d -p 8080:9000 -v /root/coolq-data:/home/user/coolq -e VNC_PASSWD=12345678 -e COOLQ_ACCOUNT=123456 coolq/wine-coolq 访问对应的端口输入密码即可操作 进入/root/cooq-data/conf,编辑CQP.cfg,添加 12[Debug]DeveloperMode=1 把开发好的应用拉下来试试（ 接下来开始开发请求模式的机器人 先启动一个docker版flask或者django试试？ 使用HardSourcePlugin加快webpack速度1npm install --save hard-source-webpack-plugin","categories":[{"name":"草稿","slug":"草稿","permalink":"https://tipwheal.github.io/blog/categories/草稿/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"草稿","slug":"草稿","permalink":"https://tipwheal.github.io/blog/tags/草稿/"},{"name":"素材","slug":"素材","permalink":"https://tipwheal.github.io/blog/tags/素材/"},{"name":"乱贴标签","slug":"乱贴标签","permalink":"https://tipwheal.github.io/blog/tags/乱贴标签/"}]},{"title":"git分支操作笔记","slug":"git-branch","date":"2018-11-05T11:19:38.000Z","updated":"2018-11-13T06:25:54.035Z","comments":true,"path":"2018/11/05/git-branch/","link":"","permalink":"https://tipwheal.github.io/blog/2018/11/05/git-branch/","excerpt":"创建本地分支1git checkout -b issn 相当于 12git branch issngit checkout issn","text":"创建本地分支1git checkout -b issn 相当于 12git branch issngit checkout issn 提交更改到分支12git add .git commit -m \"message\" 回到主分支1git checkout master 合并分支1git merge issn","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://tipwheal.github.io/blog/tags/git/"}]},{"title":"$\\mathtt{B\\acute{e}zier}$曲线","slug":"bezier-curve","date":"2018-10-26T04:01:44.000Z","updated":"2018-10-26T06:31:04.414Z","comments":true,"path":"2018/10/26/bezier-curve/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/26/bezier-curve/","excerpt":"$\\mathtt{B\\acute{e}zier}$曲线的定义$$P(t)=\\sum_{i=0}^nB_{i,n}(t)P_i,0\\le{t}\\le{1}$$ 其中， $$B_{i,n}(t)=C_n^it^i(1-t)^{n-i}=\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i},i=0,1,\\dots,n$$","text":"$\\mathtt{B\\acute{e}zier}$曲线的定义$$P(t)=\\sum_{i=0}^nB_{i,n}(t)P_i,0\\le{t}\\le{1}$$ 其中， $$B_{i,n}(t)=C_n^it^i(1-t)^{n-i}=\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i},i=0,1,\\dots,n$$ 当$n=1$时,式子成为 $$\\begin{split}P(t)&amp;=B_{0,1}(t)P_0+B_{1,1}(t)P_1,0\\le{t}\\le{1} \\\\&amp;=(1-t)P_0+tP_1 \\\\&amp;=\\begin{pmatrix}t &amp; 1 \\\\\\end{pmatrix}\\begin{pmatrix}-1 &amp; 1 \\\\1 &amp; 0 \\\\\\end{pmatrix}\\begin{pmatrix}P_0 \\\\P_1 \\\\\\end{pmatrix}\\end{split}$$ 这个式子意味着这是一条从$P_0$连到$P_1$的直线段. 当$n=2$时,式子成为 $$\\begin{split}P(t)&amp;=(1-t)^2P_0+2t(1-t)P_1+t^2P_2 \\\\&amp;=\\begin{pmatrix}t^2 &amp; t &amp; 1 \\\\\\end{pmatrix}\\begin{pmatrix}1 &amp; -2 &amp; 1 \\\\-2 &amp; 2 &amp; 0 \\\\1 &amp; 0 &amp; 0 \\\\\\end{pmatrix}\\begin{pmatrix}P_0 \\\\P_1 \\\\P_2 \\\\\\end{pmatrix}\\end{split}$$ 这次是一个抛物线. 当$n=3$时，式子成为 $$\\begin{split}P(t)&amp;=(1-t)^3P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3 \\\\&amp;=\\begin{pmatrix}t^3 &amp; t^2 &amp; t &amp; 1 \\\\\\end{pmatrix}\\begin{pmatrix}-1 &amp; 3 &amp; -3 &amp; 1 \\\\3 &amp; -6 &amp; 3 &amp; 0 \\\\-3 &amp; 3 &amp; 0 &amp; 0 \\\\1 &amp; 0 &amp; 0 &amp; 0 \\\\\\end{pmatrix}\\begin{pmatrix}P_0 \\\\P_1 \\\\P_2 \\\\P_3 \\\\\\end{pmatrix}\\end{split}$$ 曲线的性质","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://tipwheal.github.io/blog/categories/计算机图形学/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://tipwheal.github.io/blog/tags/计算机图形学/"}]},{"title":"使用docker搭建jenkins","slug":"jenkins","date":"2018-10-25T05:30:31.000Z","updated":"2018-11-06T15:32:15.280Z","comments":true,"path":"2018/10/25/jenkins/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/25/jenkins/","excerpt":"记录一下在CentOS7中使用docker运行一个jenkins…","text":"记录一下在CentOS7中使用docker运行一个jenkins… 环境使用CentOS7 前置条件 需要有tomcat 123docker pull jenkinsmkdir /home/jenkinsdocker run -d --name myjenkins -p 15000:50000 -p 18080:8080 -v /home/jenkins:/home/jenkins jenkins -v和使用copy的效果是如何不同的此处占坑 然后需要找密码了，访问服务器的10080端口可以看到jenkins的登陆界面。该界面会告诉我们密码放在/var/jenkins_home/secrets/initialAdminPassword里面，但我们的jenkins是在docker容器中启动的，所以我们需要到容器内对应的路径去找。 12docker exec -it myjenkins /bin/bash # 进入容器cat /var/jenkins_home/secrets/initialAdminPassword 拿到密码a704538e730d4acda43343383718377c 退出容器 1logout 登陆进去选插件，发现有一堆安装失败了pipeline 后续操作并没有学会…… 自己写一个吧","categories":[{"name":"持续集成","slug":"持续集成","permalink":"https://tipwheal.github.io/blog/categories/持续集成/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://tipwheal.github.io/blog/tags/jenkins/"},{"name":"持续集成","slug":"持续集成","permalink":"https://tipwheal.github.io/blog/tags/持续集成/"}]},{"title":"学习Spring Cloud","slug":"springngcloud","date":"2018-10-24T06:11:57.000Z","updated":"2018-10-25T12:48:13.508Z","comments":true,"path":"2018/10/24/springngcloud/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/24/springngcloud/","excerpt":"Eureka结构有服务注册中心、服务生产者和服务消费者 流程 服务生产者启动时，向服务注册中心注册服务 服务消费者(启动时？)向服务注册中心订阅服务 服务注册中心向服务消费者返回服务生产者的地址 服务消费者调用所需服务","text":"Eureka结构有服务注册中心、服务生产者和服务消费者 流程 服务生产者启动时，向服务注册中心注册服务 服务消费者(启动时？)向服务注册中心订阅服务 服务注册中心向服务消费者返回服务生产者的地址 服务消费者调用所需服务 用途 这是一段话所以注册的服务只是告诉注册中心自己的地址，让注册中心转告给消费者？ 启动方式服务注册中心是一个eureka-server建议禁用client功能 服务生产者是一个eureka-client bus Spring Cloud Bus被翻译为消息总线看起来可以在多个服务中互相传递消息 用途 这也是一段用途，但他不能教我数学 结构 服务A启动，连接总线 服务B启动，连接总线 服务C启动，连接总线 服务A发送消息 服务B、C收到消息 举个栗子 ActiveMQ Kafka RabbitMQ RocketMQ 比较吗？需要比较一下吗？ 使用RabiitMQzuul zuul是一个网关 配置中心spring cloud config/ zoo keeperredis断路器/熔断/Hystrixdevops和aiopsdubbo/zookeeper读论文 我们需要读论文学习","categories":[{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/categories/编程/"},{"name":"Java","slug":"编程/Java","permalink":"https://tipwheal.github.io/blog/categories/编程/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://tipwheal.github.io/blog/tags/SpringCloud/"}]},{"title":"Arduino怎么写呢","slug":"arduino","date":"2018-10-21T12:46:41.000Z","updated":"2018-11-24T07:27:43.014Z","comments":true,"path":"2018/10/21/arduino/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/21/arduino/","excerpt":"整理一些简单语法… 疑问 为什么打开Arduino放着不动，cpu占用率高达30%? Hexo的Arduino高亮似乎有问题 Arduino是垃圾吗？","text":"整理一些简单语法… 疑问 为什么打开Arduino放着不动，cpu占用率高达30%? Hexo的Arduino高亮似乎有问题 Arduino是垃圾吗？ 声明变量12int xxx = 1;boolean yyy = false; 舵机控制使用Servo控制舵机 12345678#include&lt;Servo.h&gt;Servo servo;void setup() &#123; servo.attatch(portNum); servo.write(angle);&#125; 一个简单程序的结构1234567void setup() &#123;&#125;void loop() &#123;&#125; setup会在初始化时执行，loop会持续执行 信号的IO123analogRead(portNum);digitalRead(portNum);digitalWrite(portNum, LOW); 设置输出端口1pinMode(portNum); 串口调试1234567void setup() &#123; Serial.begin(9600); //频率&#125;void loop() &#123; Serial.println(&quot;sdasdas&quot;);&#125;","categories":[{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/categories/编程/"},{"name":"arduino","slug":"编程/arduino","permalink":"https://tipwheal.github.io/blog/categories/编程/arduino/"}],"tags":[{"name":"aruduino","slug":"aruduino","permalink":"https://tipwheal.github.io/blog/tags/aruduino/"}]},{"title":"在c++中使用opengl","slug":"opengl","date":"2018-10-20T16:14:20.000Z","updated":"2018-10-21T12:46:25.355Z","comments":true,"path":"2018/10/21/opengl/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/21/opengl/","excerpt":"Shaders哪里放more,这里放more","text":"Shaders哪里放more,这里放more 如何偷懒，如何不偷懒关键字in和out是一个Shaders文件的输入和输出 vertex和fragment shader有一些不同 123in type in_variable_name;out type out_variable_name; 我们惊奇地发现，这个主题还支持glsl uniform是全局变量，后面的shader可以使用 1uniform type variable_name; Sampler通常在fragment shader中定义，是一个uniform类型的变量，但我不是很懂uniform了 取整和插值texelFetch1texelFetch(Sampler, vec2, lod); textureSizelod是什么意思呢level of detail, 有机会试试 百度百科： 多细节层次 LOG技术根据物体模型的节点在显示环境中所处的位置和重要度 给人一种放大缩小的感觉 12345uniform sampler2D texSlot;void main() &#123; vec2 texSize = textureSize(texSlot, 1);&#125; opengl很强","categories":[{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/categories/编程/"},{"name":"c++","slug":"编程/c","permalink":"https://tipwheal.github.io/blog/categories/编程/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://tipwheal.github.io/blog/tags/c/"},{"name":"opengl","slug":"opengl","permalink":"https://tipwheal.github.io/blog/tags/opengl/"},{"name":"图形学","slug":"图形学","permalink":"https://tipwheal.github.io/blog/tags/图形学/"}]},{"title":"如何学习python","slug":"learning-py3","date":"2018-10-16T08:09:30.000Z","updated":"2018-11-24T06:39:01.604Z","comments":true,"path":"2018/10/16/learning-py3/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/16/learning-py3/","excerpt":"这个很难, python很难 Queue是一个线程安全的类吗","text":"这个很难, python很难 Queue是一个线程安全的类吗 wrapper的一个用处，给函数打日志 12345678910111213141516171819import timefrom functools import wrapsdef log(func): @wraps(func) def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print(\"func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;\".format(func.__name__, (args, kwargs), end_time - start_time, result)) return result return wrapper @logdef bar(): return \"hello\" if __name__ == '__main__': bar() 运行结果： 1func bar, param ((), &#123;&#125;), time 0.0, return hello function的属性 1__name__ 偏函数 Partial, 柯里化 Currying 补充一下刚才的代码 123456789101112131415161718192021222324252627import timefrom functools import wraps, partialdef logger(func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(\"func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;\".format(func.__name__, (args, kwargs), end - start, result)) return result return wrapper@loggerdef add(a, b): return a + badd3 = partial(add, 3)if __name__ == '__main__': print(add3.__class__) add3(2) 12&lt;class 'functools.partial'&gt;func add, param ((3, 2), &#123;&#125;), time 0.0, return 5 Uncurrying 1234567891011121314@loggerdef add(a): @logger def add(b): @logger def add(c): return a + b + c return add return addif __name__ == '__main__': print(add(1)(2)(3)) 1234func add, param ((1,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add at 0x0000001567C500D0&gt;func add, param ((2,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add.&lt;locals&gt;.add at 0x00000015678267B8&gt;func add, param ((3,), &#123;&#125;), time 0.0, return 66 如何写一个满足add(2)至无穷个括号的函数？0x0000001567C500D0是内存地址?可以操作内存吗? Generator 123456789a_generator = (item**2 for item in range(200))if __name__ == '__main__': print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) 12345014916 生成质数 1234567891011121314151617181920log_next = logger(next)def prime(): base = 2 while True: is_prime = True for j in range(2, int(math.sqrt(base)) + 1): if base % j == 0: is_prime = False break if is_prime: yield base base += 1if __name__ == '__main__': prime_generator = prime() for i in range(10): log_next(prime_generator) 12345678910func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 2func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 3func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 5func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 7func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 11func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 13func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 17func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 19func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 23func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 29 eval, compile,code ?","categories":[{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/categories/编程/"}],"tags":[{"name":"python","slug":"python","permalink":"https://tipwheal.github.io/blog/tags/python/"}]},{"title":"tcp中的一些细节","slug":"tcp","date":"2018-10-10T11:20:14.000Z","updated":"2018-10-18T09:04:08.469Z","comments":true,"path":"2018/10/10/tcp/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/10/tcp/","excerpt":"RTT(往返时延)RTT的估计和超时 tcp像很多其他的协议一样，超时的时候会重发，但是如何估计往返时间和设定超时时间是一个需要考虑的问题 估计往返时延segment里面有SampleRTT，计算方式是一个segment发出的时间，到ack收到的时间，对于重发的segment则不进行计算 显然这个值会因为网络状况产生一些波动，为了估计一个典型的RTT. TCP维护一个平均值，EstimatedRTT: $$\\mathtt{EstimatedRTT}=(1-\\alpha)·\\mathtt{EstimatedRTT}+\\alpha·\\mathtt{SampleRTT}$$ 其中常用的$\\alpha$值为$0.125$","text":"RTT(往返时延)RTT的估计和超时 tcp像很多其他的协议一样，超时的时候会重发，但是如何估计往返时间和设定超时时间是一个需要考虑的问题 估计往返时延segment里面有SampleRTT，计算方式是一个segment发出的时间，到ack收到的时间，对于重发的segment则不进行计算 显然这个值会因为网络状况产生一些波动，为了估计一个典型的RTT. TCP维护一个平均值，EstimatedRTT: $$\\mathtt{EstimatedRTT}=(1-\\alpha)·\\mathtt{EstimatedRTT}+\\alpha·\\mathtt{SampleRTT}$$ 其中常用的$\\alpha$值为$0.125$ DevRTTDevRTT是用来衡量SampleRTT波动程度的值，公式如下： $$\\mathtt{DevRTT}=(1-\\beta)·\\mathtt{DevRTT}+\\beta·\\mid\\mathtt{SampleRTT}-\\mathtt{EstimatedRTT}\\mid$$ EstimatedRTT和DevRTT都是一个EWMA(指数加权移动平均值) 计算重发间隔有了EstimateRTT和DevRTT，超时时间应当如何计算？首先它需要不小于EstimateRTT，但是又不能太大，防止延迟过高。所以设置方式通常是在EstimateRTT上加一个margin，这个margin的值需要根据SampleRTT的波动情况来设置。因此TCP采用的方式是: $$\\mathtt{TimeoutInterval}=\\mathtt{EstimatedRTT}+4·\\mathtt{DevRTT}$$ 推荐使用的初始值则是1秒，当发生超时时，TimeoutInterval会倍增，直到它被重新计算。 可靠的数据传输TCP在IP协议的基础上提供了可靠的数据传输，解决了数据错误，丢包，重复和顺序错乱的问题。 TCP推荐只维护一个重发的计时器，尽管可能有很多还没有收到ACK的包 一个简化的模型123456789101112131415161718192021222324252627282930NextSeqNum=InitialSeqNumberSendBase=InitialSeqNumberloop (forever) &#123; switch(event) event: data received from application above create TCP segment with sequence number NextSeqNum if (timer currently not running) start timer pass segment to IP NextSeqNum=NextSeqNum+length(data) break; event: timer timeout retransmit not-yet-acknowledged segment with smallest sequence number start timer break; event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase = y if (there are currently any not-yet-acknowledged segments) &#123; start timer &#125; &#125; break;&#125; 有了上述的简化模型我们就可以进行一些场景模拟了 场景一 Host A向Host B发了一个包，seq=92, length=8 bytes, Host B向Host A发了一个ack=100,但是丢了 timer时间到了，Host A重发了这个包 Host B发现是收过的，直接给Host A发了ack=100 Host A收到，继续正常工作 场景二 Host A向Host B发了一个包，seq=92,length=8 bytes Host A向Host B发了一个包, seq=100,length=20 bytes Host B收到seq=92的包，发了一个ack=100 Host B收到seq=100的包，发了一个ack=120 两个ack包没能在超时前收到，Host A重发了seq=92的包 Host B收到seq=92的包，发了一个ack=120 Host A开始发seq=120的包，继续正常工作 场景三 Host A向Host B发了上述1.2.中的两个包 Host B发了一个ack=100，丢了 Host B发了一个ack=120 Host A在超时前收到了sck=120 Host A发送seq=120，继续正常工作 添加翻倍机制在上述的简化模型中，加入如下机制： 每当timeout重发时，将TimeoutInterval翻倍，可以在网络拥塞时产生一些效果 在CSMA/CD中你会看到类似的做法。 快速重传在简单的模型上进行修改，已达到如下效果： Host A向Host B连发了5个包 Host B收到了第一个包，并发送了ack=100 第二个包丢了 Host B在收到3,4,5时连发了三个ack=100 Host A的timer还没有超时，但收到三个duplicated ack了 Host A重发seq=100 12345678910111213event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase=y if (there are currently any not yet acknowledged segments) &#123; start timer &#125; &#125; else &#123; increment number of duplicate ACKs received for y if (number of duplicate ACKs received for y==3) &#123; resend segment with sequence number y &#125; &#125; break; 流控制(暂时略过)TCP连接管理这部分关注的是TCP连接的建立和断开 三次握手Step1客户端向服务端发起请求，带有SYN，并且随机选择一个Seq值x，把报文段发到服务端 Step2服务端收到报文段，分配TCP连接的缓冲区，初始化一些变量。服务端发送一个SYN报文给客户端，ack=x+1，seq为随机值y此报文称为SYNACK报文 Step3客户端收到SYNACK，分配缓冲区，初始化一些变量。向服务端发送ack=y+1,seq=x+1 四次挥手Step1客户端向服务端发送FIN报文 Step2服务端向客户端发送ACK报文 Step3服务端向客户端发送FIN报文 Step4客户端向服务端发送ACK报文。服务端收到ACK后将关闭，客户端等待一段时间后关闭 TCP的生命周期客户端","categories":[],"tags":[{"name":"tcp","slug":"tcp","permalink":"https://tipwheal.github.io/blog/tags/tcp/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://tipwheal.github.io/blog/tags/计算机网络/"}]},{"title":"常见排序算法及应用","slug":"sort","date":"2018-10-09T16:30:55.000Z","updated":"2018-11-15T05:57:27.202Z","comments":true,"path":"2018/10/10/sort/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/10/sort/","excerpt":"选择排序选择排序的原理非常简单，就是从数组里找到最大的数或者最小的数，把它放在数组的开头，然后再从剩下的部分继续找，直到结束. 使用go实现如下： 12345678910111213141516171819202122232425262728import \"fmt\"func main() &#123; var first = []int32&#123;1, 23, 4, 3, 212, 34&#125; var result = selectSort(first) for i := 0; i &lt; len(result); i += 1 &#123; fmt.Println(result[i]) &#125;&#125;func selectSort(originalList []int32) []int32 &#123; for i := 0; i &lt; len(originalList); i += 1 &#123; var max = originalList[i] var maxP = i for j := i; j &lt; len(originalList); j += 1 &#123; if originalList[j] &gt; max &#123; max = originalList[j] maxP = j &#125; &#125; if maxP != i &#123; var temp = originalList[i] originalList[i] = max originalList[maxP] = temp &#125; &#125; return originalList&#125;","text":"选择排序选择排序的原理非常简单，就是从数组里找到最大的数或者最小的数，把它放在数组的开头，然后再从剩下的部分继续找，直到结束. 使用go实现如下： 12345678910111213141516171819202122232425262728import \"fmt\"func main() &#123; var first = []int32&#123;1, 23, 4, 3, 212, 34&#125; var result = selectSort(first) for i := 0; i &lt; len(result); i += 1 &#123; fmt.Println(result[i]) &#125;&#125;func selectSort(originalList []int32) []int32 &#123; for i := 0; i &lt; len(originalList); i += 1 &#123; var max = originalList[i] var maxP = i for j := i; j &lt; len(originalList); j += 1 &#123; if originalList[j] &gt; max &#123; max = originalList[j] maxP = j &#125; &#125; if maxP != i &#123; var temp = originalList[i] originalList[i] = max originalList[maxP] = temp &#125; &#125; return originalList&#125; 冒泡排序冒泡排序的思想是，（假设需要升序排列）从第一个数开始，不停比较相邻的两个数，将大的放在右边，一轮过后最大的数会到数组的最右边。第二轮则是从第一个数到倒数第二个数…… 如果需要加快一下跳出可以加上一个flag, 如果一轮中没有出现交换，说明排序已经完成了，可以不再继续. 下面是一个go的版本:(只留function) 12345678910111213141516func bubbleSort(originalList []int32) &#123; for i := 0; i &lt; len(originalList)-1; i += 1 &#123; switched := false for j := 0; j &lt; len(originalList)-i-1; j += 1 &#123; if originalList[j] &gt; originalList[j+1] &#123; temp := originalList[j+1] originalList[j+1] = originalList[j] originalList[j] = temp switched = true &#125; &#125; if ! switched &#123; break &#125; &#125;&#125; 插入排序插入排序的思想是将数据插入到已经排序的数组当中，至于如何在数组中查找对应的位置还可以再分一下. 直接插入排序1234567891011121314func directInsertSort(originalList []int32) &#123; for i := 0; i &lt; len(originalList)-1; i += 1 &#123; current := originalList[i+1] for j := 0; j &lt;= i; j++ &#123; if current &lt; originalList[j] &#123; for k := i + 1; k &gt; j; k-- &#123; originalList[k] = originalList[k-1] &#125; originalList[j] = current break &#125; &#125; &#125;&#125; 二分插入排序希尔排序快速排序","categories":[{"name":"算法","slug":"算法","permalink":"https://tipwheal.github.io/blog/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://tipwheal.github.io/blog/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://tipwheal.github.io/blog/tags/排序/"},{"name":"go","slug":"go","permalink":"https://tipwheal.github.io/blog/tags/go/"}]},{"title":"bochs的安装和使用","slug":"bochs","date":"2018-10-09T16:21:07.000Z","updated":"2018-10-10T12:02:30.666Z","comments":true,"path":"2018/10/10/bochs/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/10/bochs/","excerpt":"","text":"占坑","categories":[],"tags":[]},{"title":"java实现一个简单的apriori算法","slug":"apriori","date":"2018-10-09T16:00:09.000Z","updated":"2018-10-10T12:02:47.729Z","comments":true,"path":"2018/10/10/apriori/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/10/apriori/","excerpt":"","text":"占坑","categories":[],"tags":[]},{"title":"计算PageRank","slug":"page-rank","date":"2018-10-09T15:59:05.000Z","updated":"2018-11-13T05:53:58.574Z","comments":true,"path":"2018/10/09/page-rank/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/page-rank/","excerpt":"核心思想PageRank的核心思想： 如果一个网页被很多其他网页链接到，说明这个网页比较重要，PageRank值相对也会比较高. 如果一个PageRank值很高的网页链接到一个其他的网页，那么被链接到的网页PageRank值也会相应提高. 计算公式一般情况下,一个网页的PR值的计算公式如下： $$PR(p_i)=\\alpha\\sum\\limits_{Pj\\in{M_{p_i}}}\\frac{PR(p_j)}{L(P_j)}+\\frac{1-\\alpha}{N}$$","text":"核心思想PageRank的核心思想： 如果一个网页被很多其他网页链接到，说明这个网页比较重要，PageRank值相对也会比较高. 如果一个PageRank值很高的网页链接到一个其他的网页，那么被链接到的网页PageRank值也会相应提高. 计算公式一般情况下,一个网页的PR值的计算公式如下： $$PR(p_i)=\\alpha\\sum\\limits_{Pj\\in{M_{p_i}}}\\frac{PR(p_j)}{L(P_j)}+\\frac{1-\\alpha}{N}$$ 计算公式一般情况下,一个网页的PR值的计算公式如下： $$PR(p_i)=\\alpha\\sum\\limits_{Pj\\in{M_{p_i}}}\\frac{PR(p_j)}{L(P_j)}+\\frac{1-\\alpha}{N}$$ 算法举例PageRank的值物理意义上是一个网页被访问的概率，因此通常对$N$个网页计算时，将每个网页的初始值设为$\\frac{1}{N}$. 假设有4个网页A, B, C, D A有1个出链到D,B有2个出链到A和DC有1个出链到AD有2个出链到B和C 然后我们开始算第一轮: $$\\begin{split}PR(A)&amp;=\\alpha\\left(\\frac{PR(B)}{L(B)}+\\frac{PR(C)}{L(C)}\\right)+\\frac{1-\\alpha}{N} \\\\&amp;=\\alpha\\left(\\frac{\\frac{1}{4}}{2}+\\frac{\\frac{1}{4}}{1}\\right)+\\frac{1-\\alpha}{N} \\\\&amp;=\\frac{17}{20}\\times\\frac{3}{8}+\\frac{3}{80} \\\\&amp;=\\frac{57}{160} \\\\\\end{split}$$$$\\begin{split}PR(B)&amp;=\\alpha\\frac{PR(D)}{L(D)}+\\frac{1-\\alpha}{N} \\\\&amp;=\\frac{23}{160} \\\\\\end{split}$$$$\\begin{split}PR(C)&amp;=\\alpha\\frac{PR(D)}{L(D)}+\\frac{1-\\alpha}{N} \\\\&amp;=\\frac{23}{160} \\\\\\end{split}$$$$\\begin{split}PR(D)&amp;=\\alpha\\left(\\frac{PR(A)}{L(A)}+\\frac{PR(B)}{L(B)}\\right)+\\frac{1-\\alpha}{N} \\\\&amp;=\\alpha\\left(\\frac{\\frac{57}{160}}{1}+\\frac{\\frac{23}{160}}{2}\\right)+\\frac{1-\\alpha}{N} \\\\&amp;=\\frac{17}{20}\\times\\frac{137}{320}+\\frac{3}{80} \\\\&amp;=\\frac{2569}{6400} \\\\\\end{split}$$ 然后再从$PR(A)$开始计算……直到趋于平稳为止. 注意 当一个网页没有出链时认为对所有网页都有出链 为了限制一个网页只有指向自己的出链或者几个出链形成一个圈的情况，我们假定有一个概率$\\alpha$，用户在浏览网页时会有一个这样的概率直接跳转到一个随机的网页，而每个网页的概率是相等的. $\\alpha$值通常取$0.85$","categories":[{"name":"算法","slug":"算法","permalink":"https://tipwheal.github.io/blog/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://tipwheal.github.io/blog/tags/算法/"},{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"PageRank","slug":"PageRank","permalink":"https://tipwheal.github.io/blog/tags/PageRank/"}]},{"title":"奇异值分解的计算方式","slug":"singular-value-decomposition","date":"2018-10-09T15:58:37.000Z","updated":"2018-11-06T15:57:11.598Z","comments":true,"path":"2018/10/09/singular-value-decomposition/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/singular-value-decomposition/","excerpt":"特征值方阵$A$,向量$v$,值$\\lambda$有如下关系 $$Av=\\lambda v$$ 此时称$v$为方阵$A$的特征向量,$\\lambda$则是此特征向量对应的特征值。","text":"特征值方阵$A$,向量$v$,值$\\lambda$有如下关系 $$Av=\\lambda v$$ 此时称$v$为方阵$A$的特征向量,$\\lambda$则是此特征向量对应的特征值。 奇异值分解","categories":[],"tags":[]},{"title":"如何学习ruby","slug":"ruby-learning","date":"2018-10-09T15:46:56.000Z","updated":"2018-11-06T15:38:14.098Z","comments":true,"path":"2018/10/09/ruby-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/ruby-learning/","excerpt":"开发环境搭建windows下的安装这个不难，有时候installer可能被墙","text":"开发环境搭建windows下的安装这个不难，有时候installer可能被墙 CentOS7我需要一个消息队列拯救服务器记笔记一个类1234567class Demo def initialize end def func1 endend","categories":[{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/categories/编程/"},{"name":"草稿","slug":"编程/草稿","permalink":"https://tipwheal.github.io/blog/categories/编程/草稿/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"ruby","slug":"ruby","permalink":"https://tipwheal.github.io/blog/tags/ruby/"},{"name":"编程","slug":"编程","permalink":"https://tipwheal.github.io/blog/tags/编程/"}]},{"title":"收集古诗文","slug":"chinese-learning","date":"2018-10-09T15:29:02.000Z","updated":"2018-11-16T07:32:54.181Z","comments":true,"path":"2018/10/09/chinese-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/chinese-learning/","excerpt":"","text":"大学12大学之道，在明明德，在亲民，在止於至善。知止而後有定，定而後能静，静而後能安，安而後能虑，虑而後能得。物有本末，事有终始，知所先後，则近道矣…… 好事近·梦中作春路雨添花，花动一山春色。行到小溪深处，有黄鹂千百。飞云当面化龙蛇，夭矫转空碧。醉卧古藤阴下，了不知南北。 宫怨李益 露湿晴花春殿香，月明歌吹在昭阳。似将海水添宫漏，共滴长门一夜长。","categories":[{"name":"草稿","slug":"草稿","permalink":"https://tipwheal.github.io/blog/categories/草稿/"}],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"汉语","slug":"汉语","permalink":"https://tipwheal.github.io/blog/tags/汉语/"}]},{"title":"如何学习英语","slug":"english-learning","date":"2018-10-09T15:28:48.000Z","updated":"2018-11-24T06:38:37.317Z","comments":true,"path":"2018/10/09/english-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/english-learning/","excerpt":"如何扩大单词量 如何提高听力","text":"如何扩大单词量 如何提高听力 太难了","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"英语","slug":"英语","permalink":"https://tipwheal.github.io/blog/tags/英语/"}]},{"title":"如何学习算法","slug":"algorithm-learning","date":"2018-10-09T15:28:38.000Z","updated":"2018-10-25T12:49:31.908Z","comments":true,"path":"2018/10/09/algorithm-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/algorithm-learning/","excerpt":"我需要学习如下算法需要在45天内完成，那就11.14完成吧 完了 时间已经快到了","text":"我需要学习如下算法需要在45天内完成，那就11.14完成吧 完了 时间已经快到了 快速排序 堆排序 归并排序 选择排序 并查集算法 图的遍历 有向图的DFS 无向图的DFS 最小生成树 图的最短路径 贪心算法 动态规划 NP完全问题 KMP算法 BM算法 近似匹配算法 传递闭包算法 中间值算法 对抗方法 分治算法 哈希算法 快速排序顺便学习C 并查集","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://tipwheal.github.io/blog/tags/算法/"},{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"}]},{"title":"如何学习c++","slug":"cpp-learning","date":"2018-10-09T15:28:24.000Z","updated":"2018-10-20T16:03:48.162Z","comments":true,"path":"2018/10/09/cpp-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/cpp-learning/","excerpt":"","text":"to do list下面是我计划关注的方面 多态和继承 运算符重载 常用的库 函数模板和类模板 元编程 指针和引用 IO 网络编程 多线程 数据库 开发环境搭建打算使用windows上的能看文件结构的编辑器+在linux上编译执行 搭完了 最后还是用了mingw","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"c++","slug":"c","permalink":"https://tipwheal.github.io/blog/tags/c/"}]},{"title":"如何学习Java","slug":"java-learning","date":"2018-10-09T15:28:08.000Z","updated":"2018-10-09T15:30:21.246Z","comments":true,"path":"2018/10/09/java-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/java-learning/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"如何学习后端","slug":"back-end-learning","date":"2018-10-09T15:27:58.000Z","updated":"2018-10-10T01:14:21.292Z","comments":true,"path":"2018/10/09/back-end-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/back-end-learning/","excerpt":"","text":"我需要学习这些东西有时间做一个思维导图 数据库 hibernate redis 分布式 中间件 linux 网络协议 jvm 设计模式 消息队列","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://tipwheal.github.io/blog/tags/学习/"},{"name":"后端","slug":"后端","permalink":"https://tipwheal.github.io/blog/tags/后端/"}]},{"title":"如何学习前端","slug":"front-end-learning","date":"2018-10-09T15:27:48.000Z","updated":"2018-10-10T01:08:55.399Z","comments":true,"path":"2018/10/09/front-end-learning/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/front-end-learning/","excerpt":"","text":"我需要学习这些东西 CSS JS CSS3 H5 Ajax Grunt Gulp eslint Vue React React Native Angular babel Promise","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://tipwheal.github.io/blog/tags/前端/"},{"name":"web","slug":"web","permalink":"https://tipwheal.github.io/blog/tags/web/"}]},{"title":"三角级数相关","slug":"trigonometric-series","date":"2018-10-09T15:05:27.000Z","updated":"2018-10-20T16:14:05.951Z","comments":true,"path":"2018/10/09/trigonometric-series/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/trigonometric-series/","excerpt":"三角级数$\\quad$一般地，以$A_k\\sin(kx+\\varphi_k)$为项作成的无穷级数 $$\\sum\\limits_{k=0}^{\\infty}A_k\\sin(kx+\\varphi_k)$$ 称为三角级数.（所以首先三角级数都是无穷级数）","text":"三角级数$\\quad$一般地，以$A_k\\sin(kx+\\varphi_k)$为项作成的无穷级数 $$\\sum\\limits_{k=0}^{\\infty}A_k\\sin(kx+\\varphi_k)$$ 称为三角级数.（所以首先三角级数都是无穷级数） 但是有时候也会取如下形式： $$\\frac{a_0}{2}+\\sum\\limits_{k=1}^{\\infty}(a_k\\cos{kx}+b_k\\sin{kx})。$$ 周期函数周期函数有初相,振幅,频率 正弦级数给三角级数中所有的$a_k$取$0$，可以得到如下的正弦级数: $$\\sum\\limits_{k=1}^{\\infty}b_k\\sin{kx}$$ 余弦级数类似的操作可以得到余弦级数 $$\\frac{a_0}{2}+\\sum\\limits_{k=1}^{\\infty}a_k\\cos{kx}$$ 傅里叶级数$$\\begin{split}A_n&amp;=\\frac{1}{\\pi}\\int_0^{2\\pi}f(x)\\cos{nx}\\mathtt{d}x \\\\B_n&amp;=\\frac{1}{\\pi}\\int_0^{2\\pi}f(x)\\sin{nx}\\mathtt{d}x\\end{split}$$ 这里用的符号和上面不一样呢 应该打屁股","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://tipwheal.github.io/blog/tags/数学/"},{"name":"微积分","slug":"微积分","permalink":"https://tipwheal.github.io/blog/tags/微积分/"},{"name":"级数","slug":"级数","permalink":"https://tipwheal.github.io/blog/tags/级数/"}]},{"title":"曲线积分的意义","slug":"curve-line-integral","date":"2018-10-09T14:20:31.000Z","updated":"2018-10-10T02:01:30.335Z","comments":true,"path":"2018/10/09/curve-line-integral/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/curve-line-integral/","excerpt":"曲线积分第一类曲线积分第一类曲线积分用来求一个曲线物体的质量.当物体的密度是一个常值时，只需要将密度乘以弧长就可以得到质量.当物体的密度不均匀时，我们将密度表示为函数$f$，并对函数在曲线上积分，称为第一类曲线积分或者对弧长的曲线积分,记为$\\int_Cf(x,y)\\mathtt{d}s$，即 $$\\int_Cf(x,y)\\mathtt{d}s=\\lim_{\\lambda\\to{0}}\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta{s_i}$$ 其中$f(x,y)$称为被积函数,$C$称为积分曲线,$\\mathtt{d}s$成为弧微分.","text":"曲线积分第一类曲线积分第一类曲线积分用来求一个曲线物体的质量.当物体的密度是一个常值时，只需要将密度乘以弧长就可以得到质量.当物体的密度不均匀时，我们将密度表示为函数$f$，并对函数在曲线上积分，称为第一类曲线积分或者对弧长的曲线积分,记为$\\int_Cf(x,y)\\mathtt{d}s$，即 $$\\int_Cf(x,y)\\mathtt{d}s=\\lim_{\\lambda\\to{0}}\\sum_{i=1}^nf(\\xi_i,\\eta_i)\\Delta{s_i}$$ 其中$f(x,y)$称为被积函数,$C$称为积分曲线,$\\mathtt{d}s$成为弧微分. 我们可以把这个概念扩展到三维空间或者更高维的空间中： $$\\int_Cf(x,y,z)\\mathtt{d}s=\\lim_{\\lambda\\to{0}}\\sum_{i=1}^nf(\\xi_i,\\eta_i,\\zeta_i)\\Delta{s_i}$$ 第二类曲线积分和第一类曲线积分不同，第二类曲线积分可以用来表示变力沿曲线做的功，是有方向的.第二类曲线积分记为: $$\\int_CP(x,y)dx+Q(x,y)dy\\quad或\\quad\\int_C\\boldsymbol{F}(x,y)·\\mathtt{d}\\boldsymbol{r}$$ 特别地，还可以有对某个方向的曲线积分 沿曲线$C$对坐标$x$的曲线积分$$\\int_CP(x,y)dx=\\lim_{\\lambda\\to{0}}\\sum_{i=1}^nP(\\xi_i,\\eta_i)\\Delta{x_i}$$ 沿曲线$C$对坐标$y$的曲线积分$$\\int_CQ(x,y)dy=\\lim_{\\lambda\\to{0}}\\sum_{i=1}^nQ(\\xi_i,\\eta_i)\\Delta{y_i}$$ 既然如此，应该还可以对一个特定的方向积分，就是不知道怎么表示. 如果曲线$C$为闭曲线，则记第二类曲线积分为 $$\\oint_CP(x,y)dx+Q(x,y)dy\\quad或\\quad\\oint_C\\boldsymbol{F}(x,y)·\\mathtt{d}\\boldsymbol{r}$$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://tipwheal.github.io/blog/tags/数学/"},{"name":"微积分","slug":"微积分","permalink":"https://tipwheal.github.io/blog/tags/微积分/"}]},{"title":"格林公式","slug":"Green-Formula","date":"2018-10-09T08:05:23.000Z","updated":"2018-10-10T05:34:44.372Z","comments":true,"path":"2018/10/09/Green-Formula/","link":"","permalink":"https://tipwheal.github.io/blog/2018/10/09/Green-Formula/","excerpt":"格林公式的定义和一些练习学习一下格林公式~","text":"格林公式的定义和一些练习学习一下格林公式~ 简单闭曲线$\\quad$设曲线$C$的参数方程为 $$\\begin{cases}x=\\varphi(t), \\\\y=\\psi(t)\\end{cases}\\quad(\\alpha\\le{t}\\le\\beta).$$ 如果$\\varphi,\\psi$连续，且对不同的参数$t_1,t_2\\in[\\alpha,\\beta]$(不妨设$t_1\\le{t_2}$),$(\\varphi(t_1),\\psi(t_1))=(\\varphi(t_2),\\psi(t_2))$当且仅当$t_1=\\alpha,t_2=\\beta$,则称$C$为简单闭曲线 单连通区域$\\quad$设有一个平面区域$D$,若$D$内的任意一条简单闭曲线所围的部分仍属于$D$，则称$D$为单连通区域，否则称为多连通区域. 格林公式$\\quad$设有界闭区域$D$由逐段光滑曲线$C$围成，函数$P(x,y)$及$Q(x,y)$在$D$上具有一阶连续偏导数，则 $$\\begin{split}\\oint_C{P}\\mathtt{d}x+Q\\mathtt{d}y=\\iint\\limits_D\\left(\\frac{\\partial{Q}}{\\partial{x}}-\\frac{\\partial{P}}{\\partial{y}}\\right)\\mathtt{d}x\\mathtt{d}y\\end{split}$$ 用途通常这些东西总是有用的，我们观察上面的式子。 左边一部分是对光滑曲线$C$的第二类曲线积分，格林公式告诉我们它会与在由曲线围成的平面区域$D$上对两个方向的分量在另一个方向的偏导之差的积分相等. 证明为了加深理解，我们来看一下证明.证明格林公式的时候是拆开证的，也就是 $$\\oint_CP\\mathtt{d}x=-\\iint\\limits_D\\frac{\\partial{P}}{\\partial{y}}\\mathtt{d}x\\mathtt{d}y, \\quad\\oint_CQ\\mathtt{d}y=\\iint\\frac{\\partial{Q}}{\\partial{x}}\\mathtt{d}x\\mathtt{d}y$$ 分以下三种情况讨论: $D$由曲线$y=\\varphi_1(x),y=\\varphi_2(x)$，及直线$x=a,x=b$围成，即 $$D=\\{(x,y)\\mid\\varphi_1(x)\\le{y}\\le\\varphi_2(x),a\\le{x}\\le{b}\\}$$ $D$是单连通区域，且与某些与$y$轴平行的直线相交多于两点 $D$是多联通区域 做题环节题目1求椭圆$x=a\\cos\\theta,y=b\\sin\\theta$所围图形面积. 解： 我们可以从格林公式中得到一个简单的应用： 当$P=-y,Q=x$时，公式就变成了 $$\\begin{split}\\oint_C{-y}\\mathtt{d}x+x\\mathtt{d}y=2\\iint\\limits_D\\mathtt{d}x\\mathtt{d}y\\end{split}$$ 也就是闭区域$D$的面积$A$为: $$\\begin{split}A=\\frac{1}{2}\\oint_C{-y}\\mathtt{d}x+x\\mathtt{d}y\\end{split}$$ 那么求椭圆面积就变为了求解上述式子,有: $$\\begin{split}A&amp;=\\frac{1}{2}\\oint_C{-y}\\mathtt{d}x+x\\mathtt{d}y \\\\&amp;=\\frac{1}{2}\\int_0^{2\\pi}{-b\\sin\\theta}\\mathtt{d}{a\\cos\\theta}+a\\cos\\theta\\mathtt{d}b\\sin\\theta \\\\&amp;=\\frac{1}{2}\\int_0^{2\\pi}{ab\\sin^2\\theta}\\mathtt{d}{\\theta}+ab\\cos^2\\theta\\mathtt{d}\\theta \\\\&amp;=\\frac{1}{2}ab·2\\pi \\\\&amp;=ab\\pi\\end{split}$$","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://tipwheal.github.io/blog/tags/数学/"},{"name":"微积分","slug":"微积分","permalink":"https://tipwheal.github.io/blog/tags/微积分/"}]}]}