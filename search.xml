<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常微分方程及解法]]></title>
    <url>%2Fblog%2F2018%2F11%2F15%2Fordinary-differential-equation%2F</url>
    <content type="text"><![CDATA[微分方程先整理一些在下面会出现的概念或者定义… 微分方程指一个表示未知函数、未知函数的导数以及自变量之间的关系的方程. 微分方程的阶指微分方程中出现的最高阶导数或偏导数的阶. 常微分方程指自变量个数只有一个的微分方程. 偏微分方程指自变量个数大于一个的微分方程. 举个栗子: $\frac{\partial^2{u}}{\partial{x^2}}+\frac{\partial^2{u}}{\partial{y^2}}+\frac{\partial^2{u}}{\partial{z^2}}=0$是一个二阶偏微分方程， 形如$$F(x,y,y’,…,y^{(n)})=0$$的等式称作一个以$x$为自变量,以$y(x)$为未知函数的n阶常微分方程 下面关注的是一些关于常微分方程和它的解法的内容,以及一些常见的问题.偏微分方程不会涉及. 解和通解微分方程有解和通解两个概念, 如果一个函数如$y=x^2+3$带入方程$\frac{\mathtt{d}y}{\mathtt{d}x}=2x$,可以使得方程恒成立，此时称$y=x^2+3$是该方程的一个解. 如果一个$n$阶微分方程有解$y=\varphi(x, C_1, C_2, …, C_n)$, 并且其中$C_1, C_2, … C_n$是相互独立的任意常数，我们称$y=\varphi(x,C_1,C_2,…,C_n)$为该方程的通解. 如果一个方程的通解需要使用隐函数来表示，那么我们称这个通解为方程的隐式通解或者通积分 然后我们看一下一阶微分方程的初等解法，出于方便下面描述中的微分方程均指常微分方程. 一阶微分方程的初等解法并不是所有的一阶方程都可以求得由初等函数表示的解,如 $$y’=x^2+y^2$$ 这个方程就不行，至于为什么不行，这个在1838年被刘维尔证明了. 在实际应用中有很多的微分方程都没有可以用初等函数表示的解，但我们还是要讨论一些能解的情况的解放，比如对于一些一阶微分方程我们可以用分离变量的方式来求解，对于一些不可以直接分离变量的方程，我们也可以把它化为可以分离变量的方式再求解……所以分离变量是一个比较有用的方法. 变量分离方程变量分离方程就是形如 $$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x)g(y)$$ 的微分方程，其中$f, g$都是连续函数. 对于这种形式的方程我们可以把与$x$和$y$有关的部分分别放到等号的两边，然后两边同时进行积分操作，就可以得到它的解. 具体如下: $$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x)g(y)$$交换一下x,y的位置$$\frac{\mathtt{d}y}{g(y)}=f(x)\mathtt{d}x$$两边积分$$\int{\frac{\mathtt{d}y}{g(y)}}=\int{f(x)\mathtt{d}x}+C$$ 我们得到的式子即为原方程的隐式通解或者通积分，如果我们能求出该式子确定的函数$y=\phi(x,C)$,那么$y=\phi(x,C)$是原方程的通解. 注意的是我们在第二行移项的时候将$g(y)$挪到了分母位置，如果有一个$y=y_0$使得$g(y_0)=0$,我们会发现它同样是方程的一个解,但不在上述的通解当中，我们应该将它补上. 也就是如果我们在运算过程中发现了一些使得某些函数定义域或者值域发生改变的情况，我们需要把这个被去除掉的部分补上. 可以化为变量分离方程的情况有一些情况虽然不是可以变量分离的形式，但经过一些简单的变换可以化为上述的$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x)g(y)$的形式, 比如下面的几个: 1. 形如$\frac{\mathtt{d}y}{\mathtt{d}x}=f(ax+by+c)$的微分方程这时候我们设$u=ax+by+c$,则有 $$\mathtt{d}u=a\mathtt{d}x+b\mathtt{d}y$$ 我们需要将$\mathtt{d}y$和$\mathtt{d}x$放在一起变为$\frac{\mathtt{d}y}{\mathtt{d}x}$的形式，然后把方程左边的$\frac{\mathtt{d}y}{\mathtt{d}x}$替换掉，从而使方程变为$u$和$x$的变量分离方程,因此有: $$\frac{\mathtt{d}u}{\mathtt{d}x}=a+b\frac{\mathtt{d}y}{\mathtt{d}x}$$ 即 $$\frac{\mathtt{d}u}{\mathtt{d}x}=a+bf(u)$$ 此时式子是一个变量分离方程，那么我们可以根据变量分离方程的方法试着求得通解，然后再将$u$替换为$ax+by+c$即可。比如我们求得通解$u=\varphi(x,C)$,则原方程的通解为$ax+by+c=\varphi(x,C)$ 2. 形如$\frac{\mathtt{d}y}{\mathtt{d}x}=f(\frac{y}{x})$的微分方程此时替换的是$\frac{y}{x}$,也就是令$u=\frac{y}{x}$,有: $$x\mathtt{d}u+u\mathtt{d}x=dy$$ 还是同样的套路，我们把上式化成: $$\frac{\mathtt{d}y}{\mathtt{d}x}=x\frac{\mathtt{d}u}{\mathtt{d}x}+u$$ 有 $$x\frac{\mathtt{d}u}{\mathtt{d}x}+u=f(u)$$ 我们也可以看出这个方程可以化为变量分离方程，如果我们可以得到通解$u=\varphi(x,C)$,那么原式通解为$\frac{y}{x}=\varphi(x,C)$ 3. 形如$\frac{\mathtt{d}y}{\mathtt{d}x}=f\left(\frac{a_1x+b_1x+c}{a_2x+b_2y+c}\right)$的微分方程一阶线性微分方程一阶线性微分方程指形如 $$\frac{\mathtt{d}y}{\mathtt{d}x}+P(x)y=Q(x)$$ 的方程 一阶齐次线性微分方程当$Q(x)\equiv0$时，成为一阶齐次线性方程. 一阶非齐次线性微分方程当然是$Q(x)\not\equiv0$时了 全微分方程与积分因子全微分方程我们可以将一阶微分方程$y’=f(x,y)$写成如下的形式 $$P(x,y)\mathtt{d}x+Q(x,y)\mathtt{d}y=0$$ 此时如果存在可微函数$\lambda(x,y)$使得$d\lambda(x,y)=P(x,y)\mathtt{d}x+Q(x,y)\mathtt{d}y$,则$P(x,y)\mathtt{d}x+Q(x,y)\mathtt{d}y=0$称为恰当微分,该方程称为全微分方程或恰当方程 积分因子有的方程虽然不是全微分方程，但在等式左右两边乘上一个连续可微函数$\mu(x,y)$,可以化为全微分方程,此时我们称这个$\mu(x,y)$为这个方程的积分因子. 解的存在唯一性定理我并没有看懂这一整个皮卡存在唯一性定理的证明 利普希兹(Lipschitz)条件我正在试图找一个函数绘图软件画一下… 皮卡存在唯一性定理定理的证明高阶微分方程这一部分主要是二阶齐次和非齐次微分方程，有时候虽然不好解，但我们的问题可能只是需要一个解，或者由一些条件来计算通解.因此这里是一些性质和定理，可以直接使用. 应用举例emmm,似乎没有那么必要]]></content>
      <categories>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
        <tag>常微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿和素材]]></title>
    <url>%2Fblog%2F2018%2F11%2F06%2Fdraft%2F</url>
    <content type="text"><![CDATA[Docker命令相关创建一个网络1docker networt create --subnet=172.18.0.0/16 mynetwork 列出网络1docker network ls 查看镜像信息1docker inspect imageid docker内网访问的问题在一个容器中使用反向代理，代理到其它容器的服务，此容器使用公网，其他容器只能在内网访问。 即比如有如下三个容器A, B, C 然后A容器暴露80端口到公网 B和C暴露各自的服务端口如8080或3000等到内网 然后在A容器中使用反向代理，代理容器B和C中的服务，使得公网可以通过访问A来访问B和C的服务 方案A容器A: 0.0.0.0:80:80容器B: 172.17.0.1:8080:8080容器C: 172.17.0.1:8081:8080 这个方案是可以的 方案B使用172.18.0.0/16网络，分配固定ip，并直接访问也是可以的。比如容器A依旧是 0.0.0.0:80:80容器B使用ip和端口: 172.18.0.10:8080这时也是可以使用的 尝试-p参数-p参数的作用是什么呢，可以的选项是什么呢？0.0.0.0可以用，那么127.0.0.1呢我需要搞清楚这个 如果指派一个ip给容器，就不能再把对应的ip用来映射了比如172.18.0.10:5000:5000 还同时把172.18.0.10分配给一个容器，这是不行的 EXPOSE的作用（去搜索） EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务 –摘自https://yeasy.gitbooks.io/docker_practice/image/dockerfile/expose.html 所以它实际上并不能暴露端口。 如果EXPOSE和-P参数一起使用，则会使用随机映射的策略进行映射，这估计是EXPOSE的唯一作用。 -p 参数则用于手动指定端口映射。 格式大致如ip:宿主机port:容器port 那么这个ip的限制呢？ –link这个命令似乎有神奇的作用，但是我们需要 啊 我只是想让某个docker服务只暴露在内网，为何总是无法访问 难道我需要iptables吗 对应的文档或者源码能不能看一下呢 -p的原理使用iptables可以查看实际上的操作 看起来docker里面应该填网络名。先使用iptables看看效果 Docker的笔记 Docker使用Go语言开发，对进程进行封装隔离，属于操作系统层面的虚拟化技术。比虚拟机技术更加轻便，快捷。 和虚拟机的区别 虚拟机技术在所有在虚拟机之上使用Hypervisor，然后每一个虚拟机包含了应用，库文件以及整个操作系统 Docker技术则使用Docker Engine对所有的容器进行管理，每一个容器中只有应用的库文件 Docker的好处 更高效地利用系统资源（不需要完整的操作系统） 更快的启动时间（比起虚拟机，不需要一个操作系统，所以很快） 一致的运行环境（同样的Dockerfile，不用担心换环境导致错误） 持续交付和部署（使用Dockerfile，CI/CD） 轻松迁移（保证执行环境的一致性） 更轻松的维护和扩展（什么是分层存储和镜像技术？）（有很多官方镜像可以使用） 镜像，容器和仓库镜像Docker镜像相当于一个root文件系统。Linux内核启动后会挂载root文件系统为其提供用户空间支持。 不是很懂这个 分层存储 分层存储利用了Union FS技术,docker的镜像并不是一个单一的文件，而是由一组文件组成。 镜像构建时会一层一层地构建。而在后面的层将无法改动前面的层，删除上一层的文件的操作实际上是将其标志为删除。 好处是在镜像复用或者定制时更加容易。 容器一个镜像可以有多个容器实例，就像面向对象的类和实例的关系一样。 容器可以进行的操作有： 创建 启动 停止 删除 暂停 跟虚拟机可以进行的操作很类似。 特性： 容器的实质是进程，这个进程运行于独立的命名空间 每一个容器运行时，会在镜像上面创建一层容器存储层，最佳实践推荐不要向存储层写入任何数据。 文件操作： 应该使用数据卷或者绑定宿主目录的方式对宿主进行读写，在这种操作方式下，容器消亡时数据并不会消亡。 仓库Docker Registry是一个集中存储、分发镜像的服务 一个Registry里面可以包含多个仓库(Repository),每个仓库可以包含多喝标签(tag); 每个标签对应一个镜像。 比如: ubuntu:16.04 ubuntu:latest 如果在docker pull时不指定标签，使用默认标签latest 常用的公开registry服务： Docker Hub Quay.io Google Container Registry 常见的加速器(Registry Mirror): 阿里云加速器 DaoCloud加速器 (配置方式呢) Dockerfile的操作 每一个指令，都会建立一层存储 FROM选择基础镜像，如果从空白开始则是FROM scratch 使用Go开发的应用很多会使用这种方式来制作镜像，体积更加小巧 RUN用于执行命令行命令，注意进行一个完整的操作时应该将命令行命令写在同一个RUN中，用\换行 举例如下: (摘自 https://yeasy.gitbooks.io/docker_practice/image/build.html) 1234567891011121314FROM debian:jessieRUN buildDeps='gcc libc6-dev make' \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install -y $buildDeps \ &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" \ &amp;&amp; mkdir -p /usr/src/redis \ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \ &amp;&amp; make -C /usr/src/redis \ &amp;&amp; make -C /usr/src/redis install \ &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; rm redis.tar.gz \ &amp;&amp; rm -r /usr/src/redis \ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 这样可以避免出无意义的层并且增加镜像的体积(因为后面的层无法真正地删除前面的层的文件) COPYADDCMDENTRYPOINTENVARGVOLUMEEXPOSEWORKDIRUSERHEALTHCHECKONBUILD Docker依旧是一种虚拟化的方式 curl的笔记1curl -X POST http://balabala.com/balabala -d &#123;\"param1\":\"value\"&#125; -X可以指定请求方式，比如POST或者GET. -d可以指定参数，但是似乎默认的参数格式是&quot;a=sss&amp;b=c&quot;这种格式 似乎需要额外的参数指定json格式呢 找到了 1curl -H "Content-Type:application/json" -X POST http://balabala.com/balabala -d &#123;\"param1\":\"value\"&#125; DevOps Development and Operations 特点？好处都有啥？缺点？采用的技术？啊容器和虚拟机是不一样的，曾经有人问我他们的区别 VSCode很好，vscode很好vscode很奇怪 不是很好 材料 md编辑时打开preview关闭很迷 terminal放到右边时如何回到下方 草稿需要的时候从草稿中取出素材已经学过的东西需要被记录 反复反复记录阅读反复阅读记录阅读强化 等待，我总是在等待 我需要把所有的额外的东西先打包一个docker image,而不是每次都操作一次,这太蠢了 人在等待的时候应该做什么 零样本学习pycryptodome什么是pycryptodome呢 源码为什么不看一看源码呢 iptables1iptables -t nat -nL iptables好像很有趣 收藏一个关于docker的gitbook: https://yeasy.gitbooks.io/docker_practice/ gitbook?#的作用比如#test可以访问这里 docker的网络模型导出word的方案telnet使用Spring boot中使用redis做缓存一篇文章： https://www.cnblogs.com/gdpuzxs/p/7222309.html另一篇： https://www.cnblogs.com/badboyf/p/6995202.html?utm_source=itdadao&amp;utm_medium=referral 读读书，涨涨姿势中文文案排版指南https://github.com/mzlogin/chinese-copywriting-guidelines#%E8%B0%81%E5%9C%A8%E8%BF%99%E6%A0%B7%E5%81%9A Go方法以及简单的Hello World1234567package mainimport "fmt"func main() &#123; fmt.Println("Hello, World!")&#125; 用scratch来制作一个go应用镜像摘自菜鸟教程。 package main代表是一个可独立执行的程序。 fmt是一个IO库。 Println竟然是大写 {的位置1234func main()&#123; fmt.Println("Hello, Wolrd")&#125; 这样写会报错。。。。真的有这个必要吗 for循环12345var list = []int32&#123;1, 2, 3&#125;for i := 0; i &lt; len(list); i++ &#123; fmt.Println(i)&#125; 变量命名使用单驼峰命名方式，不是下划线或者双驼峰 调试1go run filename.go 新问题在docker里面启动的东西能不能把命令行的日志放到日志文件里啊 试一下吧 docker启动一个redis12docker pull redisdocker run -d --name myredis -p 16379:6379 redis --requirepass "mypassword" Arduino注释可以使用 舵机使用Servo控制舵机 Serial1Serial.begin(); （Arduino高亮是不是有bug） css3动画真好玩 vue中操作cookieaxios默认不允许请求携带cookie 需要使用 1axios.defaults.withCredetials = true; 接收不到cookie不要使用mock即可 RedisRedis在互联网公司一般有以下应用: String：缓存、限流、计数器、分布式锁、分布式Session Hash：存储用户信息、用户主页访问量、组合查询 List：微博关注人时间轴列表、简单队列 Set：赞、踩、标签、好友关系 Zset：排行榜 Ant DesignKite安装先翻个墙： 123go get -u github.com/gpmgo/gopmgopm get -g -v github.com/koding/kite 创建Project如果使用goland,不要把目录放在GOROOT下面 哈夫曼编码]]></content>
      <categories>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>草稿</tag>
        <tag>素材</tag>
        <tag>乱贴标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git分支操作笔记]]></title>
    <url>%2Fblog%2F2018%2F11%2F05%2Fgit-branch%2F</url>
    <content type="text"><![CDATA[创建本地分支1git checkout -b issn 相当于 12git branch issngit checkout issn 提交更改到分支12git add .git commit -m "message" 回到主分支1git checkout master 合并分支1git merge issn]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$\mathtt{B\acute{e}zier}$曲线]]></title>
    <url>%2Fblog%2F2018%2F10%2F26%2Fbezier-curve%2F</url>
    <content type="text"><![CDATA[$\mathtt{B\acute{e}zier}$曲线的定义$$P(t)=\sum_{i=0}^nB_{i,n}(t)P_i,0\le{t}\le{1}$$ 其中， $$B_{i,n}(t)=C_n^it^i(1-t)^{n-i}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i},i=0,1,\dots,n$$ 当$n=1$时,式子成为 $$\begin{split}P(t)&amp;=B_{0,1}(t)P_0+B_{1,1}(t)P_1,0\le{t}\le{1} \\&amp;=(1-t)P_0+tP_1 \\&amp;=\begin{pmatrix}t &amp; 1 \\\end{pmatrix}\begin{pmatrix}-1 &amp; 1 \\1 &amp; 0 \\\end{pmatrix}\begin{pmatrix}P_0 \\P_1 \\\end{pmatrix}\end{split}$$ 这个式子意味着这是一条从$P_0$连到$P_1$的直线段. 当$n=2$时,式子成为 $$\begin{split}P(t)&amp;=(1-t)^2P_0+2t(1-t)P_1+t^2P_2 \\&amp;=\begin{pmatrix}t^2 &amp; t &amp; 1 \\\end{pmatrix}\begin{pmatrix}1 &amp; -2 &amp; 1 \\-2 &amp; 2 &amp; 0 \\1 &amp; 0 &amp; 0 \\\end{pmatrix}\begin{pmatrix}P_0 \\P_1 \\P_2 \\\end{pmatrix}\end{split}$$ 这次是一个抛物线. 当$n=3$时，式子成为 $$\begin{split}P(t)&amp;=(1-t)^3P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3 \\&amp;=\begin{pmatrix}t^3 &amp; t^2 &amp; t &amp; 1 \\\end{pmatrix}\begin{pmatrix}-1 &amp; 3 &amp; -3 &amp; 1 \\3 &amp; -6 &amp; 3 &amp; 0 \\-3 &amp; 3 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 0 \\\end{pmatrix}\begin{pmatrix}P_0 \\P_1 \\P_2 \\P_3 \\\end{pmatrix}\end{split}$$ 曲线的性质]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker搭建jenkins]]></title>
    <url>%2Fblog%2F2018%2F10%2F25%2Fjenkins%2F</url>
    <content type="text"><![CDATA[记录一下在CentOS7中使用docker运行一个jenkins… 环境使用CentOS7 前置条件 需要有tomcat 123docker pull jenkinsmkdir /home/jenkinsdocker run -d --name myjenkins -p 15000:50000 -p 18080:8080 -v /home/jenkins:/home/jenkins jenkins -v和使用copy的效果是如何不同的此处占坑 然后需要找密码了，访问服务器的10080端口可以看到jenkins的登陆界面。该界面会告诉我们密码放在/var/jenkins_home/secrets/initialAdminPassword里面，但我们的jenkins是在docker容器中启动的，所以我们需要到容器内对应的路径去找。 12docker exec -it myjenkins /bin/bash # 进入容器cat /var/jenkins_home/secrets/initialAdminPassword 拿到密码a704538e730d4acda43343383718377c 退出容器 1logout 登陆进去选插件，发现有一堆安装失败了pipeline 后续操作并没有学会…… 自己写一个吧]]></content>
      <categories>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Spring Cloud]]></title>
    <url>%2Fblog%2F2018%2F10%2F24%2Fspringngcloud%2F</url>
    <content type="text"><![CDATA[Eureka结构有服务注册中心、服务生产者和服务消费者 流程 服务生产者启动时，向服务注册中心注册服务 服务消费者(启动时？)向服务注册中心订阅服务 服务注册中心向服务消费者返回服务生产者的地址 服务消费者调用所需服务 用途 这是一段话所以注册的服务只是告诉注册中心自己的地址，让注册中心转告给消费者？ 启动方式服务注册中心是一个eureka-server建议禁用client功能 服务生产者是一个eureka-client bus Spring Cloud Bus被翻译为消息总线看起来可以在多个服务中互相传递消息 用途 这也是一段用途，但他不能教我数学 结构 服务A启动，连接总线 服务B启动，连接总线 服务C启动，连接总线 服务A发送消息 服务B、C收到消息 举个栗子 ActiveMQ Kafka RabbitMQ RocketMQ 比较吗？需要比较一下吗？ 使用RabiitMQzuul zuul是一个网关 配置中心spring cloud config/ zoo keeperredis断路器/熔断/Hystrixdevops和aiopsdubbo/zookeeper读论文 我们需要读论文学习]]></content>
      <categories>
        <category>编程</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arduino怎么写呢]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2Farduino%2F</url>
    <content type="text"><![CDATA[但是这里是空的呀…… 空的就空的，这个东西好无聊的 为什么打开Arduino放着不动，cpu占用率高达30%?]]></content>
      <categories>
        <category>编程</category>
        <category>arduino</category>
      </categories>
      <tags>
        <tag>aruduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在c++中使用opengl]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2Fopengl%2F</url>
    <content type="text"><![CDATA[Shaders哪里放more,这里放more 如何偷懒，如何不偷懒关键字in和out是一个Shaders文件的输入和输出 vertex和fragment shader有一些不同 123in type in_variable_name;out type out_variable_name; 我们惊奇地发现，这个主题还支持glsl uniform是全局变量，后面的shader可以使用 1uniform type variable_name; Sampler通常在fragment shader中定义，是一个uniform类型的变量，但我不是很懂uniform了 取整和插值texelFetch1texelFetch(Sampler, vec2, lod); textureSizelod是什么意思呢level of detail, 有机会试试 百度百科： 多细节层次 LOG技术根据物体模型的节点在显示环境中所处的位置和重要度 给人一种放大缩小的感觉 12345uniform sampler2D texSlot;void main() &#123; vec2 texSize = textureSize(texSlot, 1);&#125; opengl很强]]></content>
      <categories>
        <category>编程</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>opengl</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习python]]></title>
    <url>%2Fblog%2F2018%2F10%2F16%2Flearning-py3%2F</url>
    <content type="text"><![CDATA[这个很难, python很难 Queue是一个线程安全的类吗 wrapper的一个用处，给函数打日志 12345678910111213141516171819import timefrom functools import wrapsdef log(func): @wraps(func) def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print("func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;".format(func.__name__, (args, kwargs), end_time - start_time, result)) return result return wrapper @logdef bar(): return "hello" if __name__ == '__main__': bar() 运行结果： 1func bar, param ((), &#123;&#125;), time 0.0, return hello function的属性 1__name__ 偏函数 Partial, 柯里化 Currying 补充一下刚才的代码 123456789101112131415161718192021222324252627import timefrom functools import wraps, partialdef logger(func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print("func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;".format(func.__name__, (args, kwargs), end - start, result)) return result return wrapper@loggerdef add(a, b): return a + badd3 = partial(add, 3)if __name__ == '__main__': print(add3.__class__) add3(2) 12&lt;class 'functools.partial'&gt;func add, param ((3, 2), &#123;&#125;), time 0.0, return 5 Uncurrying 1234567891011121314@loggerdef add(a): @logger def add(b): @logger def add(c): return a + b + c return add return addif __name__ == '__main__': print(add(1)(2)(3)) 1234func add, param ((1,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add at 0x0000001567C500D0&gt;func add, param ((2,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add.&lt;locals&gt;.add at 0x00000015678267B8&gt;func add, param ((3,), &#123;&#125;), time 0.0, return 66 如何写一个满足add(2)至无穷个括号的函数？0x0000001567C500D0是内存地址?可以操作内存吗? Generator 123456789a_generator = (item**2 for item in range(200))if __name__ == '__main__': print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) 12345014916 生成质数 1234567891011121314151617181920log_next = logger(next)def prime(): base = 2 while True: is_prime = True for j in range(2, int(math.sqrt(base)) + 1): if base % j == 0: is_prime = False break if is_prime: yield base base += 1if __name__ == '__main__': prime_generator = prime() for i in range(10): log_next(prime_generator) 12345678910func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 2func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 3func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 5func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 7func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 11func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 13func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 17func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 19func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 23func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 29 eval, compile,code ?]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp中的一些细节]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Ftcp%2F</url>
    <content type="text"><![CDATA[RTT(往返时延)RTT的估计和超时 tcp像很多其他的协议一样，超时的时候会重发，但是如何估计往返时间和设定超时时间是一个需要考虑的问题 估计往返时延segment里面有SampleRTT，计算方式是一个segment发出的时间，到ack收到的时间，对于重发的segment则不进行计算 显然这个值会因为网络状况产生一些波动，为了估计一个典型的RTT. TCP维护一个平均值，EstimatedRTT: $$\mathtt{EstimatedRTT}=(1-\alpha)·\mathtt{EstimatedRTT}+\alpha·\mathtt{SampleRTT}$$ 其中常用的$\alpha$值为$0.125$ DevRTTDevRTT是用来衡量SampleRTT波动程度的值，公式如下： $$\mathtt{DevRTT}=(1-\beta)·\mathtt{DevRTT}+\beta·\mid\mathtt{SampleRTT}-\mathtt{EstimatedRTT}\mid$$ EstimatedRTT和DevRTT都是一个EWMA(指数加权移动平均值) 计算重发间隔有了EstimateRTT和DevRTT，超时时间应当如何计算？首先它需要不小于EstimateRTT，但是又不能太大，防止延迟过高。所以设置方式通常是在EstimateRTT上加一个margin，这个margin的值需要根据SampleRTT的波动情况来设置。因此TCP采用的方式是: $$\mathtt{TimeoutInterval}=\mathtt{EstimatedRTT}+4·\mathtt{DevRTT}$$ 推荐使用的初始值则是1秒，当发生超时时，TimeoutInterval会倍增，直到它被重新计算。 可靠的数据传输TCP在IP协议的基础上提供了可靠的数据传输，解决了数据错误，丢包，重复和顺序错乱的问题。 TCP推荐只维护一个重发的计时器，尽管可能有很多还没有收到ACK的包 一个简化的模型123456789101112131415161718192021222324252627282930NextSeqNum=InitialSeqNumberSendBase=InitialSeqNumberloop (forever) &#123; switch(event) event: data received from application above create TCP segment with sequence number NextSeqNum if (timer currently not running) start timer pass segment to IP NextSeqNum=NextSeqNum+length(data) break; event: timer timeout retransmit not-yet-acknowledged segment with smallest sequence number start timer break; event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase = y if (there are currently any not-yet-acknowledged segments) &#123; start timer &#125; &#125; break;&#125; 有了上述的简化模型我们就可以进行一些场景模拟了 场景一 Host A向Host B发了一个包，seq=92, length=8 bytes, Host B向Host A发了一个ack=100,但是丢了 timer时间到了，Host A重发了这个包 Host B发现是收过的，直接给Host A发了ack=100 Host A收到，继续正常工作 场景二 Host A向Host B发了一个包，seq=92,length=8 bytes Host A向Host B发了一个包, seq=100,length=20 bytes Host B收到seq=92的包，发了一个ack=100 Host B收到seq=100的包，发了一个ack=120 两个ack包没能在超时前收到，Host A重发了seq=92的包 Host B收到seq=92的包，发了一个ack=120 Host A开始发seq=120的包，继续正常工作 场景三 Host A向Host B发了上述1.2.中的两个包 Host B发了一个ack=100，丢了 Host B发了一个ack=120 Host A在超时前收到了sck=120 Host A发送seq=120，继续正常工作 添加翻倍机制在上述的简化模型中，加入如下机制： 每当timeout重发时，将TimeoutInterval翻倍，可以在网络拥塞时产生一些效果 在CSMA/CD中你会看到类似的做法。 快速重传在简单的模型上进行修改，已达到如下效果： Host A向Host B连发了5个包 Host B收到了第一个包，并发送了ack=100 第二个包丢了 Host B在收到3,4,5时连发了三个ack=100 Host A的timer还没有超时，但收到三个duplicated ack了 Host A重发seq=100 12345678910111213event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase=y if (there are currently any not yet acknowledged segments) &#123; start timer &#125; &#125; else &#123; increment number of duplicate ACKs received for y if (number of duplicate ACKs received for y==3) &#123; resend segment with sequence number y &#125; &#125; break; 流控制(暂时略过)TCP连接管理这部分关注的是TCP连接的建立和断开 三次握手Step1客户端向服务端发起请求，带有SYN，并且随机选择一个Seq值x，把报文段发到服务端 Step2服务端收到报文段，分配TCP连接的缓冲区，初始化一些变量。服务端发送一个SYN报文给客户端，ack=x+1，seq为随机值y此报文称为SYNACK报文 Step3客户端收到SYNACK，分配缓冲区，初始化一些变量。向服务端发送ack=y+1,seq=x+1 四次挥手Step1客户端向服务端发送FIN报文 Step2服务端向客户端发送ACK报文 Step3服务端向客户端发送FIN报文 Step4客户端向服务端发送ACK报文。服务端收到ACK后将关闭，客户端等待一段时间后关闭 TCP的生命周期客户端]]></content>
      <tags>
        <tag>tcp</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法及应用]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fsort%2F</url>
    <content type="text"><![CDATA[选择排序选择排序的原理非常简单，就是从数组里找到最大的数或者最小的数，把它放在数组的开头，然后再从剩下的部分继续找，直到结束. 使用go实现如下： 12345678910111213141516171819202122232425262728import "fmt"func main() &#123; var first = []int32&#123;1, 23, 4, 3, 212, 34&#125; var result = selectSort(first) for i := 0; i &lt; len(result); i += 1 &#123; fmt.Println(result[i]) &#125;&#125;func selectSort(originalList []int32) []int32 &#123; for i := 0; i &lt; len(originalList); i += 1 &#123; var max = originalList[i] var maxP = i for j := i; j &lt; len(originalList); j += 1 &#123; if originalList[j] &gt; max &#123; max = originalList[j] maxP = j &#125; &#125; if maxP != i &#123; var temp = originalList[i] originalList[i] = max originalList[maxP] = temp &#125; &#125; return originalList&#125; 冒泡排序冒泡排序的思想是，（假设需要升序排列）从第一个数开始，不停比较相邻的两个数，将大的放在右边，一轮过后最大的数会到数组的最右边。第二轮则是从第一个数到倒数第二个数…… 如果需要加快一下跳出可以加上一个flag, 如果一轮中没有出现交换，说明排序已经完成了，可以不再继续. 下面是一个go的版本:(只留function) 12345678910111213141516func bubbleSort(originalList []int32) &#123; for i := 0; i &lt; len(originalList)-1; i += 1 &#123; switched := false for j := 0; j &lt; len(originalList)-i-1; j += 1 &#123; if originalList[j] &gt; originalList[j+1] &#123; temp := originalList[j+1] originalList[j+1] = originalList[j] originalList[j] = temp switched = true &#125; &#125; if ! switched &#123; break &#125; &#125;&#125; 插入排序插入排序的思想是将数据插入到已经排序的数组当中，至于如何在数组中查找对应的位置还可以再分一下. 直接插入排序1234567891011121314func directInsertSort(originalList []int32) &#123; for i := 0; i &lt; len(originalList)-1; i += 1 &#123; current := originalList[i+1] for j := 0; j &lt;= i; j++ &#123; if current &lt; originalList[j] &#123; for k := i + 1; k &gt; j; k-- &#123; originalList[k] = originalList[k-1] &#125; originalList[j] = current break &#125; &#125; &#125;&#125; 二分插入排序希尔排序快速排序]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bochs的安装和使用]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fbochs%2F</url>
    <content type="text"><![CDATA[占坑]]></content>
  </entry>
  <entry>
    <title><![CDATA[java实现一个简单的apriori算法]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fapriori%2F</url>
    <content type="text"><![CDATA[占坑]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算PageRank]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fpage-rank%2F</url>
    <content type="text"><![CDATA[核心思想PageRank的核心思想： 如果一个网页被很多其他网页链接到，说明这个网页比较重要，PageRank值相对也会比较高. 如果一个PageRank值很高的网页链接到一个其他的网页，那么被链接到的网页PageRank值也会相应提高. 计算公式一般情况下,一个网页的PR值的计算公式如下： $$PR(p_i)=\alpha\sum\limits_{Pj\in{M_{p_i}}}\frac{PR(p_j)}{L(P_j)}+\frac{1-\alpha}{N}$$ 计算公式一般情况下,一个网页的PR值的计算公式如下： $$PR(p_i)=\alpha\sum\limits_{Pj\in{M_{p_i}}}\frac{PR(p_j)}{L(P_j)}+\frac{1-\alpha}{N}$$ 算法举例PageRank的值物理意义上是一个网页被访问的概率，因此通常对$N$个网页计算时，将每个网页的初始值设为$\frac{1}{N}$. 假设有4个网页A, B, C, D A有1个出链到D,B有2个出链到A和DC有1个出链到AD有2个出链到B和C 然后我们开始算第一轮: $$\begin{split}PR(A)&amp;=\alpha\left(\frac{PR(B)}{L(B)}+\frac{PR(C)}{L(C)}\right)+\frac{1-\alpha}{N} \\&amp;=\alpha\left(\frac{\frac{1}{4}}{2}+\frac{\frac{1}{4}}{1}\right)+\frac{1-\alpha}{N} \\&amp;=\frac{17}{20}\times\frac{3}{8}+\frac{3}{80} \\&amp;=\frac{57}{160} \\\end{split}$$$$\begin{split}PR(B)&amp;=\alpha\frac{PR(D)}{L(D)}+\frac{1-\alpha}{N} \\&amp;=\frac{23}{160} \\\end{split}$$$$\begin{split}PR(C)&amp;=\alpha\frac{PR(D)}{L(D)}+\frac{1-\alpha}{N} \\&amp;=\frac{23}{160} \\\end{split}$$$$\begin{split}PR(D)&amp;=\alpha\left(\frac{PR(A)}{L(A)}+\frac{PR(B)}{L(B)}\right)+\frac{1-\alpha}{N} \\&amp;=\alpha\left(\frac{\frac{57}{160}}{1}+\frac{\frac{23}{160}}{2}\right)+\frac{1-\alpha}{N} \\&amp;=\frac{17}{20}\times\frac{137}{320}+\frac{3}{80} \\&amp;=\frac{2569}{6400} \\\end{split}$$ 然后再从$PR(A)$开始计算……直到趋于平稳为止. 注意 当一个网页没有出链时认为对所有网页都有出链 为了限制一个网页只有指向自己的出链或者几个出链形成一个圈的情况，我们假定有一个概率$\alpha$，用户在浏览网页时会有一个这样的概率直接跳转到一个随机的网页，而每个网页的概率是相等的. $\alpha$值通常取$0.85$]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习</tag>
        <tag>PageRank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇异值分解的计算方式]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fsingular-value-decomposition%2F</url>
    <content type="text"><![CDATA[特征值方阵$A$,向量$v$,值$\lambda$有如下关系 $$Av=\lambda v$$ 此时称$v$为方阵$A$的特征向量,$\lambda$则是此特征向量对应的特征值。 奇异值分解]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何学习ruby]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fruby-learning%2F</url>
    <content type="text"><![CDATA[开发环境搭建windows下的安装这个不难，有时候installer可能被墙 CentOS7我需要一个消息队列拯救服务器记笔记一个类1234567class Demo def initialize end def func1 endend]]></content>
      <categories>
        <category>编程</category>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>ruby</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习汉语]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fchinese-learning%2F</url>
    <content type="text"><![CDATA[大学12大学之道，在明明德，在亲民，在止於至善。知止而後有定，定而後能静，静而後能安，安而後能虑，虑而後能得。物有本末，事有终始，知所先後，则近道矣…… 好事近·梦中作春路雨添花，花动一山春色。行到小溪深处，有黄鹂千百。飞云当面化龙蛇，夭矫转空碧。醉卧古藤阴下，了不知南北。]]></content>
      <categories>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>汉语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习英语]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fenglish-learning%2F</url>
    <content type="text"></content>
      <tags>
        <tag>学习</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习算法]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Falgorithm-learning%2F</url>
    <content type="text"><![CDATA[我需要学习如下算法需要在45天内完成，那就11.14完成吧 完了 时间已经快到了 快速排序 堆排序 归并排序 选择排序 并查集算法 图的遍历 有向图的DFS 无向图的DFS 最小生成树 图的最短路径 贪心算法 动态规划 NP完全问题 KMP算法 BM算法 近似匹配算法 传递闭包算法 中间值算法 对抗方法 分治算法 哈希算法 快速排序顺便学习C 并查集]]></content>
      <tags>
        <tag>算法</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习c++]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fcpp-learning%2F</url>
    <content type="text"><![CDATA[to do list下面是我计划关注的方面 多态和继承 运算符重载 常用的库 函数模板和类模板 元编程 指针和引用 IO 网络编程 多线程 数据库 开发环境搭建打算使用windows上的能看文件结构的编辑器+在linux上编译执行 搭完了 最后还是用了mingw]]></content>
      <tags>
        <tag>学习</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习Java]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fjava-learning%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[如何学习后端]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fback-end-learning%2F</url>
    <content type="text"><![CDATA[我需要学习这些东西有时间做一个思维导图 数据库 hibernate redis 分布式 中间件 linux 网络协议 jvm 设计模式 消息队列]]></content>
      <tags>
        <tag>学习</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习前端]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Ffront-end-learning%2F</url>
    <content type="text"><![CDATA[我需要学习这些东西 CSS JS CSS3 H5 Ajax Grunt Gulp eslint Vue React React Native Angular babel Promise]]></content>
      <tags>
        <tag>前端</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三角级数相关]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Ftrigonometric-series%2F</url>
    <content type="text"><![CDATA[三角级数$\quad$一般地，以$A_k\sin(kx+\varphi_k)$为项作成的无穷级数 $$\sum\limits_{k=0}^{\infty}A_k\sin(kx+\varphi_k)$$ 称为三角级数.（所以首先三角级数都是无穷级数） 但是有时候也会取如下形式： $$\frac{a_0}{2}+\sum\limits_{k=1}^{\infty}(a_k\cos{kx}+b_k\sin{kx})。$$ 周期函数周期函数有初相,振幅,频率 正弦级数给三角级数中所有的$a_k$取$0$，可以得到如下的正弦级数: $$\sum\limits_{k=1}^{\infty}b_k\sin{kx}$$ 余弦级数类似的操作可以得到余弦级数 $$\frac{a_0}{2}+\sum\limits_{k=1}^{\infty}a_k\cos{kx}$$ 傅里叶级数$$\begin{split}A_n&amp;=\frac{1}{\pi}\int_0^{2\pi}f(x)\cos{nx}\mathtt{d}x \\B_n&amp;=\frac{1}{\pi}\int_0^{2\pi}f(x)\sin{nx}\mathtt{d}x\end{split}$$ 这里用的符号和上面不一样呢 应该打屁股]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
        <tag>级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曲线积分的意义]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fcurve-line-integral%2F</url>
    <content type="text"><![CDATA[曲线积分第一类曲线积分第一类曲线积分用来求一个曲线物体的质量.当物体的密度是一个常值时，只需要将密度乘以弧长就可以得到质量.当物体的密度不均匀时，我们将密度表示为函数$f$，并对函数在曲线上积分，称为第一类曲线积分或者对弧长的曲线积分,记为$\int_Cf(x,y)\mathtt{d}s$，即 $$\int_Cf(x,y)\mathtt{d}s=\lim_{\lambda\to{0}}\sum_{i=1}^nf(\xi_i,\eta_i)\Delta{s_i}$$ 其中$f(x,y)$称为被积函数,$C$称为积分曲线,$\mathtt{d}s$成为弧微分. 我们可以把这个概念扩展到三维空间或者更高维的空间中： $$\int_Cf(x,y,z)\mathtt{d}s=\lim_{\lambda\to{0}}\sum_{i=1}^nf(\xi_i,\eta_i,\zeta_i)\Delta{s_i}$$ 第二类曲线积分和第一类曲线积分不同，第二类曲线积分可以用来表示变力沿曲线做的功，是有方向的.第二类曲线积分记为: $$\int_CP(x,y)dx+Q(x,y)dy\quad或\quad\int_C\boldsymbol{F}(x,y)·\mathtt{d}\boldsymbol{r}$$ 特别地，还可以有对某个方向的曲线积分 沿曲线$C$对坐标$x$的曲线积分$$\int_CP(x,y)dx=\lim_{\lambda\to{0}}\sum_{i=1}^nP(\xi_i,\eta_i)\Delta{x_i}$$ 沿曲线$C$对坐标$y$的曲线积分$$\int_CQ(x,y)dy=\lim_{\lambda\to{0}}\sum_{i=1}^nQ(\xi_i,\eta_i)\Delta{y_i}$$ 既然如此，应该还可以对一个特定的方向积分，就是不知道怎么表示. 如果曲线$C$为闭曲线，则记第二类曲线积分为 $$\oint_CP(x,y)dx+Q(x,y)dy\quad或\quad\oint_C\boldsymbol{F}(x,y)·\mathtt{d}\boldsymbol{r}$$]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格林公式]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2FGreen-Formula%2F</url>
    <content type="text"><![CDATA[格林公式的定义和一些练习学习一下格林公式~ 简单闭曲线$\quad$设曲线$C$的参数方程为 $$\begin{cases}x=\varphi(t), \\y=\psi(t)\end{cases}\quad(\alpha\le{t}\le\beta).$$ 如果$\varphi,\psi$连续，且对不同的参数$t_1,t_2\in[\alpha,\beta]$(不妨设$t_1\le{t_2}$),$(\varphi(t_1),\psi(t_1))=(\varphi(t_2),\psi(t_2))$当且仅当$t_1=\alpha,t_2=\beta$,则称$C$为简单闭曲线 单连通区域$\quad$设有一个平面区域$D$,若$D$内的任意一条简单闭曲线所围的部分仍属于$D$，则称$D$为单连通区域，否则称为多连通区域. 格林公式$\quad$设有界闭区域$D$由逐段光滑曲线$C$围成，函数$P(x,y)$及$Q(x,y)$在$D$上具有一阶连续偏导数，则 $$\begin{split}\oint_C{P}\mathtt{d}x+Q\mathtt{d}y=\iint\limits_D\left(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}}\right)\mathtt{d}x\mathtt{d}y\end{split}$$ 用途通常这些东西总是有用的，我们观察上面的式子。 左边一部分是对光滑曲线$C$的第二类曲线积分，格林公式告诉我们它会与在由曲线围成的平面区域$D$上对两个方向的分量在另一个方向的偏导之差的积分相等. 证明为了加深理解，我们来看一下证明.证明格林公式的时候是拆开证的，也就是 $$\oint_CP\mathtt{d}x=-\iint\limits_D\frac{\partial{P}}{\partial{y}}\mathtt{d}x\mathtt{d}y, \quad\oint_CQ\mathtt{d}y=\iint\frac{\partial{Q}}{\partial{x}}\mathtt{d}x\mathtt{d}y$$ 分以下三种情况讨论: $D$由曲线$y=\varphi_1(x),y=\varphi_2(x)$，及直线$x=a,x=b$围成，即 $$D=\{(x,y)\mid\varphi_1(x)\le{y}\le\varphi_2(x),a\le{x}\le{b}\}$$ $D$是单连通区域，且与某些与$y$轴平行的直线相交多于两点 $D$是多联通区域 做题环节题目1求椭圆$x=a\cos\theta,y=b\sin\theta$所围图形面积. 解： 我们可以从格林公式中得到一个简单的应用： 当$P=-y,Q=x$时，公式就变成了 $$\begin{split}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y=2\iint\limits_D\mathtt{d}x\mathtt{d}y\end{split}$$ 也就是闭区域$D$的面积$A$为: $$\begin{split}A=\frac{1}{2}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y\end{split}$$ 那么求椭圆面积就变为了求解上述式子,有: $$\begin{split}A&amp;=\frac{1}{2}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y \\&amp;=\frac{1}{2}\int_0^{2\pi}{-b\sin\theta}\mathtt{d}{a\cos\theta}+a\cos\theta\mathtt{d}b\sin\theta \\&amp;=\frac{1}{2}\int_0^{2\pi}{ab\sin^2\theta}\mathtt{d}{\theta}+ab\cos^2\theta\mathtt{d}\theta \\&amp;=\frac{1}{2}ab·2\pi \\&amp;=ab\pi\end{split}$$]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
</search>
