<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[产能规划问题相关]]></title>
    <url>%2Fblog%2F2019%2F03%2F22%2Fabout-capacity-planning%2F</url>
    <content type="text"><![CDATA[把内容关起来 相关的几个问题：性能分析问题(performance analysis question):CPU速度为x MIPS时，500/s的HTTP请求，响应时间是多少？ 也就是给出： 一个有特定产量的计算机 工作负载 输出： 系统性能（响应时间，吞吐量） 单个任务的响应时间计算： Response Time = Departure time - Arrival TimeResponse Time = Waiting Time + Processing Time （利用率）Utilisation: 系统在忙的时间比例 单服务器先进先出队列问题： 只有一个收银台的超市 单个处理器先进先出 硬盘相关的先进先出任务 如果给定每个任务进入系统的时间和需要的处理时间，我们可以计算每个任务的等待时间，每个人物的响应时间(Response Time) 这一类问题可能需要知道的东西： arrival rate inter-arrival time statistical distribution the time required to process the job 服务时间(Service Time) 在某个资源上处理一个请求所需的时间。 问题举例： 通过10kbps的连接发送一个1000byte的包，服务时间是1000*8/10000=0.8s 在硬盘上读取一个X byte的文件，所需时间是： seek time + X / transfer rate 我们有： Service Time = Overhead + Job size / Processing Rate 产能规划一个产能规划问题可以通过解决一系列的性能分析问题而被解决 性能度量： 响应时间、等待时间、吞吐量 单服务器队列建模 对计算系统的建模单服务队列仅考虑计算机系统中的一个组件，可以是CPU,硬盘，或者是一个传输通道 一个请求可能需要多个资源，比如上述多个中的一个。 我们通过队列网络(Queueing Networks)来建模一个有很多资源的计算机系统。 两者的不同记录一下但服务队列就是一堆任务进来，比如它们只需要使用CPU，然后给定它们来的时间和处理所需的时间，然后计算相关的度量。 队列网络则是比如现在一个计算机有一个CPU和硬盘，而不同的任务给定了到达的时间和所需要的CPU和硬盘的时间的序列，然后我们计算相关的度量。显然更复杂了。 开放队列网络和封闭队列网络一个可以接受外部的请求，工作负载来自于arrival rate另一个则是封闭的，不是很理解 开放队列网络可能在负载平衡的状态下吞吐率即为arrival rate封闭队列网络的吞吐率取决于用户或者用户规模？ 在开放队列网络里面的工作叫事务，在封闭队列网络里面叫任务。 计算两种网络需要不同的技术，然后像数据库这样的系统可能结合了两种不同的网络。 DBMS即Database Server Management System DBMS中设定了活动的事务的最大值，成为Multi-programming level。（MPL） 操作分析Operation Analysis（OA）又提出了一个新的概念。 “Operational”指收集在每天的操作中收集性能数据 应用： 使用这些数据来建立队列网络模型 进行瓶颈分析 进行改进分析 我们以一个单任务队列为例： A指Arrival Requests，C指Completed，B只服务器的Busy状态，T指观察的这一段时间 Arrival Rate $\lambda=\frac{A}{T}$Output Rate $X=\frac{C}{T}$Utilisation $U=\frac{B}{T}$每个完成的请求的平均服务时间=B/C 举个例子： 观察一分钟，那么T=1 minCPU: busy时间36s 1790 requests arrived 1800 requests completed可以计算： MeanSTPC = B/C = 36s / 1800 = 0.02s U = 36/60=60% Arrival Rate = 1790/60 = 29.83 requests/s Output Rate = 1800/60 = 30 requests/s 利用率法则既然U=B/TMSTPC S=B/COR X=C/T 我们可以得到U=SX，即利用率等于每个完成的任务的平均服务时间*完成率 利用率法则是操作法则的一部分。 操作分析的应用 不需要观察每一个数值，比如可以用B来推断U 一致性检查，如果U!=SX,那一定有地方出问题了 可以用于性能分析： 瓶颈分析，平均值分析 平衡总结？这标题可能不太对OA makes the assumption that: C=A或者至少是接近的 这意味着系统是在平衡状态。 QNs里的操作分析这个就比较复杂了。]]></content>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在这里放一些我觉得有用的Vue组件]]></title>
    <url>%2Fblog%2F2019%2F03%2F18%2Fvue-test%2F</url>
    <content type="text"><![CDATA[在这一页收藏一些可能会有用的Vue组件，没事的时候塞一点进来。 .coloredDiv { padding: 5px; background: #A2CEB3; margin-bottom: 10px; border-radius: 2px; } Vue.component('wrapper', { props: ['title'], template: ` {{ title }} ` }); {{ text }} Vue.component('test-input', { props: [ 'value' ], template: ` ` }); let vm_c0 = new Vue({ el: "#c0", data: function() { return { text: '' } } }) {{ text }} Vue.component('test-text-area', { props: [ 'value' ], template: ` ` }); let vm_c1 = new Vue({ el: "#c1", data: function() { return { text: '' } } }) Vue.component('md-text-area', { props: [ 'value' ], template: ` `, computed: { markedText: function() { return marked(this.value) } } }); let vm_c2 = new Vue({ el: "#c2", data: function() { return { text: '' } }, }) Vue.component('sort-table', { props: [ 'data', 'config' ], template: ` {{ key }} {{ item }} `, methods: { computedWidth: function(raw) { return raw*10+'px'; } } }); let vm_c3 = new Vue({ el: "#c3", data: function() { return { displayConfig: { columns: { name: 17, age: 6, ability: 6, } }, players: [ { name: 'Tom', age: 3, ability: 4, }, { name: 'Jerry', age: 2, ability: 5, }, { name: 'Bi', age: 6, ability: 1, }, { name: 'Boom', age: 2, ability: 4, } ] } }, })]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>vue</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[能聊天吗，能好好聊天吗]]></title>
    <url>%2Fblog%2F2019%2F02%2F19%2Fquanda%2F</url>
    <content type="text"><![CDATA[确定]]></content>
      <categories>
        <category>玩</category>
      </categories>
      <tags>
        <tag>机器人测试</tag>
        <tag>哈喽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哦，天哪]]></title>
    <url>%2Fblog%2F2019%2F02%2F17%2Fcocos-test%2F</url>
    <content type="text"><![CDATA[nmd，为什么 复制 #tam { display: flex; justify-content: space-between; } #input { width: 45%; height: 600px; } #output { width: 45%; } let clipboard = new ClipboardJS('#clip'); // clipboard.on('success', function(e) { // alert('复制成功!') // e.clearSelection(); // }); marked.setOptions({ renderer: new marked.Renderer(), gfm: true, tables: true, breaks: false, pedantic: false, sanitize: false, smartLists: true, smartypants: false }); function generateHTML(event) { document.getElementById('output').innerHTML = marked(event.target.value); }]]></content>
      <tags>
        <tag>哦，天哪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密羞耻的JS代码]]></title>
    <url>%2Fblog%2F2019%2F02%2F10%2Fencrypt-js-code%2F</url>
    <content type="text"><![CDATA[这里是一段不为人知的代码，有着不为人知的效果，就算有人点进来，也不能知道到底是什么效果。 除非，猜中密码或者暴力破解了…… F12也没有用哦[doge] 确定 你好啊…只有知道密码的人才能看到这一页的效果哦 .bhb { display: flex; justify-content: center; } // const plainText = ` // ` // let encryptedData = CryptoJS.AES.encrypt(plainText, key, { // mode: CryptoJS.mode.ECB, // padding: CryptoJS.pad.Pkcs7 // }); // encryptedData = encryptedData.ciphertext.toString(); // console.log("加密后：" + encryptedData); function dec() { const text = document.getElementById('theInput').value; console.log(text); const key = CryptoJS.enc.Utf8.parse(text); const encryptedData = 'b7cff6162daab657c26844f60e00fada1bb98c1d7f14eabe350e61742f1c5e08a151ce72b57bd8a8d5c6b14ed06102f53876a31f5d3f714dbe1724665f0b37cc944b1fbeb3b031abd4f713a86e68a70722303d2e81358e7155e71a122e94c702d9043428437505f63f32d70610fc8ca73951763531133025d4713cb5104e8ad2'; const encryptedHexStr = CryptoJS.enc.Hex.parse(encryptedData); const encryptedBase64Str = CryptoJS.enc.Base64.stringify(encryptedHexStr); const decryptedData = CryptoJS.AES.decrypt(encryptedBase64Str, key, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 }); const decryptedStr = decryptedData.toString(CryptoJS.enc.Utf8); eval(decryptedStr); } 早上醒来突然想着有时候如果需要隐藏一些界面效果，只给知道密码的人看应该怎么弄，毕竟有时候按一下f12就可以看到怎么回事了。 想了想只要把代码加密了存在字符串里，用用户输入的密码解密字符串并eval就好了。 密码错了也跑不了，密码对了就可以看到效果了。 有机会可以在博客里面放一个私人空间233 上面就是这个效果，密码……我还是留着自己看吧 顺带放一下代码 12345678910const key = CryptoJS.enc.Utf8.parse('0123456789ABCDEF');const plainText = `alert('这里是一段代码哦');`let encryptedData = CryptoJS.AES.encrypt(plainText, key, &#123; mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7&#125;);encryptedData = encryptedData.ciphertext.toString();console.log("加密后：" + encryptedData); 我们可以从这里拿到加密后的代码串，然后上传时我们把plainText里实际的代码删掉就没人看得到了。 然后就是每次取用户输入的密码来尝试解密并执行，代码如下： 1234567891011121314function dec() &#123; const text = document.getElementById('theInput').value; console.log(text); const key = CryptoJS.enc.Utf8.parse(text); const encryptedData = 'b7cff6162daab657c26844f60e00fada1bb98c1d7f14eabe350e61742f1c5e08a151ce72b57bd8a8d5c6b14ed06102f53876a31f5d3f714dbe1724665f0b37cc944b1fbeb3b031abd4f713a86e68a70722303d2e81358e7155e71a122e94c702d9043428437505f63f32d70610fc8ca73951763531133025d4713cb5104e8ad2'; const encryptedHexStr = CryptoJS.enc.Hex.parse(encryptedData); const encryptedBase64Str = CryptoJS.enc.Base64.stringify(encryptedHexStr); const decryptedData = CryptoJS.AES.decrypt(encryptedBase64Str, key, &#123; mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 &#125;); const decryptedStr = decryptedData.toString(CryptoJS.enc.Utf8); eval(decryptedStr);&#125; 这一段encryptedData就是加密后的代码了。 嗯就这样…]]></content>
      <categories>
        <category>编程</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集&算法分析的方法]]></title>
    <url>%2Fblog%2F2019%2F02%2F06%2Funion-find%2F</url>
    <content type="text"><![CDATA[这里是Coursera上Algrithm Part 1的笔记 并查集(Union-Find)并查集是一种数据结构，可以用来描述多个实体之间的连接关系，至少在这个课程中，它是一个为了解决特定的问题而简化过的模型。 一开始是一堆互不连接的点，我们使用union操作可以将它们两两连接起来，但是在我们使用的数据结构中，我们无法判断是哪两个具体的点连在了一起，也不能使用断开连接的操作。我们只需要知道，这几个点是连在一起的，这种关系叫做connected。 也就是说在并查集中有两种操作，一种是connected,一种是union，connected只是一个判断两个节点是否连通的操作，union则是把两个点连接起来(如果它们已经连通了，就跳过)。我们需要解决的问题就是判断某些点是否互相连通。 此外还有一个在connected和union中的辅助操作find，用来获取某个实体对应的集合的id。 这里的连通关系(connected)有三个性质(非常常见的性质)： (自反)自己和自己是连通的 (对称)如果p和q连通，那么q和p连通(if p is connected to q, q is connected to p) (传递)a和b连通，b和c连通，那么a和c连通。 此时我们需要来个图： #introWrapper { margin-top: 20px; } #ahaFather { display: flex; flex-direction: column; justify-content: start; } .aha { display: flex; justify-content: space-around; } .btn + .btn { margin: 0; } let data = []; function showIntro() { const svg = d3.select('#intro'); const size = 50; function randomOpen() { return Math.random() > 0.41; } function blockLayout(data) { let index = 0; for(let i = 0; i < 50; i++) { for(let j = 0; j < 50; j++) { data.push({ x: j * size, y: i * size, open: randomOpen(), }); } } } blockLayout(data); svg.attr('viewBox', '0, 0, 2500, 2500') svg.selectAll('rect') .data(data) .enter() .append('rect') .attr('x', (d, i) => d.x) .attr('y', (d, i) => d.y) .attr('width', size) .attr('height', size) .attr('fill', (d, i) => d.open? '#EEEEEE' : '#111111'); } showIntro(); function draw() { const id = []; const sz = []; for(let i = 0; i 50) { return i - 50; }else { return null; } } function getDown(i) { if(i]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>并查集</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看看随机的效果]]></title>
    <url>%2Fblog%2F2019%2F02%2F05%2Fvis-random%2F</url>
    <content type="text"><![CDATA[把内容关起来 生成一个图 function testRandom() { let rand = d3.randomLogNormal(0, 1); let dataset = []; for(let i = 0; i < 10000; i++) { dataset.push( rand() ); } let histogram = d3.histogram() .domain([0, 10]) .thresholds(20); let data = histogram(dataset); let max_height = 300; let rect_step = 30; let heights = []; for(let i = 0; i < data.length; i++) { heights.push( data[i].length ); } let yScale = d3.scaleLinear() .domain([d3.min(heights), d3.max(heights)]) .range([0, max_height]); const svg = d3.select('svg'); svg.select('g').remove(); const graphics = svg.append('g'); graphics.selectAll("rect") .data(data) .enter() .append("rect") .attr('x', (d, i) => i * rect_step) .attr('y', (d, i) => max_height - yScale(d.length)) .attr('width', (d, i) => rect_step - 2) .attr('height', (d, i) => yScale(d.length)) .attr('fill', 'steelblue'); graphics.append('line') .attr('stroke', 'black') .attr("stroke-width", "1px") .attr("x1", 0) .attr("y1", max_height) .attr("x2", data.length * rect_step) .attr("y2", max_height); graphics.selectAll(".linetick") .data(data) .enter() .append("line") .attr("stroke","black") .attr("stroke-width","1px") .attr("x1", (d, i) => i * rect_step + rect_step / 2) .attr("y1", max_height) .attr("x2", (d, i) => i * rect_step + rect_step / 2) .attr("y2", max_height + 5); graphics.selectAll("text") .data(data) .enter() .append("text") .attr("font-size", "10px") .attr("x", (d, i) => i * rect_step) .attr("y", (d, i) => max_height) .attr("dx", rect_step / 2 - 8) .attr("dy", "15px") .text(d => Math.floor(d.x0)); } testRandom();]]></content>
      <tags>
        <tag>可视化</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[篮球经理Web版测试]]></title>
    <url>%2Fblog%2F2019%2F01%2F17%2Fbm-test%2F</url>
    <content type="text"><![CDATA[建议使用Firefox或Chrome打开, Edge也不是不行，但IE真的是魔鬼 手机请到qq群 191376904 下载安装包 当前存档名：&nbsp; 读取 保存 开始新游戏 篮球经理Web版 0 &nbsp;赛季 第&nbsp; 0 &nbsp;天&nbsp; 我的球队 球队排行 属性排行 数据统计 季后赛程 模拟一天 模拟30天 新闻查看 关注列表 球员交易 选秀观察 添加球员 let fileName = ''; let fileData = ''; let state = '未读取'; let viewState = { showNav: true, } let gameState = {}; function test() { new MatchSimulator().simulateSection(720); } function init() { gameState = Game.getInitData(); fileName = 'BM-INIT.json'; changeName(); showTeamSelection(); } function finishInit(teamId) { gameState.userTeam = gameState.teams[teamId].name; gameState.userTeamId = teamId; gameState.news.push({ season: 1, day: 1, content: '欢迎进入游戏，你的球队是 ' + gameState.userTeam, }); gameState.news.push({ season: 1, day: 1, content: ` 3月快乐！ 此版本为web版，可以使用电脑浏览器进行游戏，手机端建议安装APP以获得更好的游戏体验。 详情请加入qq群（191376904）。欢迎大家的体验和反馈！ 近期更新： - 调整篮板和助攻 - 修复球龄错误问题 - 修复球员冠军数量统计 - 更改弹出框防止闪退问题 注意事项： - 手机APP菜单栏在左侧侧滑栏，请向右滑出 - 季后赛为前16名进行比赛，不分区 - 网页更新与APP端同步，（没有需要加按钮的功能时）无需重新下载客户端 ` }); initGameData(); } function updateDay() { const dayNum = document.getElementById('currentDay'); dayNum.innerText = gameState.currentDay; } function updateSeason() { const dayNum = document.getElementById('currentSeason'); dayNum.innerText = `${gameState.currentSeason}-${gameState.currentSeason + 1}`; } function updateButton() { const sim30Button = document.getElementById('sim30Btn'); const day = gameState.currentDay; if(day >= 221) { $("#sim30Btn").attr('style', 'display:none;'); }else if(day >= 166) { sim30Button.innerText = '模拟一轮'; }else if(day + 30 >= 166) { sim30Button.innerText = '直达季后赛'; }else { $("#sim30Btn").attr('style', 'display:block;'); sim30Button.innerText = '模拟30天'; } const offSeasonButton = document.getElementById('offSeasonBtn'); if(day >= 166) { $("#offSeasonBtn").attr('style', 'display:block;'); }else { $("#offSeasonBtn").attr('style', 'display:none;'); } } function initGameData() { refreshPane(); } function load() { let file = document.getElementById("selectFile").files; fileName = file[0].name; let reader = new FileReader(); reader.readAsText(file[0], "UTF-8"); reader.onload = function(evt){ fileData = evt.target.result; changeName(); gameState = JSON.parse(fileData); initGameData(); } } function showPlayerInfo(playerId) { const mainDiv = document.getElementById('contentDiv'); mainDiv.innerHTML = ""; let pane = TemplateUtil.createPlayerPane(playerId, gameState); mainDiv.appendChild(pane); } function showMatch(matchId) { const mainDiv = document.getElementById('contentDiv'); mainDiv.innerHTML = ""; let pane = TemplateUtil.createGameResultPane(matchId, gameState); mainDiv.appendChild(pane); } function showTeamRank() { const mainDiv = document.getElementById('contentDiv'); mainDiv.innerHTML = ""; const teams = Game.getTeamRank(gameState); for(let i = 0;i= 0; i--) { let line = TemplateUtil.createNewsLine(news[i].day, news[i].season, news[i].content); mainDiv.appendChild(line); } } function showTeamSelection() { const mainDiv = document.getElementById('contentDiv'); mainDiv.innerHTML = ""; let pane = TemplateUtil.createSelectTeamPane(gameState); mainDiv.appendChild(pane); } function showFollowList() { const mainDiv = document.getElementById('contentDiv'); mainDiv.innerHTML = ""; const followList = gameState.followList; for(let i = 0; i < followList.length; i++) { const player = gameState.players[followList[i]]; let line = TemplateUtil.createPlayerLine(player); mainDiv.appendChild(line); } if(followList.length == 0) { let line = TemplateUtil.createLine('可以到球员详情界面点击关注哦~'); mainDiv.appendChild(line); } } function showTeamInfo(teamId) { const mainDiv = document.getElementById('contentDiv'); mainDiv.innerHTML = ""; let pane = TemplateUtil.createTeamPane(teamId, gameState); mainDiv.appendChild(pane); } function showStatsRank() { const mainDiv = document.getElementById('contentDiv'); mainDiv.innerHTML = ""; let select = TemplateUtil.createStatsSelect([]); mainDiv.appendChild(select); let players = Game.getAbilityRank(gameState, 'seasonRegScore'); for(let i = 0; i < players.length; i++) { let player = players[i]; if(player.seasonRegScore == 0) { break; } let line = TemplateUtil.createAttrLine(i + 1, '赛季得分', player.id, player.name, player.seasonRegScore, gameState); mainDiv.appendChild(line); } } function changeStats() { const mainDiv = document.getElementById('contentDiv'); const select = document.getElementById('statsSelect'); for(let i = mainDiv.childNodes.length - 1; i > 0; i--) { mainDiv.removeChild(mainDiv.childNodes[i]); } const value = select.options[select.selectedIndex].value; const attrName = select.options[select.selectedIndex].text; let players = Game.getAbilityRank(gameState, value); for(let i = 0; i < players.length; i++) { let player = players[i]; if(player[value] == 0) { break; } let statsValue = Game.getPlayerAbility(player.id, gameState, value); let line = TemplateUtil.createAttrLine(i + 1, attrName, player.id, player.name, statsValue, gameState); mainDiv.appendChild(line); } } function showAttrRank() { const mainDiv = document.getElementById('contentDiv'); mainDiv.innerHTML = ""; let select = TemplateUtil.createSelect([]); mainDiv.appendChild(select); let players = Game.getAbilityRank(gameState, 'skillAverage'); for(let i = 0; i < players.length; i++) { let player = players[i]; let line = TemplateUtil.createAttrLine(i + 1, '综合能力', player.id, player.name, player.skillAverage, gameState); mainDiv.appendChild(line); } } function changeAttr() { const mainDiv = document.getElementById('contentDiv'); const select = document.getElementById('attrSelect'); for(let i = mainDiv.childNodes.length - 1; i > 0; i--) { mainDiv.removeChild(mainDiv.childNodes[i]); } const value = select.options[select.selectedIndex].value; const attrName = select.options[select.selectedIndex].text; let players = Game.getAbilityRank(gameState, value); for(let i = 0; i < players.length; i++) { let player = players[i]; if(player[value] == 0) { break; } let attrValue = Game.getPlayerAbility(player.id, gameState, value); let line = TemplateUtil.createAttrLine(i + 1, attrName, player.id, player.name, attrValue, gameState); mainDiv.appendChild(line); } } function showOffSeason() { const mainDiv = document.getElementById('contentDiv'); mainDiv.innerHTML = ""; const pane = TemplateUtil.createOffSeasonPane(gameState); mainDiv.appendChild(pane); } function refreshPane(prop) { updateViewState(); if(prop !== null && prop !== undefined) { gameState.showState = prop; } if(gameState.showState === ShowState.MyTeam) { showTeamInfo(gameState.userTeamId); }else if(gameState.showState === ShowState.TeamRank) { showTeamRank(); }else if(gameState.showState === ShowState.News) { showNews(); }else if(gameState.showState === ShowState.AttrRank) { showAttrRank(); }else if(gameState.showState === ShowState.OffSeason) { showOffSeason(); }else if(gameState.showState === ShowState.StatsRank) { showStatsRank(); } } function updateViewState() { updateDay(); updateSeason(); updateButton(); } function nextDay() { Game.nextDay(gameState); refreshPane(); } function next30Day() { const mainDiv = document.getElementById('contentDiv'); if(gameState.currentDay < 165) { for(let i = 0;i]]></content>
      <categories>
        <category>游戏</category>
        <category>篮球经理</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试一试tensorflowjs]]></title>
    <url>%2Fblog%2F2019%2F01%2F15%2Ftfjs-test%2F</url>
    <content type="text"><![CDATA[开始训练 测试 const model = tf.sequential(); model.add(tf.layers.dense({ units: 100, activation: 'relu', inputDim: 10, })); model.add(tf.layers.dense({ units: 1, activation: 'linear', })); model.compile({ optimizer: 'sgd', loss: 'meanSquaredError', }); function fit() { const xs = tf.randomNormal([100, 10]); const ys = tf.randomNormal([100, 1]); model.fit(xs, ys, { epochs: 10, callbacks: { onEpochEnd: (epoch, log) => { console.log("epoch: " + epoch + " loss: " + log.loss); } }, }); model.predict(tf.randomNormal([1, 10])).print(); } function test() { const md = tf.sequential(); let img = new Image(); img.src = 'http://localhost:4000/blog/images/avatar.jpg'; let tfimg = tf.fromPixels(img); console.log(tfimg.shape); let ttt = tfimg.expandDims(); let fltimg = tfimg.flatten(); const xs = tf.randomNormal(ttt.shape); md.add(tf.layers.conv2d({ inputShape: tfimg.shape, filters: 5, kernelSize: [3, 3], })); // md.add(tf.layers.flatten({ // inputShape: tfimg.shape // })); // md.add(tf.layers.dense({ // units: 100, // activation: 'sigmoid', // })); md.add(tf.layers.dense({ units: 100, activation: 'sigmoid', })); md.add(tf.layers.dense({ units: fltimg, activation: 'sigmoid', })); md.add(tf.layers.reshape({ targetShape: tfimg.shape })); md.summary(); md.compile({ optimizer: 'sgd', loss: 'meanSquaredError', }); md.fit(xs, ttt, { epochs: 10, callbacks: { onEpochEnd: (epoch, log) => { console.log("epoch: " + epoch + " loss: " + log.loss); } }, }); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[合成钢琴声测试]]></title>
    <url>%2Fblog%2F2019%2F01%2F13%2Fsynth-piano%2F</url>
    <content type="text"><![CDATA[https://www.soundonsound.com/techniques/whats-sound 这里有好东西 https://www.soundonsound.com/search/articles/%22Synth%20Secrets%22?solrsort=ds_created%20asc&amp;f%5B0%5D=im_field_subject%3A8106 VCF，EG，和LFO分别是什么呢？ 我只是想模拟一下钢琴的声音，才发现这件事情有点复杂。It’s all greek for me. 我应该学习一些subtractive synthesis。 啊哈 sine, square, sawtooth, triangle提供了四种不同的音色（它们的波形不一样） gainNode可以调整它们的音量大小，这样我们至少可以组合出一个最像的出来。 我们可以用sine波，把频率调为整数倍来合成，这样频率并不会改变。 比如录一个比较干净的钢琴声，然后用神经网络训练出一个接近的组合。 (下面的频率指261的倍数) 播放 sine square triangle sawtooth 删除此行 添加 .wrapper { margin-top: 10px; display: flex; } button { margin-left: 10px; } #btn-last { margin-top: 10px; } select { margin-left: 10px; border: 2px solid #555; border-radius: 2px; appearance: none; -webkit-appearance: none; -moz-appearance: none; text-align: center; cursor: pointer; } input::input-placeholder { text-align: center; } ::-webkit-input-placeholder { text-align: center; } :-moz-placeholder { text-align: center; } ::-moz-placeholder { text-align: center; } :-ms-input-placeholder { text-align: center; } input { margin-left: 10px; width: 70px; border: 2px solid #555; border-radius: 2px; text-align: center; } window.AudioContext = window.AudioContext||window.webkitAudioContext; const context = new AudioContext(); const typeList = ['sine', 'square', 'triangle', 'sawtooth'] function getOscillator(typeNum, freq, gain) { let oscillator = context.createOscillator(); let gainNode = context.createGain(); oscillator.connect(gainNode); gainNode.gain.value = gain; gainNode.connect(context.destination); oscillator.type = typeList[typeNum]; oscillator.frequency.value = freq; return oscillator; } function getCurrentList() { const items = document.getElementsByClassName('wrapper'); let result = []; for(let i = 0;i]]></content>
  </entry>
  <entry>
    <title><![CDATA[Audio！]]></title>
    <url>%2Fblog%2F2019%2F01%2F12%2Faudio-test%2F</url>
    <content type="text"><![CDATA[不要用手机点哦… 播放 demo1 demo2 window.AudioContext = window.AudioContext||window.webkitAudioContext; const context = new AudioContext(); function playSound(buffer){ let source = context.createBufferSource(); source = context.createBuffersource(); source.buffer = buffer; source.connect(context.destination); source.start(0); } const s = [ [16, 18, 21, 22, 25, 28, 31], [33, 36, 41, 44, 49, 55, 62], [65, 73, 82, 87, 98, 110, 123], [131, 147, 165, 175, 196, 220, 247], [261, 293, 329, 349, 392, 440, 493], [523, 587, 659, 698, 784, 880, 988], [1047, 1175, 1319, 1397, 1568, 1760, 1976], [2093, 2349, 2637, 2794, 3136, 3520, 3951], [4186, 4697, 5274, 5588, 6272, 7040, 7902], [8372, 9398, 10548, 11176, 12544, 14080, 15805], ]; const sh = [ [17, 19, 0, 23, 26, 29, 0], [35, 39, 0, 46, 52, 58, 0], [69, 78, 0, 93, 104, 117, 0], [139, 156, 0, 185, 208, 233, 0], [277, 311, 0, 370, 415, 466, 0], [554, 622, 0, 740, 831, 932, 0], [1109, 1245, 0, 1480, 1661, 1865, 0], [2218, 2489, 0, 2960, 3323, 3729, 0], [4435, 4978, 0, 5920, 6645, 7459, 0], [8870, 9398, 0, 11840, 13290, 14918, 0], ]; let combList = ['sine', 'square', 'triangle', 'sawtooth'] let testTone = [ [0, 1, 0.8], [0, 2, 0.3], [0, 3, 0.2], [2, 1, 0.05], ] let tone2 = [ [1, 1, 0.1], ] function playValue(freq, start, stop, amp) { console.log(freq + " " + start + " " + stop + " " + amp); if(amp < 1) { let curT = tone2[0]; let curO = getOscillator(combList[curT[0]], freq * curT[1], curT[2] * amp); curO.start(start); curO.stop(stop); } for(let i = 0;i]]></content>
  </entry>
  <entry>
    <title><![CDATA[网站导航]]></title>
    <url>%2Fblog%2F2019%2F01%2F09%2Fnav-page%2F</url>
    <content type="text"><![CDATA[推荐使用&nbsp;TireFox&nbsp;倦糊浏览器&nbsp;! https:// tipwheal.github.io /blog/ 背单词~ C++ 算法~ #wrapper { width: 100%; height: 300px; display: flex; background-color: #EADEA1; margin-bottom: 10px; border: 2px solid #7D6C46; border-radius: 2px; flex-direction: column; } #title { height: 30px; display: flex; background-color: #7D6C46; align-items: center; border-bottom: 1px solid #7D6C46; color: white; user-select: none; -moz-user-select: none; font-size: 0.95rem; } #bar { flex-grow: 1; display: flex; align-items: center; } #bar img { width: 20px; height: 20px; margin: 0 2px; border: none; user-select: none; -moz-user-select: none; } #tool img { width: 20px; height: 20px; margin: 0; border: none; user-select: none; -moz-user-select: none; margin-right: 2px; } #content-nav { height: 40px; background-color: #BDC0BA; border-bottom: 1px solid #7D6C46; padding: 0 2px; display: flex; align-items: center; } #nav-input { border: 1px solid #7D6C46; border-radius: 1px; background-color: white; margin: 0; flex-grow: 1; padding: 0 5px; display: flex; align-items: center; cursor: text; font-size: 0.95rem; } #nav-input img { width: 25px; height: 25px; margin: 0; border: none; user-select: none; -moz-user-select: none; } #content-main { flex-grow: 1; display: flex; padding: 20px; justify-content: space-around; align-items: center; } .card-item { width: 100px; height: 100px; background-color: #86c166; border: 1px solid #7D6C46; border-radius: 1px; padding: 3px; display: flex; justify-content: center; align-items: center; cursor: pointer; transition-duration: 0.15s; } .card-item span { -moz-user-select: none; user-select: none; } .card-item:hover { margin: -3px; padding: 6px; }]]></content>
      <tags>
        <tag>导航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我尝试在这里画一棵红黑树]]></title>
    <url>%2Fblog%2F2019%2F01%2F05%2Fred-black-tree%2F</url>
    <content type="text"><![CDATA[但是进度有点慢，我应该打住了，先写一点别的。现在应该可以很快画出来了。 function drawFirst() { const nodes = [ {id:7, color: "black", x: 0, y: 0}, {id:8, color: "red", x: 20, y: 10}, {id:2, color: "red", x: -20, y: 10}, {id:9, color: "black", x: 30, y: 20}, {id:3, color: "black", x: -10, y: 20}, {id:6, color: "black", x: 10, y: 20}, {id:1, color: "black", x: -30, y: 20}, ]; const links = [ [0, 0, 20, 10], [0, 0, -20, 10], [-20, 10, -10, 20], [-20, 10, -30, 20], [20, 10, 10, 20], [20, 10, 30, 20], ]; const svg = d3.select("#svg1"); svg.attr('viewBox', "-55 -25 110 70") svg.selectAll("line") .data(links) .enter() .append("line") .attr("x1", (d,i)=>d[0]) .attr("y1", (d,i)=>d[1]) .attr("x2", (d,i)=>d[2]) .attr("y2", (d,i)=>d[3]) .style("stroke", "#ccc") .style("stroke-width", 1); svg.selectAll("circle") .data(nodes) .enter() .append("circle") .attr("cx", (d, i)=>d.x) .attr("cy", (d, i)=>d.y) .attr("r", 5) .attr("fill", (d, i)=>d.color) } drawFirst(); 红黑树的性质 节点有颜色，红色或者是黑色 根节点是黑的，虽然这个性质用处不是很大，不影响大部分的分析 为了方便，节点有指向父节点的指针（除了左右子节点的指针之外） 红色节点的子节点都是黑色的 根节点到所有叶子节点的路径上黑色节点的数量都是相同的 我们根据上面的性质可以发现，红黑树可以保持一个比较平衡，但又不是完全平衡的状态。 根据性质5和性质4，我们可以发现红黑树最不平衡的状态也就是某些节点的实际深度是另一些的两倍。 而红黑树保持这样相对平衡的状态就可以使得我们可以像其他的平衡的二叉树一样在$O(\log{N})$的时间内完成查找。 实际上红黑树在插入和删除节点的时候消耗的时间也是$O(\log{N})$，这是红黑树的一个非常好的性质。 如果我们需要一个查找、插入、删除节点都很快的数据结构，我们可以选择它。 一些基本的操作在我们的插入删除的过程中为了保持平衡，我们需要提取一些保持平衡过程中常用的步骤。除了找节点的各个亲戚之外就是树的旋转操作。 那么下面就是常见的操作和简短的代码，代码可能是错的但是不应该影阅响读。 找爸爸123function parent(node) &#123; return node.parent;&#125; 找爷爷1234567function grandParent(node) &#123; const parent = parent(node); if(parent) &#123; return parent(parent); &#125; return null;&#125; 找叔叔12345678910function uncle(node) &#123; const grandParent = grandParent(node); if(grandParent) &#123; if(grandParent.left === parent(node)) &#123; return grandParent.right; &#125; return grandParent.left; &#125; return null;&#125; 找兄弟1234567891011function sibling(node) &#123; const parent = parent(node); if(parent) &#123; if(parent.left == node) &#123; return parent.right; &#125;else &#123; return parent.left; &#125; &#125; return null;&#125; 左旋左旋操作应该说是逆时针旋转，把一个节点变成它的右子节点的左子节点，并且继承了右子节点的左子节点为自己的新的右子节点，同时还送出了自己的父亲。具体操作如下： 1234567891011121314151617181920function rotateLeft(node) &#123; const newNode = node.right; const pNode = parent(node); if(newNode) &#123; node.right = newNode.left; node.right.parent = node; newNode.left = node; node.parent = newNode; if(pNode) &#123; if(pNode.left === node) &#123; pNode.left = newNode; &#125;else &#123; pNode.right = newNode; &#125; newNode.parent = pNode; &#125;else &#123; newNode.parent = null; &#125; &#125; &#125; 右旋右旋操作，我也更喜欢说是顺时针旋转，如果树是从上往下的话。和左旋相反，是一个节点的左儿子变成自己的父亲的过程。 1234567891011121314151617181920function rotateRight(node) &#123; const newNode = node.left; const pNode = node.parent; if(newNode) &#123; node.left = newNode.right; node.left.parent = node; newNode.right = node; node.parent = newNode; if(pNode) &#123; if(pNode.left === node) &#123; pNode.left = newNode; &#125;else &#123; pNode.right = newNode; &#125; newNode.parent = pNode; &#125;else &#123; newNode.parent = null; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>可视化</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python可视化库收集]]></title>
    <url>%2Fblog%2F2018%2F12%2F18%2Fvisualize-lib-py%2F</url>
    <content type="text"><![CDATA[graphvizgraphviz官网 (这是一个可以使用的软件，有一套DSL可以用来画图) 实例 1234567891011121314from graphviz import Digraphdot = Digraph(comment='The Test Table', format='png')dot.node('A', 'Dot A')dot.node('B', 'Dot B')dot.node('C', 'Dot C')dot.node('D', 'Dot D')dot.edges(['AB', 'BC', 'AB'])dot.save('xxx.gv')dot.render('xxx.gv')dot.view() 实际上js中也有对应的viz.js 试一下吧 var viz = new Viz(); viz.renderSVGElement(` digraph { a [label = "Dot A", style="filled", fillcolor="green"] b [label = "Dot B"] c [label = "Dot C", style="filled", fillcolor="green"] d [label = "Dot D", shape="box",style="filled", fillcolor="green"] a -> b b -> c a -> c c -> d }`) .then(function(element) { document.querySelector('#pic').appendChild(element); }) .catch(error => { // Create a new Viz instance (@see Caveats page for more info) viz = new Viz(); // Possibly display the error console.error(error); }); 看起来viz.js以及python里的graphviz以及d3js的graphviz用的都是同一套的graphviz，效果相当。 但是除了这个之外似乎并不能折叠，对于大的流程图也不能弄出缩略图？]]></content>
      <tags>
        <tag>可视化</tag>
        <tag>py</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机算法笔记]]></title>
    <url>%2Fblog%2F2018%2F12%2F16%2Fnotes-caida%2F</url>
    <content type="text"><![CDATA[分析算法和问题：原理和例子算法可解的说一个问题是算法可解的，意味着： 可以编写一个计算机程序，在足够的时间和空间内，这个程序可以为任意输入处理出一个正确的结果。 算法20世纪30年代，计算机出现之前，数学家们已经在积极地定义和研究算法的概念。 算法被解释成： 一套清楚的简单指令，按照这套指令可以解决某个问题和计算某个函数。 停机问题 能否判断一个任意给出的算法（或计算机程序）在给定输入的情况下是否最终停止。 阿兰·图灵建立了一个重要的否定结论是，这个问题不能用计算机程序解决。 这个问题的意思是说，我能不能用一个程序来判断任意的一个程序在某个特定的输入下是不是会终止。 这个问题的意义在哪里… 继续实际应用中大量问题都是可解决的，但是我们可能没有足够的时间或者存储空间，因此有了计算机科学中的一个分支计算复杂性。 我们可以使用复杂性的公理来证明任意一个复杂问题的存在，以及问题有没有最好的程序。 几个很有用的算法 分而治之(divide and conquer) 贪婪算法(greedy algorithms) 深度优先搜索(depth first search) 动态编程(dynamic programming) 一些约定 函数的完全类型特征指返回类型和参数类型的组合，也叫原型 过程是一个可以取名字、可以被调用的计算步骤序列（带参数） 函数是一个可以向调用者返回值的过程 私有数据的维护叫封装或信息隐藏 重载指一个方法有多个带不同参数的定义，但有相同的返回值 覆盖指子类覆盖父类的方法 组织者类指一种只是为了将多个实例域组合在一起的简单的类。 通常实现为内部类。 组织者类中只有一个copy()方法 数学知识集合的定义方法集合指一堆不同的元素（通常有同样的类型），集合中的元素没有固定的顺序 列举法 描述法 两种方式都在一对大括号中，如下 $$S_1=\{a, b, c\}, S_2=\{x\vert x是2的整数次幂\}, S_3=\{1,\dots,n\}$$ 集合的基指集合中的元素的数量，记为$\vert S\vert$ 序列以特定顺序组合的一组元素称为序列，此外，序列中的元素可以是重复的。 通常像这么表示： $$(a,b,c),(b,c,a),(1,\dots,n)$$ 元组元组则指一个有不同类别元素的有限序列（也可以是相同的） 两个集合$S$和$T$的叉积，是一个对(二元组)的集合，每个对的第一个元素来自$S$，第二个元素来自$T$: $$S\times T=\{(x,y)\vert x\in S,y\in T\}$$ 元组可以根据数量分为二元组，三元组，四元组以及更多的n元组（一个大概是不行的，但我不确定） 集合的叉积迭代指类似如下的事情： $$S\times T\times U=\{(x,y,z)\vert x\in S,y\in T,z\in U\}$$ 一些结论或者关系或者定义集合之间的关系： $\subseteq$, $\subset$, $\supseteq$, $\supset$以及其他更多的关系 如果有限序列的所有元素都不同，那么我们称该序列是由同样的元素构成的有限集合的一个排列。 一个有$n$个元素的集合有$n!$个排列，有$2^n$个子集(包括自身和空集)，有$c_n^k$个基为$k$的子集。 $c_n^k$又称为二项式系数,计算如下： $$c_n^k=\frac{n!}{(n-k)!k!}$$ 关系和函数关系是叉积的一个简单子集，可以是有限的/无限的/空集/叉积本身。 如实数上的小于关系： $$\{(x,y)\vert x\in R,y\in R,x\lt y\}$$ 假设有关系$R$，符号$xRy$表示$(x,y)\in R$ 关系的一些属性： 自反性对于所有$x\in S$，有$(x,x)\in R$ 对称性$(x,y)\in R$，则$(y,x)\in R$ 反对称性$(x,y)\in R$，则$(y,x)\not\in R$ 传递性$(x,y)\in R$且$(y,z)in R$，则$(x,z)\in R$ 全等全等关系指一个满足自反、对称和可传递的关系，记做$\equiv$(又称为等价关系) 等价关系可以将底层集合划分为一组不相交的子集（也叫等价类），其中每个子集都是等价的。 如果$R$是$S$的一个等价关系，我们称$R$等价于$S$ 许多涉及二元关系的问题可以转换为一个图上的问题，如我们可能会在后面遇到形如“任务x必须在任务y完成之后才可以开始，有固定的人来完成固定的任务，如何安排在最短时间内完成”这样的问题。 代数和微积分工具Floor和Ceiling$\lfloor{x}\rfloor$表示小于或等于$x$的最大整数，$\lceil{x}\rceil$表示大于或等于$x$的最小整数。 对数的注意事项（一大部分的数学知识…我应该整理一些我比较不熟悉的） $x^{\log_by}=y^{\log_bx}$ 对数函数的复合： $\lg\lg(x)=\lg(\lg(x))=\lg^{(2)}(x)$ 如果$n$不是$2$的幂，则有一个整数$k$使得$2^k\lt{n}\lt2^{k+1}$ 此时$\lfloor{\lg{n}}\rfloor=k$且$\lceil{\lg{n}}\rceil=k+1$ 然后还有两个不等式： $n\le2{\lceil{n}\rceil}\le{2n}$$\frac{n}{2}\le2{\lfloor{n}\rfloor}\le{n}$ 概率基本事件：假设在给定的状况下，一个事件或试验有一个或$k$个结果，这些结果叫基本事件，记为$s_1,s_2,s_3,\dots,s_k$所有基本事件的集合叫事件空间，以$U$标记。 级数单调递增函数和凸函数积分逻辑元素分析算法和问题分析一个算法的目的是要改进他，为在解决一个问题中到底选择哪一个方法提供依据。 我们使用下面的标准： 正确性 所做工作的量（时间复杂度） 使用空间的量 简单，清晰 最优性 后面会介绍建立问题最低边界复杂性的技术。 正确性建立算法的正确性有三步： 对“正确”有一个清晰的概念 需要一个清晰的命题来描述期望有效输入的特性（前提） 需要处理每一个输出的结果（后置条件） 在输入前提条件满足，算法结束之后后置条件也正确的话，我们尝试证明输入输出关系的命题。 这一段有点乱，后面回来整理吧。 算法有两个方面，一是要解决的问题，二是解决问题所需要的指令序列。 什么是循环不变式(loop invariants)？ 所做工作的量不是简单地比较执行的时间，时间会随着不同的计算机而变化，但我们可以用执行的指令数或者语句的数量来代替执行时间。 一个简单的算法可能由一堆初始化构造和循环组成，此时我们可以用循环体执行的次数来衡量工作量。 在许多时候，为了分析一个算法，我们可以隔离出一种解决所研究问题的基本操作。 比如在如下问题中可以有这样的基本操作： 问题 操作 在一个数组中查找x 比较x和数组中的元素 两个实数矩阵相乘 两个实数做乘法（或者乘法和加法） 数组排序 比较数组的两个元素 遍历二叉树 便历边 任一迭代过程 过程调用 选定了基本操作之后，我们就可以粗略地估计执行基本操作的数目。 算法所做工作的度量也可以用一个算法的复杂性来代替。 平均和最坏分析我们知道工作量的大小不能用一个简单的数值来描述，对于不同的输入算法执行的步数也可能不同。 工作量依赖于输入量的大小，也依赖于具体输入的值。 我们可以根据工作量依赖于输入量的大小指出一个输入规模的度量： 问题 输入的规模 在名字数组中查找 x 数组中名字的个数 两个矩阵乘法 矩阵的维数 遍历二叉树 树节点的数量 解系统的线性方程 等式的数量，或未知数的数量，或者两者 一个关于图的问题 图节点的数量，或边的数量，或者两者 我们经常使用最坏情况复杂性来描述算法的行为。 定义如下： 令$D_n$是所考虑问题的规模为$n$的输入集合，$I$是$D_n$的一个元素。令$t(I)$是对于输入$I$要执行的基本操作的数量。我们定义函数$W$ $$W(n)=\max\{t(I)\vert I\in D_n\}$$ 函数$W(n)$称为算法的最坏复杂性，是对于规模为$n$的输入所要做的基本操作的最大数量。除非特别指出，当我们说一个算法的工作量时，都是指最坏情况时的工作量。当然有时候计算平均复杂度或者带权平均复杂度更有用。 平均复杂性的定义如下： $$A(n)=\sum\limits_{I\in D_n}P_r(I)t(I)$$ $P_r(I)$通过一些假设或者先验知识来获得。 下面是一个展示平均和最坏分析的例子： 下一步 重置 自动 let dataset = []; function getChart(change) { const width = 300; const height = 100; d3.select("#main-div").selectAll("*").remove(); let svg = d3.select("#main-div").append("svg").attr("width", width).attr("height", height); let c = svg.selectAll("svg") .data(dataset) .enter() .append("svg") let rec = c.append("rect").attr("stroke-width", 1).attr("stroke", "black").attr("x", (d, i) => i * 50 + 1).attr("y",50).attr("width",40).attr("height",40).attr("fill", d => d.color); let text = c.append("text").attr("x", (d, i) => i * 50 + 13).attr("y",75).attr("fill", "black").text(d => d.value); if (change !== undefined) { rec.transition().duration(800).attr("x", (d, i) => change[i] * 50 + 1) text.transition().duration((d, i) => 800) .attr("x", (d, i) => change[i] * 50 + 13) } } function updateData(change) { let backup = [].concat(dataset); for(let i = 0;i= changeList.length) { auto = false; return; } let next = changeList[step]; getChart(next); updateData(next); step += 1; } reset(); setInterval(() => { if(auto) { start(); } }, 1000); 这是一个最坏情况的冒泡排序，我们比较并交换了$10$次数组中的元素。 如果是最好的情况（已排序），我们只需要比较$4$次并且不做任何的交换就可以了。 我们对于输入$n$，可以得出冒泡排序中最坏情况需要比较和交换$1+2+\dots+(n-1)$次，也就是$\frac{n(n-1)}{2}$次。 看一个书上的例子，查找某个数在数组中的位置： 1234567891011int seqSearch(int[] E, int n, int K) &#123; int ans, index; ans = -1; for(index = 0; index &lt; n; ++index) &#123; if (K == E[index]) &#123; ans = index; break; &#125; &#125; return ans;&#125; 我们定义一下基本操作为比较$x$和数组的元素。 最坏分析： $W(n)=n$，也就是把所有的元素都比较以便才找到或者没找到对应的位置。 我们在假定数组中的元素各不相同下分析一下平均情况，记事件$K$在数组$E$中为$succ$,不在记为$fail$。 当$K$在$E$中时，令$t(I)$为输入$I$时的比较次数，我们有: $$\begin{split}A_{succ}(n)&amp;=\sum_{i=0}^{n-1}P_r(I_i\vert succ)t(I_i) \\&amp;=\sum_{i=0}^{n-1}(\frac{1}{n})(i+1) \\&amp;=\frac{n+1}{2}\end{split}$$ 而$K$不在$E$中时我们有： $$A_{fail}(n)=n$$ 进一步： $$A(n)=P_r(succ)A_{succ}(n)+P_r(fail)A_{fail}(n)=n(1-\frac{1}{2}q)+\frac{1}{2}q$$ 其中$q$为$K$在$E$中的概率。 再看一个]]></content>
      <categories>
        <category>编程</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker的一些有趣的东西]]></title>
    <url>%2Fblog%2F2018%2F12%2F13%2Fdocker-learning%2F</url>
    <content type="text"><![CDATA[Docker命令相关创建一个网络1docker network create --subnet=172.18.0.0/16 mynetwork docker默认使用的网络是172.17.0.0/16，所以创建网络应该从内网的其他部分选取。 列出网络1docker network ls 查看镜像信息1docker inspect imageid 查看使用记录1docker history docker内网访问的问题我需要在一个容器中使用反向代理，代理其它容器的服务，此容器使用公网，其他容器只能在内网访问。 即有如下三个容器A, B, C 然后A容器暴露80端口到公网 B和C暴露各自的服务端口如8080或3000等到内网 然后在A容器中使用反向代理，代理容器B和C中的服务，使得公网可以通过访问A来访问B和C的服务 直接使用-p绑定端口到默认网络容器A: 0.0.0.0:80:80容器B: 172.17.0.1:8080:8080容器C: 172.17.0.1:8081:3000 这个方案可以使容器A可以从公网的80端口访问，而容器A可以使用127.17.0.1:8080和127.17.0.1:8081分别访问容器B和容器C。 通过这种方式我们可以使用容器A来代理所有的内网服务。 分配一个固定的ip，直接访问使用172.18.0.0/16网络，分配固定ip，并直接访问 比如容器A是 0.0.0.0:80:80容器B使用ip和端口: 172.18.0.10:8080容器C使用ip和端口: 172.18.0.11:3000 这种方式需要改变容器内应用监听的ip和port号，比较麻烦。此外没有试过在默认网络是不是也可以用。讲道理我觉得可以。 –link这个命令似乎有神奇的作用，有机会看一看 -p的原理使用iptables可以查看实际进行的操作。 Docker的笔记 Docker使用Go语言开发，对进程进行封装隔离，属于操作系统层面的虚拟化技术。比虚拟机技术更加轻便，快捷。 和虚拟机的区别 虚拟机技术在所有在虚拟机之上使用Hypervisor，然后每一个虚拟机包含了应用，库文件以及整个操作系统 Docker技术则使用Docker Engine对所有的容器进行管理，每一个容器中只有应用的库文件 Docker的好处 更高效地利用系统资源（不需要完整的操作系统） 更快的启动时间（比起虚拟机，不需要一个操作系统，所以很快） 一致的运行环境（同样的Dockerfile，不用担心换环境导致错误） 持续交付和部署（使用Dockerfile，CI/CD） 轻松迁移（保证执行环境的一致性） 更轻松的维护和扩展（什么是分层存储和镜像技术？）（有很多官方镜像可以使用） 镜像，容器和仓库镜像Docker镜像相当于一个root文件系统。Linux内核启动后会挂载root文件系统为其提供用户空间支持。 不是很懂这个 分层存储 分层存储利用了Union FS技术,docker的镜像并不是一个单一的文件，而是由一组文件组成。 镜像构建时会一层一层地构建。而在后面的层将无法改动前面的层，删除上一层的文件的操作实际上是将其标志为删除。 好处是在镜像复用或者定制时更加容易。 容器一个镜像可以有多个容器实例，就像面向对象的类和实例的关系一样。 容器可以进行的操作有： 创建 启动 停止 删除 暂停 跟虚拟机可以进行的操作很类似。 特性： 容器的实质是进程，这个进程运行于独立的命名空间 每一个容器运行时，会在镜像上面创建一层容器存储层，最佳实践推荐不要向存储层写入任何数据。 文件操作： 应该使用数据卷或者绑定宿主目录的方式对宿主进行读写，在这种操作方式下，容器消亡时数据并不会消亡。 仓库Docker Registry是一个集中存储、分发镜像的服务 一个Registry里面可以包含多个仓库(Repository),每个仓库可以包含多喝标签(tag); 每个标签对应一个镜像。 比如: ubuntu:16.04 ubuntu:latest 如果在docker pull时不指定标签，使用默认标签latest 常用的公开registry服务： Docker Hub Quay.io Google Container Registry 常见的加速器(Registry Mirror): 阿里云加速器 DaoCloud加速器 (配置方式呢) Dockerfile的操作 每一个指令，都会建立一层存储 FROM选择基础镜像，如果从空白开始则是FROM scratch 使用Go开发的应用很多会使用这种方式来制作镜像，体积更加小巧 RUN用于执行命令行命令，注意进行一个完整的操作时应该将命令行命令写在同一个RUN中，用\换行 举例如下: (摘自 https://yeasy.gitbooks.io/docker_practice/image/build.html) 1234567891011121314FROM debian:jessieRUN buildDeps='gcc libc6-dev make' \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install -y $buildDeps \ &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" \ &amp;&amp; mkdir -p /usr/src/redis \ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \ &amp;&amp; make -C /usr/src/redis \ &amp;&amp; make -C /usr/src/redis install \ &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; rm redis.tar.gz \ &amp;&amp; rm -r /usr/src/redis \ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 这样可以避免出无意义的层并且增加镜像的体积(因为后面的层无法真正地删除前面的层的文件) COPYADDCMDCMD是容器启动时执行的命令，和RUN一样有两种格式： shell格式 exec格式 12CMD 命令CMD ["xxx", "arg1", "arg2"] 通常推荐使用exec格式 也可以先使用ENTRYPOINT再在CMD里面放参数列表 ENTRYPOINTENTRYPOINT主要有两个作用： 是使镜像可以像命令一样使用 应用运行前的准备工作 第一种是将原本的CMD命令用ENTRYPOINT替换 如我们构建了一个查看ip地址的镜像，其中的CMD如下: 1CMD [ "curl", "-s", "https://ip.cn" ] 当我们使用docker命令运行时，跟在镜像后面的部分会替换CMD，也就是我们不能通过在后面加上一些部分如-i来运行curl -s https://ip.cn -i，这个时候我们可以使用ENTRYPOINT。 1ENTRYPOINT [ "curl", "-s", "https://ip.cn" ] 这时候我们就可以docker run ip_check -i 这样来运行了(假设镜像叫ip_check) 第二种情况则是我们需要进行的一些初始化操作是需要根据命令行参数来决定的情况，可以在CMD里面放默认的启动参数，如果我们需要执行其他的操作，可以在命令行运行时指定参数，替换CMD中的参数。 ENVENV是用来设置环境变量的。 格式有两种： ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; 换行使用\ ARGVOLUMEEXPOSE EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务 所以它实际上并不能暴露端口。 如果EXPOSE和-P参数一起使用，则会使用随机映射的策略进行映射，这估计是EXPOSE的唯一作用。 -p 参数则用于手动指定端口映射。 格式大致如ip:宿主机port:容器port 这里的ip可以用的有0.0.0.0，localhost以及docker中的其他网络。 WORKDIR用于改变各层工作目录的位置。 也就是指明后面执行的命令的位置… 具体的命令有：RUN,CMD,ENTRYPOINT USERUSER则是指定后面的命令执行时的用户身份。 （这个用户必须是之前建立好的） HEALTHCHECKONBUILD收藏一个关于docker的gitbook: https://yeasy.gitbooks.io/docker_practice/ 操作数据]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS的数据可视化工具收集]]></title>
    <url>%2Fblog%2F2018%2F12%2F09%2Fvisualize-lib-js%2F</url>
    <content type="text"><![CDATA[D3.js官网有一些文档和例子中文站 流程图 据说这个叫力导向图 var dataset = { nodes: [ { name: "Adam" }, { name: "Bob" }, { name: "Carrie" }, { name: "Donovan" }, { name: "Edward" }, { name: "Felicity" }, { name: "George" }, { name: "Hannah" }, { name: "Iris" }, { name: "Jerry" }, { name: "Kkk" }, { name: "Llull" }, { name: "Mnn" }, { name: "Nmm" }, { name: "Ok" }, ], links: [ { source: 0, target: 1 }, { source: 0, target: 2 }, { source: 0, target: 3 }, { source: 0, target: 4 }, { source: 1, target: 5 }, { source: 2, target: 5 }, { source: 2, target: 5 }, { source: 3, target: 4 }, { source: 3, target: 14 }, { source: 5, target: 8 }, { source: 5, target: 9 }, { source: 6, target: 7 }, { source: 7, target: 8 }, { source: 8, target: 9 }, { source: 8, target: 11 }, { source: 8, target: 14 }, { source: 10, target: 11}, { source: 12, target: 13}, { source: 12, target: 14}, { source: 13, target: 14}, ] }; var svg = d3.select('svg'), width = +svg.attr('width'), height = +svg.attr('height'), colors = d3.scaleOrdinal(d3.schemeCategory10); var simulation = d3.forceSimulation(dataset.nodes) .force('charge', d3.forceManyBody()) .force('link', d3.forceLink(dataset.links)) .force('center', d3.forceCenter(width / 2, height / 2)); var link = svg.append('g') .attr('class', 'links') .selectAll('line') .data(dataset.links) .enter().append('line') .attr('stroke', '#ccc') .attr('stroke-width', 1); var node = svg.append('g') .attr('class', 'nodes') .selectAll('circle') .data(dataset.nodes) .enter().append('circle') .attr('r', 10) .attr('fill', function(d, i) { return colors(i); }) .call(d3.drag() .on('start', dragstarted) .on('drag', dragged) .on('end', dragended)); node.append('title') .text(function(d) { return d.name; }); simulation .nodes(dataset.nodes) .on('tick', ticked); simulation.force('link') .links(dataset.links); function ticked() { link .attr('x1', function(d) { return d.source.x; }) .attr('y1', function(d) { return d.source.y; }) .attr('x2', function(d) { return d.target.x; }) .attr('y2', function(d) { return d.target.y; }) node .attr('cx', function(d) { return d.x; }) .attr('cy', function(d) { return d.y; }) } function dragstarted(d) { if (!d3.event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; } function dragged(d) { d.fx = d3.event.x; d.fy = d3.event.y; } function dragended(d) { if (!d3.event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; } 这个是一个可以折叠的树的效果： let dx = 20 let dy = 162.5 let data = { name: "开始", children: [ { name: "初始化数据", children: [ {name: "输入a"}, {name: "输入b"}, {name: "瞎分配一些内存空间"} ] }, { name: "运行", children: [ {name: "计算a+b，结果存在c"}, {name: "将c除以2"} ] }, { name: "结束", children: [ {name: "回收分配的内存空间"}, {name: "返回c"} ] } ] } let margin = ({top: 10, right: 120, bottom: 10, left: 40}) let tree = d3.tree().nodeSize([dx, dy]) let diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x) chart = () => { const root = d3.hierarchy(data); root.x0 = dy / 2; root.y0 = 0; root.descendants().forEach((d, i) => { d.id = i; d._children = d.children; if (d.depth && d.data.name.length !== 7) d.children = null; }); const svg = d3.create("svg") .attr("width", width) .attr("height", dx) .attr("viewBox", [-margin.left, -margin.top, width, dx]) .style("font", "12px sans-serif") .style("user-select", "none"); const gLink = svg.append("g") .attr("fill", "none") .attr("stroke", "#555") .attr("stroke-opacity", 0.4) .attr("stroke-width", 1.5); const gNode = svg.append("g") .attr("cursor", "pointer"); function update(source) { const duration = d3.event && d3.event.altKey ? 2500 : 250; const nodes = root.descendants().reverse(); const links = root.links(); // Compute the new tree layout. tree(root); let left = root; let right = root; root.eachBefore(node => { if (node.x < left.x) left = node; if (node.x > right.x) right = node; }); const height = right.x - left.x + margin.top + margin.bottom; const transition = svg.transition() .duration(duration) .attr("height", height) .attr("viewBox", [-margin.left, left.x - margin.top, width, height]) .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle")); // Update the nodes… const node = gNode.selectAll("g") .data(nodes, d => d.id); // Enter any new nodes at the parent's previous position. const nodeEnter = node.enter().append("g") .attr("transform", d => `translate(${source.y0},${source.x0})`) .attr("fill-opacity", 0) .attr("stroke-opacity", 0) .on("click", d => { d.children = d.children ? null : d._children; update(d); }); nodeEnter.append("circle") .attr("r", 2.5) .attr("fill", d => d._children ? "#555" : "#999"); nodeEnter.append("text") .attr("dy", "0.31em") .attr("x", d => d._children ? -6 : 6) .attr("text-anchor", d => d._children ? "end" : "start") .text(d => d.data.name) .clone(true).lower() .attr("stroke-linejoin", "round") .attr("stroke-width", 3) .attr("stroke", "white"); // Transition nodes to their new position. const nodeUpdate = node.merge(nodeEnter).transition(transition) .attr("transform", d => `translate(${d.y},${d.x})`) .attr("fill-opacity", 1) .attr("stroke-opacity", 1); // Transition exiting nodes to the parent's new position. const nodeExit = node.exit().transition(transition).remove() .attr("transform", d => `translate(${source.y},${source.x})`) .attr("fill-opacity", 0) .attr("stroke-opacity", 0); // Update the links… const link = gLink.selectAll("path") .data(links, d => d.target.id); // Enter any new links at the parent's previous position. const linkEnter = link.enter().append("path") .attr("d", d => { const o = {x: source.x0, y: source.y0}; return diagonal({source: o, target: o}); }); // Transition links to their new position. link.merge(linkEnter).transition(transition) .attr("d", diagonal); // Transition exiting nodes to the parent's new position. link.exit().transition(transition).remove() .attr("d", d => { const o = {x: source.x, y: source.y}; return diagonal({source: o, target: o}); }); // Stash the old positions for transition. root.eachBefore(d => { d.x0 = d.x; d.y0 = d.y; }); } update(root); return svg.node(); } let c = chart(); document.querySelector('#svg-div').appendChild(c); EchartsinfoVisCesiumHighChartsFusionChartsAnyChartamChartChart.jsChartist.jsGoogle ChartLeafletDygraphsichartsflowchart.jsflotn3-chartsEmber ChartsChartKickMeteorChartsEJS ChartuvCharts]]></content>
      <tags>
        <tag>可视化</tag>
        <tag>JavaScript</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js测试]]></title>
    <url>%2Fblog%2F2018%2F12%2F03%2Fthreejs-lab%2F</url>
    <content type="text"><![CDATA[#three-div { margin: 0 auto; width: 250px; padding: 0 !important; } #three-div br { display: none; } let scene = new THREE.Scene(); const height = 200; const width = 200; let camera = new THREE.PerspectiveCamera( 75, width/height, 0.1, 1000 ); let renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize( width, height ); renderer.setClearColor(0xffffff); document.querySelector('#three-div').appendChild( renderer.domElement ); //添加环境光 { var ambientLight = new THREE.AmbientLight( 0x707070 ); scene.add( ambientLight ); } //添加平行光 { var directionalLight = new THREE.DirectionalLight( 0xffffff ); directionalLight.position.set( 1, 0.75, 0.5 ).normalize(); scene.add( directionalLight ); } var axes = new THREE.AxesHelper(10); scene.add(axes); cube(); camera.position.z = 5; camera.position.x = 1; camera.position.y = 2; renderer.render( scene, camera ); function sphere() { let sphereGeo = new THREE.SphereGeometry(5, 40, 40); let sphereMat = new THREE.MeshLambertMaterial({ color:0x0000FF, wireframe:false }); let sphereMesh = new THREE.Mesh(sphereGeo, sphereMat); sphereMesh.position.set(3, 10, -15); scene.add(sphereMesh); } function cube() { let cube = new THREE.CubeGeometry(10, 10, 10, 1, 1, 1); let cubeMat = new THREE.MeshLambertMaterial({ color: 0xbbbbbb, wireframe: false }); let cubeMesh = new THREE.Mesh(cube, cubeMat); cubeMesh.position.set(-1, 5, -30); cubeMesh.rotation.y += 0.25 * Math.PI; cubeMesh.rotation.z += 0.15 * Math.PI; scene.add(cubeMesh); }]]></content>
      <tags>
        <tag>玩儿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebGL测试]]></title>
    <url>%2Fblog%2F2018%2F11%2F30%2Fwebgl-lab%2F</url>
    <content type="text"><![CDATA[#canvas-div { margin: 0 auto; width: 250px; padding: 0 !important; } #canvas-div br { display: none; } #canvas { margin: 0; } var cubeRotation = 0.0; main(); let mat4 = glMatrix.mat4; // // Start here // function main() { const canvas = document.querySelector('#canvas'); const gl = canvas.getContext('webgl'); // If we don't have a GL context, give up now if (!gl) { alert('Unable to initialize WebGL. Your browser or machine may not support it.'); return; } // Vertex shader program const vsSource = ` attribute vec4 aVertexPosition; attribute vec3 aVertexNormal; attribute vec2 aTextureCoord; uniform mat4 uNormalMatrix; uniform mat4 uModelViewMatrix; uniform mat4 uProjectionMatrix; varying highp vec2 vTextureCoord; varying highp vec3 vLighting; void main(void) { gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition; vTextureCoord = aTextureCoord; // Apply lighting effect highp vec3 ambientLight = vec3(0.3, 0.3, 0.3); highp vec3 directionalLightColor = vec3(1, 1, 1); highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75)); highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0); highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0); vLighting = ambientLight + (directionalLightColor * directional); } `; // Fragment shader program const fsSource = ` varying highp vec2 vTextureCoord; varying highp vec3 vLighting; uniform sampler2D uSampler; void main(void) { highp vec4 texelColor = texture2D(uSampler, vTextureCoord); gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a); } `; // Initialize a shader program; this is where all the lighting // for the vertices and so forth is established. const shaderProgram = initShaderProgram(gl, vsSource, fsSource); // Collect all the info needed to use the shader program. // Look up which attributes our shader program is using // for aVertexPosition, aVertexNormal, aTextureCoord, // and look up uniform locations. const programInfo = { program: shaderProgram, attribLocations: { vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'), vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'), textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'), }, uniformLocations: { projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'), modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'), normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'), uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'), }, }; // Here's where we call the routine that builds all the // objects we'll be drawing. const buffers = initBuffers(gl); const texture = loadTexture(gl, '/blog/images/avatar.jpg'); var then = 0; // Draw the scene repeatedly function render(now) { now *= 0.001; // convert to seconds const deltaTime = now - then; then = now; drawScene(gl, programInfo, buffers, texture, deltaTime); requestAnimationFrame(render); } requestAnimationFrame(render); } // // initBuffers // // Initialize the buffers we'll need. For this demo, we just // have one object -- a simple three-dimensional cube. // function initBuffers(gl) { // Create a buffer for the cube's vertex positions. const positionBuffer = gl.createBuffer(); // Select the positionBuffer as the one to apply buffer // operations to from here out. gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // Now create an array of positions for the cube. const positions = [ // Front face -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, // Back face -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, // Top face -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, // Bottom face -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, // Right face 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, // Left face -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, ]; // Now pass the list of positions into WebGL to build the // shape. We do this by creating a Float32Array from the // JavaScript array, then use it to fill the current buffer. gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW); // Set up the normals for the vertices, so that we can compute lighting. const normalBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer); const vertexNormals = [ // Front 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, // Back 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, // Top 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // Bottom 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, // Right 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // Left -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0 ]; gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW); // Now set up the texture coordinates for the faces. const textureCoordBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer); const textureCoordinates = [ // Front 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // Back 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // Top 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // Bottom 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // Right 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // Left 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, ]; gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW); // Build the element array buffer; this specifies the indices // into the vertex arrays for each face's vertices. const indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); // This array defines each face as two triangles, using the // indices into the vertex array to specify each triangle's // position. const indices = [ 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // back 8, 9, 10, 8, 10, 11, // top 12, 13, 14, 12, 14, 15, // bottom 16, 17, 18, 16, 18, 19, // right 20, 21, 22, 20, 22, 23, // left ]; // Now send the element array to GL gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW); return { position: positionBuffer, normal: normalBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer, }; } // // Initialize a texture and load an image. // When the image finished loading copy it into the texture. // function loadTexture(gl, url) { const texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); // Because images have to be download over the internet // they might take a moment until they are ready. // Until then put a single pixel in the texture so we can // use it immediately. When the image has finished downloading // we'll update the texture with the contents of the image. const level = 0; const internalFormat = gl.RGBA; const width = 1; const height = 1; const border = 0; const srcFormat = gl.RGBA; const srcType = gl.UNSIGNED_BYTE; const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel); const image = new Image(); image.onload = function() { gl.bindTexture(gl.TEXTURE_2D, texture); gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, image); // WebGL1 has different requirements for power of 2 images // vs non power of 2 images so check if the image is a // power of 2 in both dimensions. if (isPowerOf2(image.width) && isPowerOf2(image.height)) { // Yes, it's a power of 2. Generate mips. gl.generateMipmap(gl.TEXTURE_2D); } else { // No, it's not a power of 2. Turn of mips and set // wrapping to clamp to edge gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); } }; image.src = url; return texture; } function isPowerOf2(value) { return (value & (value - 1)) == 0; } // // Draw the scene. // function drawScene(gl, programInfo, buffers, texture, deltaTime) { gl.clearColor(1.0, 1.0, 1.0, 1.0); // Clear to black, fully opaque gl.clearDepth(1.0); // Clear everything gl.enable(gl.DEPTH_TEST); // Enable depth testing gl.depthFunc(gl.LEQUAL); // Near things obscure far things // Clear the canvas before we start drawing on it. gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Create a perspective matrix, a special matrix that is // used to simulate the distortion of perspective in a camera. // Our field of view is 45 degrees, with a width/height // ratio that matches the display size of the canvas // and we only want to see objects between 0.1 units // and 100 units away from the camera. const fieldOfView = 45 * Math.PI / 180; // in radians const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight; const zNear = 0.1; const zFar = 100.0; const projectionMatrix = mat4.create(); // note: glmatrix.js always has the first argument // as the destination to receive the result. mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar); // Set the drawing position to the "identity" point, which is // the center of the scene. const modelViewMatrix = mat4.create(); // Now move the drawing position a bit to where we want to // start drawing the square. mat4.translate(modelViewMatrix, // destination matrix modelViewMatrix, // matrix to translate [-0.0, 0.0, -6.0]); // amount to translate mat4.rotate(modelViewMatrix, // destination matrix modelViewMatrix, // matrix to rotate cubeRotation, // amount to rotate in radians [0, 0, 1]); // axis to rotate around (Z) mat4.rotate(modelViewMatrix, // destination matrix modelViewMatrix, // matrix to rotate cubeRotation * .7,// amount to rotate in radians [0, 1, 0]); // axis to rotate around (X) mat4.rotate(modelViewMatrix, // destination matrix modelViewMatrix, // matrix to rotate cubeRotation * .5,// amount to rotate in radians [1, 0, 0]); // axis to rotate around (X) const normalMatrix = mat4.create(); mat4.invert(normalMatrix, modelViewMatrix); mat4.transpose(normalMatrix, normalMatrix); // Tell WebGL how to pull out the positions from the position // buffer into the vertexPosition attribute { const numComponents = 3; const type = gl.FLOAT; const normalize = false; const stride = 0; const offset = 0; gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position); gl.vertexAttribPointer( programInfo.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset); gl.enableVertexAttribArray( programInfo.attribLocations.vertexPosition); } // Tell WebGL how to pull out the texture coordinates from // the texture coordinate buffer into the textureCoord attribute. { const numComponents = 2; const type = gl.FLOAT; const normalize = false; const stride = 0; const offset = 0; gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord); gl.vertexAttribPointer( programInfo.attribLocations.textureCoord, numComponents, type, normalize, stride, offset); gl.enableVertexAttribArray( programInfo.attribLocations.textureCoord); } // Tell WebGL how to pull out the normals from // the normal buffer into the vertexNormal attribute. { const numComponents = 3; const type = gl.FLOAT; const normalize = false; const stride = 0; const offset = 0; gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal); gl.vertexAttribPointer( programInfo.attribLocations.vertexNormal, numComponents, type, normalize, stride, offset); gl.enableVertexAttribArray( programInfo.attribLocations.vertexNormal); } // Tell WebGL which indices to use to index the vertices gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices); // Tell WebGL to use our program when drawing gl.useProgram(programInfo.program); // Set the shader uniforms gl.uniformMatrix4fv( programInfo.uniformLocations.projectionMatrix, false, projectionMatrix); gl.uniformMatrix4fv( programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix); gl.uniformMatrix4fv( programInfo.uniformLocations.normalMatrix, false, normalMatrix); // Specify the texture to map onto the faces. // Tell WebGL we want to affect texture unit 0 gl.activeTexture(gl.TEXTURE0); // Bind the texture to texture unit 0 gl.bindTexture(gl.TEXTURE_2D, texture); // Tell the shader we bound the texture to texture unit 0 gl.uniform1i(programInfo.uniformLocations.uSampler, 0); { const vertexCount = 36; const type = gl.UNSIGNED_SHORT; const offset = 0; gl.drawElements(gl.TRIANGLES, vertexCount, type, offset); } // Update the rotation for the next draw cubeRotation += deltaTime; } // // Initialize a shader program, so WebGL knows how to draw our data // function initShaderProgram(gl, vsSource, fsSource) { const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource); const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource); // Create the shader program const shaderProgram = gl.createProgram(); gl.attachShader(shaderProgram, vertexShader); gl.attachShader(shaderProgram, fragmentShader); gl.linkProgram(shaderProgram); // If creating the shader program failed, alert if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) { alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram)); return null; } return shaderProgram; } // // creates a shader of the given type, uploads the source and // compiles it. // function loadShader(gl, type, source) { const shader = gl.createShader(type); // Send the source to the shader object gl.shaderSource(shader, source); // Compile the shader program gl.compileShader(shader); // See if it compiled successfully if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; } return shader; }]]></content>
      <tags>
        <tag>计算机图形学</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集一些变换矩阵]]></title>
    <url>%2Fblog%2F2018%2F11%2F29%2Ftransformation-metrix%2F</url>
    <content type="text"><![CDATA[下面的内容主要是收集一些二维/三维图形变换的矩阵，并尝试理解一下为什么。 二维图形变换显然，对一个二维图形做几何变换，就是对图形上的每一个点做相应的几何变换。虽然有时候实际上我们并不需要全部做，比如一个直线段我们只需要把端点变换过去然后连起来就可以了。 常见的二维图形几何变换有： 平移 缩放 旋转 二维齐次变换矩阵我们引入一个概念叫二位齐次变换矩阵，它可以用来进行二位图像的各种变换，如下： $$T_{2D}=\left(\begin{matrix}a &amp; d &amp; g \\b &amp; e &amp; h \\c &amp; f &amp; i \\\end{matrix}\right)$$ 我们可以从变换功能上把它分成四个部分: $$\left(\begin{matrix}a &amp; d \\b &amp; e \\\end{matrix}\right),\left(\begin{matrix}c &amp; f \\\end{matrix}\right),\left(\begin{matrix}g \\h \\\end{matrix}\right),\left(\begin{matrix}i \\\end{matrix}\right)$$ 其中：$\left(\begin{matrix}a &amp; d \\b &amp; e \\\end{matrix}\right)$是对图形进行比例、旋转、对称、错切等变换；$\left(\begin{matrix}c &amp; f \\\end{matrix}\right)$是对图形进行平移变换；$\left(\begin{matrix}g \\h \\\end{matrix}\right)$是对图形进行投影变换；$\left(\begin{matrix}i\end{matrix}\right)$是对图形整体做比例变换。 平移平移会用到的位置就是上述的$\left(\begin{matrix}c &amp; f \\\end{matrix}\right)$位置，然后其余部分按照单位矩阵补上就OK了，也就是： $$\boldsymbol{p’}=\left(\begin{matrix}x’ &amp; y’ &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}x &amp; y &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\T_x &amp; T_y &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}x+T_x &amp; y+T_y &amp; 1\end{matrix}\right)$$ $(x+T_x, y+T_y)$ $(x,y)$ let main = () => { let canvas = document.querySelector("#moveCanvas"); let ctx = canvas.getContext("2d"); ctx.beginPath(); ctx.moveTo(5, 100); ctx.lineTo(295, 100); ctx.stroke(); ctx.beginPath(); ctx.moveTo(30, 195); ctx.lineTo(30, 5); ctx.stroke(); ctx.setLineDash([3, 2]); ctx.strokeRect(25, 85, 60, 40); ctx.setLineDash([]); ctx.strokeRect(125, 35, 60, 40); ctx.beginPath(); ctx.arc(85,85,2,0,Math.PI*2,true); ctx.closePath(); ctx.fillStyle = "red"; ctx.fill(); ctx.beginPath(); ctx.arc(185,35,2,0,Math.PI*2,true); ctx.closePath(); ctx.fill(); } main(); 缩放缩放也很简单，只需要用到二维齐次变换矩阵中的$a,e$就可以了。 $$\boldsymbol{p’}=\left(\begin{matrix}x’ &amp; y’ &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}x &amp; y &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}S_x &amp; 0 &amp; 0 \\0 &amp; S_y &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}xS_x &amp; yS_y &amp; 1\end{matrix}\right)$$ $(xS_x, yS_y)$ $(x,y)$ main = () => { let canvas = document.querySelector("#scaleCanvas"); let ctx = canvas.getContext("2d"); ctx.beginPath(); ctx.moveTo(5, 100); ctx.lineTo(295, 100); ctx.stroke(); ctx.beginPath(); ctx.moveTo(30, 195); ctx.lineTo(30, 5); ctx.stroke(); ctx.setLineDash([3, 2]); ctx.strokeRect(25, 85, 60, 40); ctx.setLineDash([]); ctx.strokeRect(20, 70, 120, 80); ctx.beginPath(); ctx.arc(85, 85, 2, 0, Math.PI*2, true); ctx.closePath(); ctx.fillStyle = "red"; ctx.fill(); ctx.beginPath(); ctx.arc(140, 70, 2, 0, Math.PI*2, true); ctx.closePath(); ctx.fill(); } main(); 旋转旋转时，我们假设逆时针旋转了$\theta$，很容易可以得到如下关系： （用$x’=t\sin(\alpha+\theta)$这种方式或者 比较麻烦的方式） $$\boldsymbol{p’}=\left(\begin{matrix}x’ &amp; y’ &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}x &amp; y &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}\cos{\theta} &amp; \sin{\theta} &amp; 0 \\-\sin{\theta} &amp; \cos{\theta} &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}x\cos{\theta}-y\sin{\theta} &amp; x\sin{\theta}+y\cos{\theta} &amp; 1\end{matrix}\right)$$ $(x\cos\theta-y\sin\theta, x\sin\theta+y\cos\theta)$ $(x,y)$ $\theta$ main = () => { let canvas = document.querySelector("#rotateCanvas"); let ctx = canvas.getContext("2d"); ctx.beginPath(); ctx.moveTo(5, 180); ctx.lineTo(295, 180); ctx.stroke(); ctx.beginPath(); ctx.moveTo(30, 195); ctx.lineTo(30, 5); ctx.stroke(); ctx.setLineDash([7, 2]); ctx.beginPath(); ctx.moveTo(30, 180); ctx.lineTo(170, 125); ctx.stroke(); ctx.beginPath(); ctx.moveTo(30, 180); ctx.lineTo(122.69, 62.78); ctx.stroke(); ctx.setLineDash([3, 2]); ctx.beginPath(); ctx.moveTo(150, 150); ctx.lineTo(230, 140); ctx.lineTo(170, 125); ctx.lineTo(150, 150); ctx.stroke(); ctx.setLineDash([]); ctx.beginPath(); ctx.moveTo(118.02, 94.25); ctx.lineTo(181.7, 45.66); ctx.lineTo(122.69, 62.78); ctx.lineTo(118.02, 94.25); ctx.stroke(); ctx.beginPath(); ctx.arc(122.69, 62.78, 2, 0, Math.PI*2, true); ctx.closePath(); ctx.fillStyle = "red"; ctx.fill(); ctx.beginPath(); ctx.arc(170, 125, 2, 0, Math.PI*2, true); ctx.closePath(); ctx.fill(); } main(); 对称首先我们会讨论一下关于坐标轴或者某些简单的直线对称的变换矩阵，然后再通过变换的组合来完成对任意直线的对称变换。 关于坐标轴对称当一个图形关于$x$轴对称时，我们只需要将$y$变为原来的相反数即可，因此有以下矩阵： $$\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; -1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 关于$y$对称则是： $$\left(\begin{matrix}-1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 关于原点对称也就是两个坐标都取相反数： $$\left(\begin{matrix}-1 &amp; 0 &amp; 0 \\0 &amp; -1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 关于$y=x$或者$y=-x$对称关于$y=x$对称时，实际上是将$x$和$y$对调，即$y’=x,x’=y$，因此： $$\left(\begin{matrix}0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 那么如果是$y=-x$，我们有： $$\left(\begin{matrix}0 &amp; -1 &amp; 0 \\-1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 关于直线$y=kx+b$对称上面提到的几个都比较容易理解…不过当对一条长得比较随意的直线对称的时候就没那么好直接写出来了。 我们可以把变换分解一下。 我们可以通过平移，旋转和简单的对称来组合成一个比较复杂的变化。 比如这条$y=kx+b$,截距是$b$,我们可以先将点在$y$轴上挪动$-y$,然后关于$y=kx$对称,结束后再往回挪动即可。 因此有： $$\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; -b &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}? &amp; ? &amp; 0 \\? &amp; ? &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; b &amp; 1 \\\end{matrix}\right)$$ 那么中间的一部分就是关于$y=kx$对称的矩阵，我们要如何得到它呢。 $y=kx$时我们假设直线与$x$轴的夹角为$\theta$，（从$x$轴开始两个方向旋转,$\theta$的范围是$(-\frac{\pi}{2},\frac{\pi}{2})$） 我们有$k=\tan{\theta}$,即$\theta=\arctan{k}$,可以知道$y=kx$是$x$轴旋转了$\theta$后得到的直线。 因此我么可以先将点旋转$-\theta$,再关于$x$轴对称，最后再旋转$\theta$即可，有： $$\left(\begin{matrix}\cos{\theta} &amp; -\sin{\theta} &amp; 0 \\\sin{\theta} &amp; \cos{\theta} &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; -1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}\cos{\theta} &amp; \sin{\theta} &amp; 0 \\-\sin{\theta} &amp; \cos{\theta} &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 即 $$\left(\begin{matrix}\cos{2\theta} &amp; \sin{2\theta} &amp; 0 \\\sin{2\theta} &amp; -\cos{2\theta} &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 是一个美美的式子呢。 我们再代回刚才的$?$号矩阵，可以得到： $$\left(\begin{matrix}\cos{2\theta} &amp; \sin{2\theta} &amp; 0 \\\sin{2\theta} &amp; -\cos{2\theta} &amp; 0 \\-b\sin{2\theta} &amp; b(\cos{2\theta}+1) &amp; 1 \\\end{matrix}\right)$$ 这就是我们的对称矩阵了，其中$\theta=\arctan{k}$ 三维图形变换 .canvas-div { position: relative; z-index: 1; margin: 0 auto; padding: 0; width: 300px; } .canvas-top { position: absolute; top: 0; margin: 0 auto; width: 300px; z-index: 99; font-size: 0.7rem; } #c1 { padding: 14px 0 0 130px; } #c2 { padding: 60px 0 0 60px; } #c3 { padding: 45px 0 0 110px; } #c4 { padding: 75px 0 0 90px; } #c5 { padding: 25px 0 0 90px; } #c6 { padding: 95px 0 0 140px; } #c7 { padding: 150px 0 0 50px; } .canvas-div br { display: none; }]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>矩阵</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神摸是隐马尔可夫模型(Hidden Markov Model)]]></title>
    <url>%2Fblog%2F2018%2F11%2F24%2Fhidden-markov-model%2F</url>
    <content type="text"><![CDATA[举个栗子隐马尔可夫模型可以描述很多场景。 里面大概有这么些东西： 一个可以观测到的可见状态链$X_0,\dots,X_{n-1},X_n$ 一个隐含状态链$Y_0,\dots,Y_{n-1},Y_n$ 几个隐含状态和它们之间的转换概率 从隐含状态到可见状态的发射概率 一个不好理解的例子一个不好理解的例子是，我们看到了一个序列[1, 2, 5, 7, 2, 3, 2],隐马尔可夫模型认为它有一个对应的隐含序列[a, c, b, c, a, c, b],我们观测到的序列，是在隐含序列以这样的顺序发生时，其中的每一个隐含状态以一个概率触发了对应的可见状态，而隐含状态之间的转换也有对应的概率。这里隐含状态的数量有$4$个，对应的转换概率我们没有说。 一个好一些的例子我们举一个好理解的例子是，一个人最近几天做的主要事情是： 逛街，浇花，在家看电视，散步，浇花，散步，在家看电视。 我们知道的是不同的天气下，人干出这些事情的概率是不一样的，所以我们可能会对一个隐含状态链感兴趣，也就是这几天的天气。(我们不知道或者忘记了天气，只知道这个人干了什么) 天晴的时候可能会有比较大的概率去浇花逛街散步，下雨的时候可能就是在家看电视，阴天又是另一个情况。 假设我们已经知道了，隐含状态有3种： 阴天、雨天、晴天。 我们也知道这三种天气下，一个人干这些事情的概率，这个就是从隐含状态到可见状态的发射概率。 我们还观察了天气变化的规律，统计出了不同的天气互相转换的概率(假设事情就是这样的)，那么这个就是隐含状态的转换概率。比如雨天有$50\%$的概率变成雨天,有$20\%$的概率变成晴天之类的。 当然天气的互相转换在这里是被简化过的，如果我们再加上一点复杂的东西，这个模型就更复杂了，暂时不考虑这个。 那么隐马尔可夫模型就是描述这样的一个模型，其中的隐含状态链又称为马尔可夫链。 在这个模型中主要关心的问题如下： HMM中的三种问题已知隐含状态数量，转换概率和可见状态链，求隐含状态链我们现在知道了不同天气的转换概率，和不同天气下人做不同事情的概率，现在看到一个人这几天做了这些事情，想知道这几天的天气最可能是怎么样的。 (然后我们会用一个$\mathrm{Viterbi}$算法来解决这个问题，如果有人想穷举并且感觉会炸然后毫无头绪的话可以了解一下这个做法) 当然我们是求不同情况产生这一个可见状态序列的概率，取其中最大的一个。 已知隐含状态数量，转换概率和可见状态链，求这个结果的概率我们现在知道了不同天气的转换概率，和不同天气下人做不同事情的概率，现在看到一个人这几天做了这些事情，开始想：总觉得我们的这个天气转换的概率是不对的，或者不同天气下人做这些事情的概率是有问题的。那么我们可以看看在我们已知的模型下，这个人可能做出这个结果的概率。如果这个概率很小，还有其他结果的概率比它大，甚至大得多，很可能是我们的模型出了问题。 这个问题可能在这个例子中没那么有必要，假设我们是在一个赌场赌博，怀疑人家的骰子有问题的时候也许就可以用上了。 已知隐含状态数量和可见状态链，求转换概率这个问题是…我们知道了有几个天气，不同天气下人做一些事情的概率，现在想知道天气之间互相转换的概率最可能是怎么样的… 这个问题有、复杂，也就是我们要看通过观测的序列来完善我们的模型。]]></content>
      <categories>
        <category>隐马尔可夫模型</category>
      </categories>
      <tags>
        <tag>隐马尔可夫模型</tag>
        <tag>自然语言处理</tag>
        <tag>HMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LSTM-CRF模型]]></title>
    <url>%2Fblog%2F2018%2F11%2F24%2Flstm-crf%2F</url>
    <content type="text"><![CDATA[介绍LSTM-CRF是一个用于命名实体识别的内嵌CRF的LSTM模型。 好处呢循环神经网络解决了传统神经网络只依赖于当前输入的问题。长短时记忆网络模型解决了循环神经网络由于梯度爆炸或消失只能学习到短周期的依赖关系问题。 记忆单元LSTM模型通过引入一组记忆单元使得神经网络具有学习遗忘历史信息的能力。 在时刻$t$，记忆单元$c_t$记录了当前时刻为止的所有历史信息，并受三个门的控制： 输入门$i_t$ 遗忘门$c_t$ 输出门$o_t$ 有下列一组计算公式，是peeholes convolutional LSTM的式子 $$\begin{split}i_t&amp;=\sigma(W_ix_t+U_ih_{t-1}+V_ic_{t-1}), \\f_t&amp;=\sigma(W_ix_t+U_fh_{t-1}+V_fc_{t-1}), \\o_t&amp;=\sigma(W_ox_t+U_oh_{t-1}+V_oc_{t}), \\\widetilde{c}_t&amp;=\tanh(W_cx_t+U_ch_{t-1}+b_c), \\c_t&amp;=f_t\odot{c}_{t-1}+i_t\odot\widetilde{c}_t, \\h_t&amp;=o_t\odot\tanh(c_t)\end{split}$$ 其中，$x_t$是当前时刻的输入，$\sigma$是$\mathrm{logistic}$函数，也就是$\mathrm{sigmoid}$(如下)，$V_i$,$V_f$,$V_o$是对角矩阵。 $$\sigma(x)=\frac{1}{1+e^{-x}}$$ $c_t$指cell在t时刻的状态，$\widetilde{c}_t$是对输入和上一时刻的状态进行处理后的值。 那么$W$和$U$又是什么呢？ $W$是对于输入值$x$的权重，$U$则是对于从输出返回来的输入$h$的权重。 我们先看一组简单一点的LSTM式子： $$\begin{split}i_t&amp;=\sigma(W_ix_t+U_ih_{t-1}+b_i), \\f_t&amp;=\sigma(W_ix_t+U_fh_{t-1}+b_f), \\o_t&amp;=\sigma(W_ox_t+U_oh_{t-1}+b_o), \\\widetilde{c}_t&amp;=\tanh(W_cx_t+U_ch_{t-1}+b_c), \\c_t&amp;=f_t\odot{c}_{t-1}+i_t\odot\widetilde{c}_t, \\h_t&amp;=o_t\odot\tanh(c_t)\end{split}$$ 我们可以看到输入门，遗忘门和输出门的值，都是由当前输入乘上输入权重，上一轮的输出乘上对应的权重，和一个偏置项的和，套上一层$\mathrm{sigmoid}$组成的。而计算Cell状态$c$时，引入的$\widetilde{c}_t$也有类似的权重加偏置项，然后使用$\tanh$激活。$c$的计算是对上一回$c$的状态和遗忘门使用madamard积，也就是将对应的位置乘起来，而我们的遗忘门经过了sigmoid之后是$(0,1)$之间的值，这么一乘就可以以一定的比例“遗忘”上一回的状态。除了遗忘之外，我们还需要将新的输入也加上，这一个项$i_t\odot\widetilde{c}_t$使用输入门和$\widetilde{c}_t$求madamard积获得。最后是这一层的输出$h$则是用输出门与$c_t$求madamard积。$c_t$可以使用$\tanh$激活，也可以不使用。 初始化时，$h_0$和$c_0$均为0。 我们根据上面的一通分析可以描述一下$\mathrm{LSTM}$的结构: 有一个Cell $c$,初始状态都是0,每一时刻的输入来自输入和自身在前一时刻的状态$c_{t-1}$经过的一些处理。 其中的输入来源有实际输入和上一次的输出。他们分别乘上对应的权重后，与一个偏置项求和，使用$\tanh$激活后再经过一层输入门，就成为了输入。 而自身上一次的状态则需要经过遗忘门。 最终这一个时刻的输出$h_t$则是由Cell状态$c$经过输出门得到的结果，而下一时刻输入门，输出门，遗忘门包括Cell再计算输入时，都会使用到这一个$h_t$。 因此这是一个循环的结构并且(如果训练得当)我们可以看出一次输出可能会受到很久以前的输入的影响，也许我应该看看为什么传统的RNN会产生梯度爆炸/消失而这个不会。 LSTM-CRF模型啊……哦……这里是空的。 我们看完了LSTM但并不知道如何在其中嵌入一个CRF模型]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>自然语言处理</tag>
        <tag>神经网络</tag>
        <tag>LSTM</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名实体识别]]></title>
    <url>%2Fblog%2F2018%2F11%2F24%2Fname-entities-recognition%2F</url>
    <content type="text"><![CDATA[收集一些命名实体识别相关的知识 收集一下名词 条件随机场CRF 召回率 F值 viterbi算法 序列标注任务 最大似然迭代算法 MEMM标记偏置 线性条件随机场 层叠条件随机场 前向后向算法 N-最短路径的切分排歧策略 互信息 二值特征函数 L-BGFS算法 牛顿方法 收集一些工具 CRF++ 收集一些言论文本信息抽取是自然语言处理及文本挖掘领域的一个研究热点。命名实体识别是信息抽取的子任务 主要任务 人名 地名 时间、日期 主要方法 基于规则的方法 基于统计的方法 基于神经网络的方法 语料库 《人民日报》语料库 基于规则的方法构建词规则及句法规则，采用匹配算法自动识别。 基于统计的方法 最大熵模型 隐马尔科夫模型 条件随机场模型 条件随机场模型条件随机场模型(Conditional Random Field,CRF)是一种概率无向图模型。属于判别模型。 摘抄一个 线性链条件随机场模型 在序列标注任务中，随机变量$X=X_1,\dots,X_{n-1},X_n$是观察序列，随机变量$Y=Y_1,\dots,Y_{n-1},Y_n$表示与观察序列相对应的标记序列。 引入两个函数$t_k$和$s_k$ $t_k(y_{i-1},y_i,x,i)$是从位置$i$到位置$i-1$的转移特征函数，$s_k(y_i,x,i)$是位置$i$的状态特征函数，$\lambda_k$、$\mu_k$是相应的权重。 下面一个是随机变量$Y$的链接条件概率分布： $$P(Y\vert{X})=\frac{1}{Z(x)}\exp\left(\sum\limits_i\sum\limits_k\lambda_kt_k(y_{i-1},y_i,x,i)+\sum\limits_i\sum\limits_k\mu_ks_k(y_i,x,i)\right)$$ 其中 $$Z(x)=\sum\limits_y\exp\left(\sum\limits_i\sum\limits_k\lambda_kt_k(y_{i-1},y_i,x,i)+\sum\limits_i\sum\limits_k\mu_ks_k(y_i,x,i)\right)$$ $\lambda_k$和$s_k$需要从训练样本中学习得出。 $Z(x)$是一个仅依赖于观测序列$X$的归一化函数。 在序列标注的过程中，条件随机场模型使用$\mathrm{Viterbi}$方法寻找使$P(Y\vert{X})$最大的$Y^*$,即$Y^*=\max_YP(Y\vert{X})$ 这两个东西看起来有一、复杂 依存句法分析依存句法分析（Dependency Parsing）是一种语言结构，它通过分析语言单位内成分之间的依存关系揭示其语法结构，描述句中词和词之间存在的支配与被支配的依存关系，鉴于依存分析可以找出句子各成分之间的语义修饰关系，因此，可以得到长距离的搭配信息，而且依存分析和句子成分的物理位置无关，更倾向于人的语言直觉，能够提供更精确的结果，因此，依存分析技术得到人们的广泛关注。 P,R,F的关系准确率$P$,就是$\frac{其中预测正确的数量}{预测是某个类型的实体的数量}$召回率$R$,就是$\frac{预测到的正确的数量}{所有的正确的数量}$$F$值,计算方式:$\frac{2\times{P}\times{R}}{P+R}$ 新词的发现方式主要有两类方法： 在大规模训练语料的基础上，使用统计方法确定新的单词边界，从而获得候选的单词 在缺乏大规模训练语料，对实验数据文本中的字符串进行频率统计，词频高于阈值的词语作为候选新词 条件随机场中的层叠模型和层次模型 层叠模型(CCRFs)是将多个模型进行线性组合 层次模型采用递归方式将低层模型嵌入高层模型 层次模型训练复杂度和解码复杂度远远高于层叠模型。 参考文献： [1]杨晓燕,徐戈,谢安,庄泽彬.基于词典与条件随机场的中文菜名识别研究[J].电脑知识与技术,2018,17:91-93.[2]周俊生,戴新宇,尹存燕,陈家骏.基于层叠条件随机场模型的中文机构名自动识别[J].电子学报,2006,5:804-809]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>自然语言处理</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[余弦相似度计算]]></title>
    <url>%2Fblog%2F2018%2F11%2F23%2Fconsine-similarity%2F</url>
    <content type="text"><![CDATA[先来一段废话为了计算文本的相似度，我们需要一些算法，比如这个余弦相似度算法。 具体怎么算呢？ 简单一点就是如下: 分词 将所有的词放在一个集合中 根据集合位置给词编码 将两个语句化为向量，维度为所有词的数量，每个维度的数值为这个词在此句子中出现的次数 计算两个向量的余弦值，越大代表越接近 具体操作分词我们可以用jieba分词，因为它分得一定比我好 把所有的词放在集合中遍历一下即可 根据集合位置给词编码变为一个dict并且对应的位置置为数量 转向量先将分词结果替换为数字数组，数字为dict中的值。统计不同位置出现的次数，存在向量中。 计算余弦值使用如下式子计算： $$\cos(\theta)=\frac{\sum\limits_{i=1}^n(x_i\times{y_i})}{\sqrt{\sum\limits_{i=1}^n(x_i)^2}\times\sqrt{\sum\limits_{i=1}^n(y_i)^2}}$$ 其实就是点积和长度的乘积的比值。 具体影响： 如果两个句子相同的词越多，点积就会越大，相似度也会越高。如果两个句子在相同的词不变的情况下，句子长度越长，相似度则会越低。 如果动脑子想一想，确实还是有道理的，但是似乎有点太简单了一些。 举个栗子首先我们拿到两句话： 这里有一根比较长的棍子这里有一根比较短的棍子 使用jiaba分词的结果： 12[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;长&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;][&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;短&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;] (所以标点符号也算进去了) 然后我们变成这样的集合： 1[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;长&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;, &apos;短&apos;] 然后标个号: 1234567891011&#123; &apos;这里&apos;: 0, &apos;有&apos;: 1, &apos;一根&apos;: 2, &apos;比较&apos;: 3, &apos;长&apos;: 4, &apos;的&apos;: 5, &apos;棍子&apos;: 6, &apos;。&apos;: 7, &apos;短&apos; 8&#125; 然后我们变成两个向量： [1, 1, 1, 1, 1, 1, 1, 1, 0],[1, 1, 1, 1, 0, 1, 1, 1, 1], 最后求得余弦值为$0.875$ 此时我们再掏出一个句子： 这里有一根棍子，它有点长 分个词： 1[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;棍子&apos;, &apos;，&apos;, &apos;它&apos;, &apos;有点&apos;, &apos;长&apos;, &apos;。&apos;] 我们用第一个句子和第二个句子来计算相似度，那么我们得到的集合是: 1[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;长&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;, &apos;，&apos;, &apos;它&apos;, &apos;有点&apos;] 向量: 12[1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0][1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1] 余弦值约等于$0.707$ 结果也就是说，比较和第二，第三句的相似度，第一句和第二句的相似度是比较高的。 虽然它们结构上确实是……比较接近的 但是意思显然…不太对 一个可能有效的改进假设我们有一个反义词集，里面有记录 长/短 是一对反义词，那么我们似乎可以记录一个负值： 比如在计算前两句的相似度时，我们认为长和短在同一个维度，但方向相反，我们如下的位置集合： 1234567891011&#123; &apos;这里&apos;: [0, 1], &apos;有&apos;: [1, 1], &apos;一根&apos;: [2, 1], &apos;比较&apos;: [3, 1], &apos;长&apos;: [4, 1], &apos;的&apos;: [5, 1], &apos;棍子&apos;: [6, 1], &apos;。&apos;: [7, 1], &apos;短&apos; [4, -1]&#125; 那么我们在这个情况下，计算的两个向量为： [1, 1, 1, 1, 1, 1, 1, 1][1, 1, 1, -1, 1, 1, 1, 1] 余弦值只有$0.75$了…感觉总归是有一点效果的，对于当前这种，一个位置意思相反的情况。 要是冒出一个双重否定怎么办呢…也许我们需要加入一些结构分析 感觉会有人用了一些考虑了不同的词的相关性的算法…而不是这样简单粗暴地分成多个维度 或者只是加一个反向 不过暂时应该是够用了 代码实现没有实现]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>文本分析</tag>
        <tag>相似度计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常微分方程及解法]]></title>
    <url>%2Fblog%2F2018%2F11%2F15%2Fordinary-differential-equation%2F</url>
    <content type="text"><![CDATA[微分方程先整理一些在下面会出现的概念或者定义… 微分方程指一个表示未知函数、未知函数的导数以及自变量之间的关系的方程. 微分方程的阶指微分方程中出现的最高阶导数或偏导数的阶. 常微分方程指自变量个数只有一个的微分方程. 偏微分方程指自变量个数大于一个的微分方程. 举个栗子: $\frac{\partial^2{u}}{\partial{x^2}}+\frac{\partial^2{u}}{\partial{y^2}}+\frac{\partial^2{u}}{\partial{z^2}}=0$是一个二阶偏微分方程， 形如$$F(x,y,y’,…,y^{(n)})=0$$的等式称作一个以$x$为自变量,以$y(x)$为未知函数的n阶常微分方程 下面关注的是一些关于常微分方程和它的解法的内容,以及一些常见的问题.偏微分方程不会涉及. 解和通解微分方程有解和通解两个概念, 如果一个函数如$y=x^2+3$带入方程$\frac{\mathtt{d}y}{\mathtt{d}x}=2x$,可以使得方程恒成立，此时称$y=x^2+3$是该方程的一个解. 如果一个$n$阶微分方程有解$y=\varphi(x, C_1, C_2, …, C_n)$, 并且其中$C_1, C_2, … C_n$是相互独立的任意常数，我们称$y=\varphi(x,C_1,C_2,…,C_n)$为该方程的通解. 如果一个方程的通解需要使用隐函数来表示，那么我们称这个通解为方程的隐式通解或者通积分 然后我们看一下一阶微分方程的初等解法，出于方便下面描述中的微分方程均指常微分方程. 一阶微分方程的初等解法并不是所有的一阶方程都可以求得由初等函数表示的解,如 $$y’=x^2+y^2$$ 这个方程就不行，至于为什么不行，这个在1838年被刘维尔证明了. 在实际应用中有很多的微分方程都没有可以用初等函数表示的解，但我们还是要讨论一些能解的情况的解放，比如对于一些一阶微分方程我们可以用分离变量的方式来求解，对于一些不可以直接分离变量的方程，我们也可以把它化为可以分离变量的方式再求解……所以分离变量是一个比较有用的方法. 变量分离方程变量分离方程就是形如 $$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x)g(y)$$ 的微分方程，其中$f, g$都是连续函数. 对于这种形式的方程我们可以把与$x$和$y$有关的部分分别放到等号的两边，然后两边同时进行积分操作，就可以得到它的解. 具体如下: $$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x)g(y)$$交换一下x,y的位置$$\frac{\mathtt{d}y}{g(y)}=f(x)\mathtt{d}x$$两边积分$$\int{\frac{\mathtt{d}y}{g(y)}}=\int{f(x)\mathtt{d}x}+C$$ 我们得到的式子即为原方程的隐式通解或者通积分，如果我们能求出该式子确定的函数$y=\phi(x,C)$,那么$y=\phi(x,C)$是原方程的通解. 注意的是我们在第二行移项的时候将$g(y)$挪到了分母位置，如果有一个$y=y_0$使得$g(y_0)=0$,我们会发现它同样是方程的一个解,但不在上述的通解当中，我们应该将它补上. 也就是如果我们在运算过程中发现了一些使得某些函数定义域或者值域发生改变的情况，我们需要把这个被去除掉的部分补上. 可以化为变量分离方程的情况有一些情况虽然不是可以变量分离的形式，但经过一些简单的变换可以化为上述的$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x)g(y)$的形式, 比如下面的几个: 1. 形如$\frac{\mathtt{d}y}{\mathtt{d}x}=f(ax+by+c)$的微分方程这时候我们设$u=ax+by+c$,则有 $$\mathtt{d}u=a\mathtt{d}x+b\mathtt{d}y$$ 我们需要将$\mathtt{d}y$和$\mathtt{d}x$放在一起变为$\frac{\mathtt{d}y}{\mathtt{d}x}$的形式，然后把方程左边的$\frac{\mathtt{d}y}{\mathtt{d}x}$替换掉，从而使方程变为$u$和$x$的变量分离方程,因此有: $$\frac{\mathtt{d}u}{\mathtt{d}x}=a+b\frac{\mathtt{d}y}{\mathtt{d}x}$$ 即 $$\frac{\mathtt{d}u}{\mathtt{d}x}=a+bf(u)$$ 此时式子是一个变量分离方程，那么我们可以根据变量分离方程的方法试着求得通解，然后再将$u$替换为$ax+by+c$即可。比如我们求得通解$u=\varphi(x,C)$,则原方程的通解为$ax+by+c=\varphi(x,C)$ 2. 形如$\frac{\mathtt{d}y}{\mathtt{d}x}=f(\frac{y}{x})$的微分方程此时替换的是$\frac{y}{x}$,也就是令$u=\frac{y}{x}$,有: $$x\mathtt{d}u+u\mathtt{d}x=dy$$ 还是同样的套路，我们把上式化成: $$\frac{\mathtt{d}y}{\mathtt{d}x}=x\frac{\mathtt{d}u}{\mathtt{d}x}+u$$ 有 $$x\frac{\mathtt{d}u}{\mathtt{d}x}+u=f(u)$$ 我们也可以看出这个方程可以化为变量分离方程，如果我们可以得到通解$u=\varphi(x,C)$,那么原式通解为$\frac{y}{x}=\varphi(x,C)$ 3. 形如$\frac{\mathtt{d}y}{\mathtt{d}x}=f\left(\frac{a_1x+b_1x+c}{a_2x+b_2y+c}\right)$的微分方程一阶线性微分方程一阶线性微分方程指形如 $$\frac{\mathtt{d}y}{\mathtt{d}x}+P(x)y=Q(x)$$ 的方程 一阶齐次线性微分方程当$Q(x)\equiv0$时，成为一阶齐次线性方程. 一阶非齐次线性微分方程当然是$Q(x)\not\equiv0$时了 全微分方程与积分因子全微分方程我们可以将一阶微分方程$y’=f(x,y)$写成如下的形式 $$P(x,y)\mathtt{d}x+Q(x,y)\mathtt{d}y=0$$ 此时如果存在可微函数$\lambda(x,y)$使得$d\lambda(x,y)=P(x,y)\mathtt{d}x+Q(x,y)\mathtt{d}y$,则$P(x,y)\mathtt{d}x+Q(x,y)\mathtt{d}y=0$称为恰当微分,该方程称为全微分方程或恰当方程 积分因子有的方程虽然不是全微分方程，但在等式左右两边乘上一个连续可微函数$\mu(x,y)$,可以化为全微分方程,此时我们称这个$\mu(x,y)$为这个方程的积分因子. 解的存在唯一性定理我并没有看懂这一整个皮卡存在唯一性定理的证明 利普希兹(Lipschitz)条件我正在试图找一个函数绘图软件画一下… 利普希兹条件是指: 如果存在一个常数$L$，使得一个函数$f(x,y)$在区域$D$内,$\mid f(x,y_1)-f(x,y_2)\mid\le L\mid(y_1-y_2)\mid$对所有的$(x,y_1),(x,y_2)\in{D}$都成立. 我们称$L$是利普希兹常数，称$f(x,y)$在区域$D$上关于$y$满足利普希兹条件. 皮卡存在唯一性定理如果$f(x,y)$在闭区域$D$：$\mid x-x_0\mid\le{a},\mid y-y_0\mid\le{b}$上连续且关于$y$满足利普希兹条件，则方程$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x,y)$存在唯一的解$y=\phi(x)$,它在区间$\mid x-x_0\mid\le{h}$上连续，且满足初始条件$\phi(x_0)=y_0$,这里$h=\min(a,\frac{b}{M}),M=\max\limits_{(x,y)\in{D}}\mid f(x,y)\mid$. 上面的定理描述是针对一阶微分方程的,那么高阶的时候是否成立或者如何描述呢？ 证明起来步骤似乎很长，首先证明有解等价于一个式子，然后构造一个函数序列，证明对于每个n，函数都存在，然后证明函数序列一致收敛，求极限后等于我们要求的式子，最后再证明解的唯一性… 定理的证明我们分五个引理来证明这个定理。方便起见区间$\mid x-x_0\mid\le{h}$取$x_0\le{x}\le{x_0+h}$部分来证明. 引理1$y=\phi(x)$是方程$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x,y)$定义在区间$x_0\le{x}\le{x_0+h}$上,且满足初始条件$\phi(x_0)=y_0$的解，当且仅当$y=\phi(x)$在$x_0\le{x}\le{x_0+h}$上连续且满足 $$\phi(x)=y_0+\int_{x_0}^xf(x,y)\mathtt{d}x,(x_0\le{x}\le{x_0+h})$$ (看起来是这样，既满足初始条件，求个导也是$f(x,y)$) 证明: 由于$y=\phi(x)$是方程的解，有: $$\frac{\mathtt{d}\phi(x)}{\mathtt{d}x}=f(x,\phi(x))$$ (直接写y不好吗)那么我们对两边从$x_0$到$x$求定积分就可以得到: $$\phi(x)-\phi(x_0)=\int_{x_0}^xf(x,\phi(x))\mathtt{d}x,(x_0\le{x}\le{x_0+h})$$ 整理一下就是上面写的式子了. 反过来我们对$\phi(x)=y_0+\int_{x_0}^xf(x,y)\mathtt{d}x,(x_0\le{x}\le{x_0+h})$两边求导,可得 $$\frac{\mathtt{d}\phi(x)}{\mathtt{d}x}=f(x,\phi(x))$$ (所以$y$和$\phi$混着写令人非常难受)证明了这个引理就是告诉我们在这个区间上，有解和这个条件是等价的，那我们后面需要证这个条件就可以得出有解. 引理2我们首先构造一个皮卡逐步逼近函数序列: $$\begin{cases}\phi_0(x)=y_0 \\\phi_n(x)=y_0+\int_{x_0}^xf(t,\phi_{n-1}(t))\mathtt{d}t,(x_0\le{x}\le{x_0+h})\end{cases}$$ 引理2的内容是： 对于所有的$n$，式中的函数$\phi_n(x)$在区间$x_0\le{x}\le{x_0+h}$都有定义且满足: $$\mid{\phi_n(x)-y_0}\mid\le{b}$$ 证明： 我们用数学归纳法可以证明。当$n=1$时，$\phi_1(x)=y_0+\int_{x_0}^xf(t,y_0)\mathtt{d}t$，易见这个函数在$x_0\le{x}\le{x_0+h}$上有定义，连续且有: $$\begin{split}\mid\phi_1(x)-y_0\mid&amp;=\left\vert\int_{x_0}^xf(t,y_0)\mathtt{d}t\right\vert \\&amp;\le\int_{x_0}^x\vert{f(t,y_0)}\vert\mathtt{d}t \\&amp;\le{M(x-x_0)}\le{Mh}\le{b}\end{split}$$ 引理3引理4引理5高阶微分方程这一部分主要是二阶齐次和非齐次微分方程，有时候虽然不好解，但我们的问题可能只是需要一个解，或者由一些条件来计算通解.因此这里是一些性质和定理，可以直接使用. 应用举例emmm,似乎没有那么必要]]></content>
      <categories>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
        <tag>常微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿和素材]]></title>
    <url>%2Fblog%2F2018%2F11%2F06%2Fdraft%2F</url>
    <content type="text"><![CDATA[curl的笔记1curl -X POST http://balabala.com/balabala -d &#123;\"param1\":\"value\"&#125; -X可以指定请求方式，比如POST或者GET. -d可以指定参数，但是似乎默认的参数格式是&quot;a=sss&amp;b=c&quot;这种格式 似乎需要额外的参数指定json格式呢 找到了 1curl -H "Content-Type:application/json" -X POST http://balabala.com/balabala -d &#123;\"param1\":\"value\"&#125; DevOps Development and Operations 特点？好处都有啥？缺点？采用的技术？VSCode很好，vscode很好vscode很奇怪 不是很好 材料 md编辑时打开preview关闭很迷 terminal放到右边时如何回到下方 零样本学习pycryptodome什么是pycryptodome呢 源码为什么不看一看源码呢 iptables1iptables -t nat -nL iptables好像很有趣 gitbook?#的作用比如#test可以访问这里 docker的网络模型导出word的方案telnet使用Spring boot中使用redis做缓存一篇文章： https://www.cnblogs.com/gdpuzxs/p/7222309.html另一篇： https://www.cnblogs.com/badboyf/p/6995202.html?utm_source=itdadao&amp;utm_medium=referral 中文文案排版指南https://github.com/mzlogin/chinese-copywriting-guidelines#%E8%B0%81%E5%9C%A8%E8%BF%99%E6%A0%B7%E5%81%9A Go方法以及简单的Hello World1234567package mainimport "fmt"func main() &#123; fmt.Println("Hello, World!")&#125; 用scratch来制作一个go应用镜像摘自菜鸟教程。 package main代表是一个可独立执行的程序。 fmt是一个IO库。 Println竟然是大写 {的位置1234func main()&#123; fmt.Println("Hello, Wolrd")&#125; 这样写会报错。。。。真的有这个必要吗 for循环12345var list = []int32&#123;1, 2, 3&#125;for i := 0; i &lt; len(list); i++ &#123; fmt.Println(i)&#125; 变量命名使用单驼峰命名方式，不是下划线或者双驼峰 调试1go run filename.go 新问题在docker里面启动的东西能不能把命令行的日志放到日志文件里啊 试一下吧 docker启动一个redis12docker pull redisdocker run -d --name myredis -p 16379:6379 redis --requirepass "mypassword" Arduino注释可以使用 舵机使用Servo控制舵机 Serial1Serial.begin(); （Arduino高亮是不是有bug） css3动画真好玩 vue中操作cookieaxios默认不允许请求携带cookie 需要使用 1axios.defaults.withCredetials = true; 接收不到cookie不要使用mock即可 RedisRedis在互联网公司一般有以下应用: String：缓存、限流、计数器、分布式锁、分布式Session Hash：存储用户信息、用户主页访问量、组合查询 List：微博关注人时间轴列表、简单队列 Set：赞、踩、标签、好友关系 Zset：排行榜 Ant DesignKite安装先翻个墙： 123go get -u github.com/gpmgo/gopmgopm get -g -v github.com/koding/kite 创建Project如果使用goland,不要把目录放在GOROOT下面 哈夫曼编码glsl点乘是dot 叉乘是cross 圈乘$\otimes$是把对应位置乘起来，可以用matrixCompMult 叉乘假设有向量$\mathrm{A}=(x_1,y_1,z_1),\mathrm{B}=(x_2,y_2,z_2)$,那么 $$\mathrm{A}\times\mathrm{B}=(y_1\times{z_2}-y_2\times{z_1},z_1\times{x_2}-z_2\times{x_1},x_1\times{y_2}-x_2\times{y_1})$$ 酷Q docker测试一下 123docker pull coolq/wine-coolqmkdir /root/coolq-datadocker run --name=coolq -d -p 8080:9000 -v /root/coolq-data:/home/user/coolq -e VNC_PASSWD=12345678 -e COOLQ_ACCOUNT=123456 coolq/wine-coolq 访问对应的端口输入密码即可操作 进入/root/cooq-data/conf,编辑CQP.cfg,添加 12[Debug]DeveloperMode=1 把开发好的应用拉下来试试（ 接下来开始开发请求模式的机器人 先启动一个docker版flask或者django试试？ 使用HardSourcePlugin加快webpack速度1npm install --save hard-source-webpack-plugin groovier的做法整理OneToOne、OneToMany、ManyToOne的关系OneToOne假设有两个类A和B，它们互相只能持有一个对方的对象，我们想把这个关系存在A对应的表中。 也就是在数据库中A持有B的id字段，B则不持有A的字段。 而在类中它们则是相互持有的关系，此时应该如何处理呢？ 如果我们在A类中写一个B类的属性并使用OneToOne注解，效果是在数据库中 A里面持有了一个B_id，而B没有。 如果两边都写一个OneToOne，则是A中存一个B_id，B中存一个A_id。 都不符合要求。 我们试试JoinColumn，但并不能达到效果。 比如在A中的B属性使用OneToOne，B中的A属性使用OneToOne，并且加上JoinColumn(name=’B_id’) 我们会发现并没有什么效果，只是B里面原来应该是A_id的字段变成了B_id 达到要求的操作应该是对B使用： OneToOne(mappedBy = “A中持有的B的属性名称”) 对A使用： OneToOneJoinColumn(unique=true) 这时达到的效果是： B表中没有相关的A的信息，而A表中有B的信息。 具体一点则是： 1234567891011121314151617181920@Entityclass A &#123; @Id int id @OneToOne @JoinColumn(unique = true) B b&#125;@Entityclass B &#123; @Id int id @OneToOne(mappedBy = "b") A a&#125; 而在数据库中的字段： A: 1id, b_id B: 1id 级联更新和级联删除我现在有一个需求： 不要那么多save，直接save一个 其他相关的也会save 我们来看看JPA中级联的几个方式 级联里面有Persist和Remove 其实还有好几个 PERSiST REFRESH DETACH MERGE ALL 看看CascadeType源码吧 里面并没有写特别多东西 算了 此外发现Java和Groovy中的一些不同 在Java的注解中 一个列表用的是{} 而在Groovy中使用的是[] 如： 1@OneToOne(cascade = &#123;CascadeType.PERSIST, CascadeType.REFRESH&#125;) 1@OneToOne(cascade = [CascadeType.PERSIST, CascadeType.REFRESH]) 几个同名类的不同java.persistence.Id和org.springframework.data.annotation.Id有什么区别？ 点进去看看⑧ java.persistence.Id说这个就是用来指定实体的主键的。 在Java类中它可以修饰的类型如下： 基本类型 基本类型的封装类型 String java.util.Date java.sql.Date java.math.BigDecimal java.math.BigInteger 但是有一件很神奇的事情是，它还可以修饰方法…emm 也就是只要返回值是这些类就可以？找个时间做个实验吧 而org.springframework.data.annotation.Id的解释少了一些 只说是用来修饰identifier的。 Target多了一个value是ANNOTATION_TYPE 这个是用来干什么的呢 写一个注解的例子1234@Target(&#123;METHOD, FIELD&#125;)@Retention(RUNTIME)public @interface Id &#123;&#125; 其中Target里面有一个ElementType的数组，可以是： TYPE(我猜是类型) ANNOTATION_TYPE(注解类型) FIELD(Field就是类的属性啦) METHOD(方法) PARAMETER(参数) CONSTRUCTOR(构造器) LOCAL_VARIABLE(局部变量) PACKAGE TYPE_PARAMETER TYPE_USE(1.8起 也没搞懂) MODULE(java9开始，应该是用在package-info里面) 什么是jls呢 而Retention呢？大概是指这个注解的生存期 RetentionPolicy里面定义的几个enum是 SOURCE(源码中存在，编译后去除) CLASS(记录在class文件中，但在运行时没有，这个是默认选项) RUNTIME(运行时也存在，可以通过反射获得) 去源码里面找一些骚操作集合框架啊ik分词器是什么呢elasticsearch的使用用完感觉也就一般 WordEmbedding是一个比OneHot更高效的用向量表示单词的方式。 可以指定向量的长度 并由神经网络生成。 向量之间有相似度关系，而不是在OneHot中的只是表示一个编号。 （使用余弦相似度计算） 生成方式是使用下列方式的一种: CBOW(Continuous Bag of Words) n-gram(skip-gram) Glove Word2Vec中包含了CBOW和n-gram方法。 Word2Vec使用Hex-Rays DecompilerIDA ProPOSIXKCachegrindzcovapktool我们使用apktool来修改篮球经理2017 apktool下载地址 然后我们需要一个apk文件，想办法搞一个就ok了。 把它们放在同一个目录下，打开命令行，运行 (需要Java7环境) 1java -jar apktool.jar d xxx.apk 我们可以看到结果会多出一个xxx文件夹。 如果需要重新编译 则使用： 1java -jar apktool.jar b xxx 就会在xxx/dist文件夹下看到重新编译的xxx.apk。 我们需要对它进行签名才能使用，此时我们可以在java的目录下面找到一个keytool.exe,用他生成一个keystore文件 1keytool -genkey -alias abc.keystore -keyalg RSA -validity 20000 -keystore abc.keystore 具体信息自己填就可以了。 最后我们要对apk进行签名，这次用到的是jarsigner.exe，也在java目录下。 1jarsigner -verbose -keystore abc.keystore -signedjar signed.apk xxx/dist/xxx.apk abc.keystore 接下来就是愉快的修改环节了，开始写smali代码…… 测试可以使用各种安卓模拟器。 tidbit: VSCode有smali插件 smali语法方法12.method public static test()V.end method (smali高亮一般啊) 使用.method和.end method来标识一个方法的开始和结束。 public static test()和Java中差不多，但是方法的返回值放在了方法参数括号的后面，并且： V表示void I表示int Z表示boolean B表示byte D表示double C表示char J表示long F表示float S表示short 其他类使用L, 如：Ljava/lang/String(需要使用全限定名) 如果是数组，在前面加[ 构造方法举例如下： 123456789101112.method public constructor &lt;init&gt;()V .locals 0 # 表示局部变量数 .prologue # 逻辑开始 .line 12 # 标识在源码中的代码行(应该是debug信息输出用的) # 调用静态方法，&#123;p0&#125;是指包含p0的参数列表，p0在构造函数中指向自身 # ,后是需要调用的方法，格式是类-&gt;方法 invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V return-void.end method 在构造方法中，&lt;init&gt;代表构造方法，而下面这个是静态方法块： 12.method static constructor &lt;clinit&gt;()V.end method 此外方法中一定要指定locals的数量。 属性获取1234.locals 1.prologueiget-object v0, p0, Lcom/xxx/Test;-&gt;id:Ljava/lang/String; new-instance用于创建一个新变量 1new-instance v0, L invoke-virtual调用对象的方法 1invoke virtual &#123;p1, v0&#125; xxxxx.ClassName-&gt;mathodName(ParamType)ReturnValue; 第一个参数是调用此方法的对象，第二个开始是参数。 .source.source表示源java文件，但这并不是一个必要的选项，我们可以去掉这一栏。 android.os.AsyncTask去除广告从程序入口找广告加载时间？svg viewbox大概是在svg上再抽象出一层，让一个固定大小的svg上总是能显示出图像。 TwineTwine 是一个轻量的数据结构，用于高效率地表达字符串的连接。 Twine 是一种 rope(串接)，它使用二叉树表示一个连接的字符串，结果字符串是二叉树节点由前序遍历拼接而成。只有当需要字符串拼接结果的时候，才进行这种拼接到一个最终的 buffer 中，因此可以避免在多个字符串拼接中产生临时的 string 对象，及避免不必要的高消耗的内存分配操作。 没搞定的问题 N^2的3-sum 双调序列查找数字问题 线性时间计算inversion数量 shuffle链表 寻找两个已排序数组的第k大元素，在logn时间内完成 3-way-partition很棒]]></content>
      <categories>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>草稿</tag>
        <tag>素材</tag>
        <tag>乱贴标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git分支操作笔记]]></title>
    <url>%2Fblog%2F2018%2F11%2F05%2Fgit-branch%2F</url>
    <content type="text"><![CDATA[创建本地分支1git checkout -b issn 相当于 12git branch issngit checkout issn 提交更改到分支12git add .git commit -m "message" 回到主分支1git checkout master 合并分支1git merge issn]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$\mathtt{B\acute{e}zier}$曲线]]></title>
    <url>%2Fblog%2F2018%2F10%2F26%2Fbezier-curve%2F</url>
    <content type="text"><![CDATA[$\mathtt{B\acute{e}zier}$曲线的定义$$P(t)=\sum_{i=0}^nB_{i,n}(t)P_i,0\le{t}\le{1}$$ 其中， $$B_{i,n}(t)=C_n^it^i(1-t)^{n-i}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i},i=0,1,\dots,n$$ 当$n=1$时,式子成为 $$\begin{split}P(t)&amp;=B_{0,1}(t)P_0+B_{1,1}(t)P_1,0\le{t}\le{1} \\&amp;=(1-t)P_0+tP_1 \\&amp;=\begin{pmatrix}t &amp; 1 \\\end{pmatrix}\begin{pmatrix}-1 &amp; 1 \\1 &amp; 0 \\\end{pmatrix}\begin{pmatrix}P_0 \\P_1 \\\end{pmatrix}\end{split}$$ 这个式子意味着这是一条从$P_0$连到$P_1$的直线段. 当$n=2$时,式子成为 $$\begin{split}P(t)&amp;=(1-t)^2P_0+2t(1-t)P_1+t^2P_2 \\&amp;=\begin{pmatrix}t^2 &amp; t &amp; 1 \\\end{pmatrix}\begin{pmatrix}1 &amp; -2 &amp; 1 \\-2 &amp; 2 &amp; 0 \\1 &amp; 0 &amp; 0 \\\end{pmatrix}\begin{pmatrix}P_0 \\P_1 \\P_2 \\\end{pmatrix}\end{split}$$ 这次是一个抛物线. 当$n=3$时，式子成为 $$\begin{split}P(t)&amp;=(1-t)^3P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3 \\&amp;=\begin{pmatrix}t^3 &amp; t^2 &amp; t &amp; 1 \\\end{pmatrix}\begin{pmatrix}-1 &amp; 3 &amp; -3 &amp; 1 \\3 &amp; -6 &amp; 3 &amp; 0 \\-3 &amp; 3 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 0 \\\end{pmatrix}\begin{pmatrix}P_0 \\P_1 \\P_2 \\P_3 \\\end{pmatrix}\end{split}$$ 曲线的性质]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker搭建jenkins]]></title>
    <url>%2Fblog%2F2018%2F10%2F25%2Fjenkins%2F</url>
    <content type="text"><![CDATA[记录一下在CentOS7中使用docker运行一个jenkins… 环境使用CentOS7 前置条件 需要有tomcat 123docker pull jenkinsmkdir /home/jenkinsdocker run -d --name myjenkins -p 15000:50000 -p 18080:8080 -v /home/jenkins:/home/jenkins jenkins -v和使用copy的效果是如何不同的此处占坑 然后需要找密码了，访问服务器的10080端口可以看到jenkins的登陆界面。该界面会告诉我们密码放在/var/jenkins_home/secrets/initialAdminPassword里面，但我们的jenkins是在docker容器中启动的，所以我们需要到容器内对应的路径去找。 12docker exec -it myjenkins /bin/bash # 进入容器cat /var/jenkins_home/secrets/initialAdminPassword 拿到密码a704538e730d4acda43343383718377c 退出容器 1logout 登陆进去选插件，发现有一堆安装失败了pipeline 后续操作并没有学会…… 自己写一个吧]]></content>
      <categories>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Spring Cloud]]></title>
    <url>%2Fblog%2F2018%2F10%2F24%2Fspringngcloud%2F</url>
    <content type="text"><![CDATA[Eureka结构有服务注册中心、服务生产者和服务消费者 流程 服务生产者启动时，向服务注册中心注册服务 服务消费者(启动时？)向服务注册中心订阅服务 服务注册中心向服务消费者返回服务生产者的地址 服务消费者调用所需服务 用途 这是一段话所以注册的服务只是告诉注册中心自己的地址，让注册中心转告给消费者？ 启动方式服务注册中心是一个eureka-server建议禁用client功能 服务生产者是一个eureka-client bus Spring Cloud Bus被翻译为消息总线看起来可以在多个服务中互相传递消息 用途 这也是一段用途，但他不能教我数学 结构 服务A启动，连接总线 服务B启动，连接总线 服务C启动，连接总线 服务A发送消息 服务B、C收到消息 举个栗子 ActiveMQ Kafka RabbitMQ RocketMQ 比较吗？需要比较一下吗？ 使用RabiitMQzuul zuul是一个网关 配置中心spring cloud config/ zoo keeperredis断路器/熔断/Hystrixdevops和aiopsdubbo/zookeeper读论文 我们需要读论文学习]]></content>
      <categories>
        <category>编程</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在c++中使用opengl]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2Fopengl%2F</url>
    <content type="text"><![CDATA[Shaders哪里放more,这里放more 如何偷懒，如何不偷懒关键字in和out是一个Shaders文件的输入和输出 vertex和fragment shader有一些不同 123in type in_variable_name;out type out_variable_name; 我们惊奇地发现，这个主题还支持glsl uniform是全局变量，后面的shader可以使用 1uniform type variable_name; Sampler通常在fragment shader中定义，是一个uniform类型的变量，但我不是很懂uniform了 取整和插值texelFetch1texelFetch(Sampler, vec2, lod); textureSizelod是什么意思呢level of detail, 有机会试试 百度百科： 多细节层次 LOG技术根据物体模型的节点在显示环境中所处的位置和重要度 给人一种放大缩小的感觉 12345uniform sampler2D texSlot;void main() &#123; vec2 texSize = textureSize(texSlot, 1);&#125; opengl很强]]></content>
      <categories>
        <category>编程</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>opengl</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习python]]></title>
    <url>%2Fblog%2F2018%2F10%2F16%2Flearning-py3%2F</url>
    <content type="text"><![CDATA[这个很难, python很难 Queue是一个线程安全的类吗 wrapper的一个用处，给函数打日志 12345678910111213141516171819import timefrom functools import wrapsdef log(func): @wraps(func) def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print("func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;".format(func.__name__, (args, kwargs), end_time - start_time, result)) return result return wrapper @logdef bar(): return "hello" if __name__ == '__main__': bar() 运行结果： 1func bar, param ((), &#123;&#125;), time 0.0, return hello function的属性 1__name__ 偏函数 Partial, 柯里化 Currying 补充一下刚才的代码 123456789101112131415161718192021222324252627import timefrom functools import wraps, partialdef logger(func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print("func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;".format(func.__name__, (args, kwargs), end - start, result)) return result return wrapper@loggerdef add(a, b): return a + badd3 = partial(add, 3)if __name__ == '__main__': print(add3.__class__) add3(2) 12&lt;class 'functools.partial'&gt;func add, param ((3, 2), &#123;&#125;), time 0.0, return 5 Uncurrying 1234567891011121314@loggerdef add(a): @logger def add(b): @logger def add(c): return a + b + c return add return addif __name__ == '__main__': print(add(1)(2)(3)) 1234func add, param ((1,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add at 0x0000001567C500D0&gt;func add, param ((2,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add.&lt;locals&gt;.add at 0x00000015678267B8&gt;func add, param ((3,), &#123;&#125;), time 0.0, return 66 如何写一个满足add(2)至无穷个括号的函数？0x0000001567C500D0是内存地址?可以操作内存吗? Generator 123456789a_generator = (item**2 for item in range(200))if __name__ == '__main__': print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) 12345014916 生成质数 1234567891011121314151617181920log_next = logger(next)def prime(): base = 2 while True: is_prime = True for j in range(2, int(math.sqrt(base)) + 1): if base % j == 0: is_prime = False break if is_prime: yield base base += 1if __name__ == '__main__': prime_generator = prime() for i in range(10): log_next(prime_generator) 12345678910func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 2func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 3func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 5func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 7func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 11func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 13func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 17func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 19func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 23func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 29 eval, compile,code ?]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp中的一些细节]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Ftcp%2F</url>
    <content type="text"><![CDATA[RTT(往返时延)RTT的估计和超时 tcp像很多其他的协议一样，超时的时候会重发，但是如何估计往返时间和设定超时时间是一个需要考虑的问题 估计往返时延segment里面有SampleRTT，计算方式是一个segment发出的时间，到ack收到的时间，对于重发的segment则不进行计算 显然这个值会因为网络状况产生一些波动，为了估计一个典型的RTT. TCP维护一个平均值，EstimatedRTT: $$\mathtt{EstimatedRTT}=(1-\alpha)·\mathtt{EstimatedRTT}+\alpha·\mathtt{SampleRTT}$$ 其中常用的$\alpha$值为$0.125$ DevRTTDevRTT是用来衡量SampleRTT波动程度的值，公式如下： $$\mathtt{DevRTT}=(1-\beta)·\mathtt{DevRTT}+\beta·\mid\mathtt{SampleRTT}-\mathtt{EstimatedRTT}\mid$$ EstimatedRTT和DevRTT都是一个EWMA(指数加权移动平均值) 计算重发间隔有了EstimateRTT和DevRTT，超时时间应当如何计算？首先它需要不小于EstimateRTT，但是又不能太大，防止延迟过高。所以设置方式通常是在EstimateRTT上加一个margin，这个margin的值需要根据SampleRTT的波动情况来设置。因此TCP采用的方式是: $$\mathtt{TimeoutInterval}=\mathtt{EstimatedRTT}+4·\mathtt{DevRTT}$$ 推荐使用的初始值则是1秒，当发生超时时，TimeoutInterval会倍增，直到它被重新计算。 可靠的数据传输TCP在IP协议的基础上提供了可靠的数据传输，解决了数据错误，丢包，重复和顺序错乱的问题。 TCP推荐只维护一个重发的计时器，尽管可能有很多还没有收到ACK的包 一个简化的模型123456789101112131415161718192021222324252627282930NextSeqNum=InitialSeqNumberSendBase=InitialSeqNumberloop (forever) &#123; switch(event) event: data received from application above create TCP segment with sequence number NextSeqNum if (timer currently not running) start timer pass segment to IP NextSeqNum=NextSeqNum+length(data) break; event: timer timeout retransmit not-yet-acknowledged segment with smallest sequence number start timer break; event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase = y if (there are currently any not-yet-acknowledged segments) &#123; start timer &#125; &#125; break;&#125; 有了上述的简化模型我们就可以进行一些场景模拟了 场景一 Host A向Host B发了一个包，seq=92, length=8 bytes, Host B向Host A发了一个ack=100,但是丢了 timer时间到了，Host A重发了这个包 Host B发现是收过的，直接给Host A发了ack=100 Host A收到，继续正常工作 场景二 Host A向Host B发了一个包，seq=92,length=8 bytes Host A向Host B发了一个包, seq=100,length=20 bytes Host B收到seq=92的包，发了一个ack=100 Host B收到seq=100的包，发了一个ack=120 两个ack包没能在超时前收到，Host A重发了seq=92的包 Host B收到seq=92的包，发了一个ack=120 Host A开始发seq=120的包，继续正常工作 场景三 Host A向Host B发了上述1.2.中的两个包 Host B发了一个ack=100，丢了 Host B发了一个ack=120 Host A在超时前收到了sck=120 Host A发送seq=120，继续正常工作 添加翻倍机制在上述的简化模型中，加入如下机制： 每当timeout重发时，将TimeoutInterval翻倍，可以在网络拥塞时产生一些效果 在CSMA/CD中你会看到类似的做法。 快速重传在简单的模型上进行修改，已达到如下效果： Host A向Host B连发了5个包 Host B收到了第一个包，并发送了ack=100 第二个包丢了 Host B在收到3,4,5时连发了三个ack=100 Host A的timer还没有超时，但收到三个duplicated ack了 Host A重发seq=100 12345678910111213event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase=y if (there are currently any not yet acknowledged segments) &#123; start timer &#125; &#125; else &#123; increment number of duplicate ACKs received for y if (number of duplicate ACKs received for y==3) &#123; resend segment with sequence number y &#125; &#125; break; 流控制(暂时略过)TCP连接管理这部分关注的是TCP连接的建立和断开 三次握手Step1客户端向服务端发起请求，带有SYN，并且随机选择一个Seq值x，把报文段发到服务端 Step2服务端收到报文段，分配TCP连接的缓冲区，初始化一些变量。服务端发送一个SYN报文给客户端，ack=x+1，seq为随机值y此报文称为SYNACK报文 Step3客户端收到SYNACK，分配缓冲区，初始化一些变量。向服务端发送ack=y+1,seq=x+1 四次挥手Step1客户端向服务端发送FIN报文 Step2服务端向客户端发送ACK报文 Step3服务端向客户端发送FIN报文 Step4客户端向服务端发送ACK报文。服务端收到ACK后将关闭，客户端等待一段时间后关闭 TCP的生命周期客户端]]></content>
      <tags>
        <tag>tcp</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法及应用]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fsort%2F</url>
    <content type="text"><![CDATA[这里是一些常见的排序方法和它们的分析，可能也有应用，也可能有图 工具类我们先拿出一些常用的方法，简化一下用在后面的调用： 123456789function less(a, i, j) &#123; return a[i] &lt; a[j];&#125;function swap(a, i, j) &#123; const temp = a[i]; a[i] = a[j]; a[j] = temp;&#125; 选择排序选择排序的思路是每次从未排序的部分中寻找最小的一个，把它放在已排序部分的末尾。 使用js实现如下： 1234567891011function selectionSort(a) &#123; for(let i = 0; i &lt; a.length - 1; i ++) &#123; let minIndex = i; for(let j = i + 1; j &lt; a.length; j ++) &#123; if(less(a, j, minIndex)) &#123; minIndex = j; &#125; &#125; swap(a, i, minIndex); &#125;&#125; 下一步 重置 自动 开始 let dataset1 = []; function getChart1(change) { const width = 300; const height = 100; d3.select("#main-div1").selectAll("*").remove(); let svg = d3.select("#main-div1").append("svg").attr("width", width).attr("height", height); let c = svg.selectAll("svg") .data(dataset1) .enter() .append("svg") let rec = c.append("rect").attr("stroke-width", 1).attr("stroke", "black").attr("x", (d, i) => i * 50 + 1).attr("y",50).attr("width",40).attr("height",40).attr("fill", d => d.color); let text = c.append("text").attr("x", (d, i) => i * 50 + 13).attr("y",75).attr("fill", "black").text(d => d.value); if (change !== undefined) { rec.transition().duration(800).attr("x", (d, i) => change[i] * 50 + 1) text.transition().duration((d, i) => 800) .attr("x", (d, i) => change[i] * 50 + 13) } } function updateData1(change) { let backup = [].concat(dataset1); console.log(backup); for(let i = 0;i= changeList1.length) { auto1 = false; return; } let next = changeList1[step1]; getChart1(next); updateData1(next); step1 += 1; } reset1(); setInterval(() => { if(auto1) { start1(); } }, 1000); function printData(a) { console.log(a); const t = []; for(let k = 0; k < a.length;k++) { t.push(a[k].content); } console.log(t); } function less(a, i, j) { return a[i] < a[j]; } function swap(a, i, j) { const temp = a[i]; a[i] = a[j]; a[j] = temp; } function swapObj(a, i, j) { temp = {}; function sendTo(first, second) { first.x = second.x; first.y = second.y; first.height = second.height; first.fill = second.fill; } sendTo(a, i); sendTo(i, j); sendTo(j, a); } function random(i, j) { return Math.floor(Math.random() * (j - i)) + i; } function shuffle(a) { for(let i = 1; i < a.length; i ++) { const rand = random(0, i + 1); swap(a, i, rand); } } function randomData(num) { const data = []; for(let i = 1; i d.y) .attr("width", (d, i) => d.width) .attr("height", (d, i) => d.height) .attr("fill", d => d.fill); selectionSort(rawData); } function copy(a) { const t = []; for(let k = 0; k < a.length;k++) { t.push(a[k]); } return t; } function selectionSort(data) { function update(newData, ci, cj) { newData = layout(newData).data; d3.select("#selection-sort") .selectAll('rect') .data(newData) .attr("stroke-width", 1) .attr("stroke", "black") .attr("x", (d, i) => i * (20 + 8)) .attr("y", (d, i) => d.y) .attr("width", (d, i) => d.width) .attr("height", (d, i) => d.height) .attr("fill", d => d.fill); d3.select("#selection-sort") .selectAll('rect') .transition() .duration(200) .attr("x", (d, i) => { if(i == ci) { return cj * (20 + 8); }else if(i == cj) { return ci * (20 + 8); }else { return i * (20 + 8); } }); } let i = 0; function next() { let minIndex = i; for(let j = i + 1; j < data.length; j ++) { find(j); if(less(data, j, minIndex)) { minIndex = j; } } const oldData = copy(data); swap(data, i, minIndex); update(oldData, i, minIndex); i++; } setInterval(() => { if(i < data.length) { next(); } }, 300); } selectionDraw(randomData(20)); function getNumAndStartSelectionSort() { const value = document.getElementById('selectNum').value; selectionDraw(randomData(value)); } 插入排序希尔排序归并排序快速排序快速排序的一个简单实现： 选取最左一个值作为中心，把比它小的值挪到它左边，其余在右边，然后对它分成的两个部分使用快速排序。 用Js实现如下： 1234567891011121314151617181920function quicksort(array, low, high) &#123; if(low &gt;= high) &#123; return; &#125; let lt = low, gt = high; const pivot = array[low]; while(true) &#123; while(array[++lt] &lt; pivot &amp;&amp; lt != high); while(array[--gt] &gt; pivot); if(lt &lt;= gt) &#123; swap(array, lt, gt); &#125;else &#123; break; &#125; &#125; swap(array, low, gt); quicksort(array, low, lt - 1); quicksort(array, lt + 1, high);&#125; 但这不是一个好的实现。快速排序当面对一串已经排序的数据时，每次都把剩余部分分成了$0$和$当前长度-1$的两部分，最终能跑出~$\frac{1}{2}N^2$的时间来。 我们可以通过一个shuffle函数在$N$时间内把它打乱，但是当面对一串一模一样的数据时，依然是快排的最坏情况。如果待排序的数据中存在大量的重复，快排的效率就会下降。 因此我们可以通过将相同的数据都放在一起的方式来做一些改进，这个改进技术叫3 way partitioning. 12 function quicksort(array, low, high) { if(low >= high) { return; } let lt = low, gt = high; const pivot = array[low]; while(true) { while(array[++lt] < pivot && lt != high); while(array[--gt] > pivot); if(lt i * 50 + 1).attr("y",50).attr("width",40).attr("height",40).attr("fill", d => d.color); let text = c.append("text").attr("x", (d, i) => i * 50 + 13).attr("y",75).attr("fill", "black").text(d => d.value); if (change !== undefined) { rec.transition().duration(800).attr("x", (d, i) => change[i] * 50 + 1) text.transition().duration((d, i) => 800) .attr("x", (d, i) => change[i] * 50 + 13) } } function updateData(change) { let backup = [].concat(dataset); for(let i = 0;i= changeList.length) { auto = false; return; } let next = changeList[step]; getChart(next); updateData(next); step += 1; } reset(); setInterval(() => { if(auto) { start(); } }, 1000);]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算PageRank]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fpage-rank%2F</url>
    <content type="text"><![CDATA[核心思想PageRank的核心思想： 如果一个网页被很多其他网页链接到，说明这个网页比较重要，PageRank值相对也会比较高. 如果一个PageRank值很高的网页链接到一个其他的网页，那么被链接到的网页PageRank值也会相应提高. 计算公式一般情况下,一个网页的PR值的计算公式如下： $$PR(p_i)=\alpha\sum\limits_{Pj\in{M_{p_i}}}\frac{PR(p_j)}{L(P_j)}+\frac{1-\alpha}{N}$$ 计算公式一般情况下,一个网页的PR值的计算公式如下： $$PR(p_i)=\alpha\sum\limits_{Pj\in{M_{p_i}}}\frac{PR(p_j)}{L(P_j)}+\frac{1-\alpha}{N}$$ 算法举例PageRank的值物理意义上是一个网页被访问的概率，因此通常对$N$个网页计算时，将每个网页的初始值设为$\frac{1}{N}$. 假设有4个网页A, B, C, D A有1个出链到D,B有2个出链到A和DC有1个出链到AD有2个出链到B和C 然后我们开始算第一轮: $$\begin{split}PR(A)&amp;=\alpha\left(\frac{PR(B)}{L(B)}+\frac{PR(C)}{L(C)}\right)+\frac{1-\alpha}{N} \\&amp;=\alpha\left(\frac{\frac{1}{4}}{2}+\frac{\frac{1}{4}}{1}\right)+\frac{1-\alpha}{N} \\&amp;=\frac{17}{20}\times\frac{3}{8}+\frac{3}{80} \\&amp;=\frac{57}{160} \\\end{split}$$$$\begin{split}PR(B)&amp;=\alpha\frac{PR(D)}{L(D)}+\frac{1-\alpha}{N} \\&amp;=\frac{23}{160} \\\end{split}$$$$\begin{split}PR(C)&amp;=\alpha\frac{PR(D)}{L(D)}+\frac{1-\alpha}{N} \\&amp;=\frac{23}{160} \\\end{split}$$$$\begin{split}PR(D)&amp;=\alpha\left(\frac{PR(A)}{L(A)}+\frac{PR(B)}{L(B)}\right)+\frac{1-\alpha}{N} \\&amp;=\alpha\left(\frac{\frac{57}{160}}{1}+\frac{\frac{23}{160}}{2}\right)+\frac{1-\alpha}{N} \\&amp;=\frac{17}{20}\times\frac{137}{320}+\frac{3}{80} \\&amp;=\frac{2569}{6400} \\\end{split}$$ 然后再从$PR(A)$开始计算……直到趋于平稳为止. 注意 当一个网页没有出链时认为对所有网页都有出链 为了限制一个网页只有指向自己的出链或者几个出链形成一个圈的情况，我们假定有一个概率$\alpha$，用户在浏览网页时会有一个这样的概率直接跳转到一个随机的网页，而每个网页的概率是相等的. $\alpha$值通常取$0.85$]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>算法</tag>
        <tag>PageRank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习ruby]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fruby-learning%2F</url>
    <content type="text"><![CDATA[开发环境搭建windows下的安装这个不难，有时候installer可能被墙 CentOS7我需要一个消息队列拯救服务器记笔记一个类1234567class Demo def initialize end def func1 endend]]></content>
      <categories>
        <category>编程</category>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集古诗文]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fchinese-learning%2F</url>
    <content type="text"><![CDATA[大学12大学之道，在明明德，在亲民，在止於至善。知止而後有定，定而後能静，静而後能安，安而後能虑，虑而後能得。物有本末，事有终始，知所先後，则近道矣…… 好事近·梦中作春路雨添花，花动一山春色。行到小溪深处，有黄鹂千百。飞云当面化龙蛇，夭矫转空碧。醉卧古藤阴下，了不知南北。 宫怨李益 露湿晴花春殿香，月明歌吹在昭阳。似将海水添宫漏，共滴长门一夜长。 归去来兮辞陶渊明 归去来兮，田园将芜胡不归？既自以心为形役，奚惆怅而独悲？悟已往之不谏，知来者之可追。实迷途其未远，觉今是而昨非。舟遥遥以轻飏，风飘飘而吹衣。问征夫以前路，恨晨光之熹微。乃瞻衡宇，载欣载奔。僮仆欢迎，稚子候门。三径就荒，松菊犹存。携幼入室，有酒盈樽。引壶觞以自酌，眄庭柯以怡颜。倚南窗以寄傲，审容膝之易安。园日涉以成趣，门虽设而常关。策扶老以流憩，时矫首而暇观。云无心以出岫，鸟倦飞而知还。景翳翳以将入，抚孤松而盘桓。归去来兮，请息交以绝游。世与我而相违，复驾言兮焉求？悦亲戚之情话，乐琴书以消忧。农人告余以春及，将有事与西畴。或命巾车，或棹孤舟。既窈窕以寻壑，亦崎岖而经丘。木欣欣以向荣，泉涓涓而始流。善万物以得时，感吾生之行休。已矣乎！寓形宇内复几时。曷不委心任去留？胡为惶惶乎欲何之？富贵非吾愿，帝乡不可期。怀良辰以孤往，或执杖而耘耔。登东皋以舒啸，临清流而赋诗。聊乘化以归尽，乐夫天命复奚疑！]]></content>
      <categories>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>汉语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集/背英语单词]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fenglish-learning%2F</url>
    <content type="text"><![CDATA[下一个 #main-div { background-color: #fad689; min-height: 140px; margin-bottom: 40px; padding: 15px; border: 2px solid black; border-radius: 2px; } @media (max-width: 628px) { #main-div { max-width: 300px; } } #title { font-size: 1.2rem; font-weight: bold; } #wrapper { display: flex; flex-direction: column; align-items: center; } 收集一些翻到的英语词汇perpendicularadj. 垂直的，成直角的n. 垂直线，垂直面 namelyadv. 即，也就是说 coordinatevt. 使协调，使调和vi. 协调，协同adj. 同等的;带有同等性质的 regardless of不管，不顾 obscureadj. 昏暗的，朦胧的;晦涩的，不清楚的vt. 使…模糊不清n. 某种模糊的或不清楚的东西 perspectiven. 透镜，望远镜;观点，看法adj. (按照)透视画法的;透视的 distortionn. 扭曲，变形;失真，畸变 interpolationn. 篡改，添写，插补，插值 revisevt. 修订，修正，改变，复习vi. 修订，校订 permeatevt. 渗透，渗入，弥漫，遍布vi. 贯穿，感染，传播，渗入，遍及，穿透某物 photonn. 光子，光量子 strikingadj. 引人注目的，显著的v. 击，打(现在分词);敲响;报时 comprisevt. 包含，包括;由…组成 squishn. 咯吱声，果酱v. 压扁，压烂，咯吱吱地走 retentionn. 保留，记忆力，保持力，滞留，扣留，闭尿 innocentadj. 清白的,天真无邪的n. 无辜者,头脑简单的人 molen. 鼹鼠，痣，间谍，防波堤 prolepticadj. 预期的 temporaladj. 时间的，世俗的，暂存的n. 暂存的事物，时间的事物，世俗的权力 corpusn. 全集，文集，资金 semanticsn. 语义学，词义学 farewelln. 告别，欢送，欢送会，告别辞int. 再见，再会adj. 告别的，送行的 magnificantadj. 辉煌的 napn. 绒毛，小睡，打盹vi. 打瞌睡，疏忽vt. 使起毛 tinkern. 小炉匠，补锅匠，拙劣的工人，小鲭鱼vi. 焊补，胡乱修补vt. 修补，粗修 intrinsicadj. 本征，固有的，内在的，本质的，体内的，先天性 harnessn. 背带，马具，挽具vt. 利用，给（马等）套轭具，控制 concretizevt. 使具体化，使有形化 provablyadj. [计]证明地 caveatn. 警告，附加说明 fledgevi. （鸟）长羽毛vt. 给（箭）装上羽毛，把（小鸟）养到能飞 nastyadj. 肮脏的，下流的，令人讨厌的n. 令人不愉快的事物 feasibilityn. 可行性，可能性，现实性 dissectingvt. 解剖，仔细分析vi. 进行解剖，进行详细分析 spriten. 鬼怪，小妖精，调皮鬼 affirmativeadj. 肯定的，赞成的，同意的，积极的，乐观的n. 肯定的，肯定语，正方，确言，赞成 proneadj. 俯卧的，易于……的，有……倾向的，倾斜的，坡陡的 acquaintvt. 使熟悉，使认识，告知 purgevt. 肃清，清除，净化n. 净化，整肃 explanatoryadj. 解释的，解释性，说明的 restatevt. 重申，再次声明 taintn. 污点，污名，气味vt. 玷污，败坏，使变质，使污染vi. 败坏，腐坏，被污染 scarceadj. 缺乏的，罕见的adv. 勉强，仅仅，几乎不，简直不 elaboratevi. 详尽说明，变得复杂vt. 详细制定，详尽阐述，加工，尽力竭力地做adj. 精心制作的，精巧的，复杂的 aforementionedadj. 前述的，上述的 ambitiouslyadv. 雄心勃勃地 auxiliaryadj. 辅助的，备用的，补充的，附加的n. 助动词，副助词，辅助人员，附属机构 tightenvt. 收紧，（使）收紧，（使）绷紧 imposevt. 强加，征税，以……欺骗vi. 利用，欺骗，施加影响 legitn. 正统剧，正统剧院adj. 合法的 recapvt. 翻新（轮胎）的胎面vt. 扼要重述，概括n. 翻新的轮胎，重述要点，简明新闻 oversightsn. 失察，忽略，疏忽，负责 dedicatedadj. 专用的，专注的，投入的，献身的 concatenatedvt. 把（一系列事件、事情等）联系起来adj. 连接的，联系在一起的 innocuousadj. 无害的，平淡无味的 interminglevt. （使）混合，混在一起 trivialadj. 琐碎的，无价值的，平常的，平凡的，不重要的 subtleadj. 微妙的，巧妙的，敏感的，狡猾的 tidbitn. 趣闻，（美味食物的）一口，小栏报导 decentadj. 正派的，得体的，相称的，合宜的 anecdotea short, often funny story, especially about something someone has donen. 趣闻，轶事 intermediateadj. 中间的，中级的n. 中间物，中间分子，中间人；vi. 调解，充当调解人，干涉 blazingadj. 炽热的，酷热的，及其愤怒的，感情强烈的v. 猛烈地燃烧,发光,照耀 theoremn. [数]定理；一般原理，公理，定律，法则 provern. 证人，校准装置 arguablyadv. 可论证地，可争辩地 purportedlyadv. 据称 myriadadj. 无数的，多种的，各式各样的n. 无数，极大数量，[古语]一万 manipulatevt. 操纵，操作，处理 colloquiallyadv. 用白话，用通俗话 conceitedadj. 自负的，自高自大的，骄傲自满的 arrogantadj. 傲慢的，自大的 leveragen. 杠杆作用，影响力，优势v. 举债经营，借贷收购 heuristicsn. 启发(法)，探索法 magnituden. 量级，巨大，广大，级数 promptlyadv. 迅速地，敏捷地，立即地 vulnerabilityn. 脆弱性; 弱点，攻击; 易伤性; 致命性; unalteredadj. 未改变的 soleadj. 唯一的，单独的，专有的，独占的n. 鞋底，脚底，有…底的，可食用的比目鱼vt. 给鞋换底 snippetn. 小片，片段，不知天高地厚的年轻人 maliciousadj. 恶意的，有敌意的，蓄意的，预谋的，存心不良的 reassuringlyadv. 安慰地，鼓励地 approximationn. 接近; &lt;数&gt;近似值; 近似额; 粗略估计 resultantadj. 因而发生的，结果必然产生的，组合的，合成的n. 结果，后果，合力，合成力 sidestepvi. 回避，向侧方跨步vt. 让开…的路，躲避，绕开n. 台阶，避开与强手对阵，侧跨步，横跳躲闪 granularityn. 间隔尺寸，粒度 internalizevt. 使内在化，使藏在心底 substitutevt. 代替，替换，代用n. 替代物vi. 用……代替 overlapn. 重叠部分，覆盖物，涂盖层vt. 重叠，与……相同vi. 互搭，重叠，部分相同 sophisticatedadj. 复杂的，精致的，富有经验的，深奥微妙的 sentineln. 岗哨，哨兵 interleavingn. 交叉，交错 interleavevt. 插入纸 elidevt. 省略 multiplexadj. 多元的，多倍的，复式的n. 多路，多厅影院v. 多路传输，多路复用 crudeadj. 简陋的，粗糙的，粗杂的n. 原油，原材料，天然物质 coexistvi. 同时共存，和平共处 downsiden. 下降趋势，负面，消极面adj. 下降趋势的 conservativen. 保守的人，保守党党员adj. 保守的，保守党的 uncontroversialadj. 非争论性的 grosslyadv. 非常，十足地，下流地，大概 swathn. 收割的刈痕，细长的列，草条 dismaladj. 忧郁的，阴沉的，惨淡的，凄凉的n. 低落的情绪，沼泽 vastadj. 广阔的，巨大的，大量的，巨额的n. 浩瀚，广大无边的空间 miscellaneousadj. 混杂的，各种各样的，五花八门的，多方面的 ravevi. 咆哮，胡言乱语，说梦话，愤怒地说，狂喜vt. 热烈讨论，奋笔疾书n. 围栏，围板，狂闹，怒吼，狂欢晚会 inhibitv. 抑制，禁止 cosmeticn. 化妆品，美发油，发蜡，装饰品，美容术adj. 美容的，化妆用的，装点门面的，表面的 lemman. 引理，辅助定理，论点，主旨 subtractiveadj. 减去的，负数的 catchyadj. 易记的; 易使人上当的; 迷人的 whereinadv. 其中，在那里，在哪方面conj. 在哪一点上，在什么地方 attenuatevt. 减弱，（使）变细，（使）变薄，（使）变小adj. 稀薄的，细小的，减弱的，减少的 tuckvt. 吃，喝，折叠，包起，裹起n. 鼓声，喇叭声，活力，精力，卷起，盖住 photocopiern. 影印机，复印机 analoguen. 相似物，相似的情况，对应的人adj. 模拟计算的，类似的，相似物的 territoryn. 领地，领土，版图，领域 pluckn. 勇气，精神，内脏，快而猛的拉vt. 拔掉，采，摘，弹（乐器）vi. 拉，拽 numerologyn. 数字命理学，数字占卜术 orbitn. 轨道，眼眶，势力范围，（人生的）旅程vt. 在…轨道上运行，环绕轨道运行vi. 盘旋，绕轨道运行 amplituden. 振幅，广大，广阔，充足，（思想的）广度 feasibleadj. 可行的，可用的，可实行的，可能的 likewiseadv. 同样地，也，而且 permissibleadj. 许可的，可允许的，不碍事的，得到准许的 resonancen. 共振，共鸣，反响 esotericadj. 秘传的，机密的，难解的，深奥的，限于少数人的 perceivev. 理解，意识到，察觉，发觉 octaven. 八度音阶，八度音，高八度音 convolutedadj. 复杂的，盘绕的，卷曲的v. 回旋，卷绕，盘旋 percussionn. 敲打，碰撞，振动，打击乐器，叩诊法 constituentn. 选民，成分，构成部分，委托人adj. 构成的，组成的，选举的，有选举权的 instalmentn. 分期付款，装设，就职，分期连载的一部分 clarinetn. 竖笛，黑管，单簧管 reedn. 芦苇，芦苇秆，舌簧 oboen. 欧巴，双簧管 bassoonn. （一种吹奏乐器）巴松管，低音管，巴松管吹奏者 timpanin. 定音鼓 negligibleadj. 微不足道的，可以忽略的，无足轻重的，不足轻重 carvedadj. 有雕刻的 lumpn. 肿块，块，团，许多，大量，笨拙的人vi. 结成块，成团，笨重地行走vt. 使成团，使成块，使团结在一起 membranen. 隔膜; （动物或植物体内的） 薄膜; （可起防水、防风等作用的） 膜状物; circumferencen. 胸围，周围，腰围 tambourn. 鼓v. 在绷圈上绣 acousticadj. 声学的，听觉的，原声的，音响的 stationaryadj. 不动的，固定的，静止的，不变的n. 不动的人，驻军，固定物 suspiciouslyadv. 猜疑地，怀疑地，疑心很深地 astrophysicistn. 天体物理学家 hideousadj. 令人惊骇的，极其丑陋的，可怕的，丑恶的 bogglevi. 惊恐，退缩，踌躇，犹豫vt. 弄坏，搞糟，犹豫n. 搪塞，犹豫，退缩，吃惊 consignvt. 托运，寄售，委托，托付，用作，当作 gongn. 锣 cymbaln. 钹 startlingadj. 令人吃惊的 syllabusn. 教学大纲 synopsesn. 大纲，摘要 particaln. 质点 genomen. 基因组，染色体组 stimulationn. 刺激，启发，促进 versen. 诗篇，诗，散文v. 作诗 inquiryn. 探究，调查，审查，质问 expositoryadj. 说明的，解释的 interdisciplinaryadj. 跨学科，各学科间的 percolationn. 渗漏，过滤，浸透 breadthn. 宽度，广泛 intractabilityn. 难驾驭，棘手 deluxeadj. 豪华的，高级的 precedencen. 优先级，位次，领先，地位先后，级别高低 parenthesesn. 圆括号，插入语，插曲 raggedadj. 衣着破烂的，衣衫褴褛的，参差不齐的，凹凸不平的 thumbn. 拇指，手套的拇指部分vi. 翘起拇指请求搭乘，翻阅vt. 翻阅，作搭车手势，用拇指翻脏 circumscribevt. 限制，限定，在……周围划线 casinon. 赌场，俱乐部，娱乐场，小别墅 cryptographicallyadv. 密码地，暗号地 amortizevt. 分期偿还 morphologyn. 形态学（尤指动植物形态学或词语形态学） porousadj. 能穿透的，能渗透的，有毛孔或气孔的 insulatevt. 使隔离，使孤立，使绝缘，使隔热 adjacentadj. 相邻，邻近的，毗邻的 pervasiveadj. 普遍的，扩大的，渗透的，弥漫的adv. 无处不在的，遍布地n. 无处不在，遍布 underpinningn. 基础材料，基础结构，理论，腿v. 用砖石结构从下面支撑 perceptionn. 知觉，观念，觉察 dualismn. 二元论 materialismn. 唯物主义，唯物论 blastingn. 爆破作业v. 炸毁 foremann. 工头，领班 borevt. 钻孔，令人厌烦vi. 钻孔，挖洞n. 使人讨厌的东西 fusevi. 融合，熔化vt. 使融合，使融化n. 保险丝，引信，导火线，雷管 tampingn. 填塞物，捣紧v. 夯实，tamp的现在分词 javelinn. 标枪，投枪 cluttern. 杂乱，混乱vt. 使凌乱，乱糟糟的堆满vi. 乱哄哄地跑，发出吵闹声 staggervi. 蹒跚，动摇，犹豫vt. 使蹒跚，使动摇n. 摇晃，一种不稳定形式 shrewdadj. 精明的，敏锐的，奸诈的，狡猾的 fitfuladj. 一阵阵的，不规则的，不稳定的 indulgevt. 迁就，纵容，使满足vi. 沉溺，纵容，满足 grossadj. 总的，粗俗的，显而易见的，恶劣的n. 总额vt. 总共收入 profanityn. 渎神，亵渎语言 molecuren. 分子 spinaladj. 脊柱的，与脊柱有关的adv. 在脊骨方面n. 脊髓麻醉 cordn. 绳，灯芯绒裤vt. 用绳子捆绑 doctrinen. 教条，教义，法律原则 articulateadj. 发音清晰的，善于表达的，有关节的vt. 清晰地发音，言语表达vi. 清楚和清晰地讲 tridentn. 三叉戟，三叉线adj. 三叉的 variegatedadj. 杂色的，斑驳的，变化多端的vt. 使成杂色（过去分词） intuitionn. 直觉，直觉力 derangedadj. 疯狂的，神经错乱的，混乱的v. 使精神错乱（过去分词） vatn. （酿造，制革等用的）大桶，大缸vt. 把……盛入大桶 hopvi. 跳上，单足蹦跳，齐足跳行vt. 跃过，登上n. 跳舞，蹦跳 swampn. 湿地，沼泽地vt. 淹没，使沉没vi. 淹没，沉没 bristlen. 刚毛，鬃毛，胡须茬vi. 发怒，竖立vt. 使（毛发）直立 swinen. &lt;旧&gt;猪，&lt;俚&gt;讨厌鬼 demonicadj. 恶魔的，魔鬼似的，恶魔般的 reincarnationn. 再生，再投胎，化身而成的生物 audaciousadj. 大胆的，大胆创新的，鲁莽的 shrugvt. 耸肩vi. 耸肩n. 耸肩 grapplevt. 搏斗，抓住，抓牢vi. 格斗，抓住n. 扭打，格斗 grudginglyadv. 不情愿地，勉强地 ludicrousadj. 可笑的，荒唐的 syphilisn. 梅毒 unpalatableadj. 味道差的，不好吃的，无味 humilityn. 谦逊，谦恭 revolvevt. 使旋转，反复考虑，使循环vi. 旋转，循环出现，反复考虑 loitervi. 游荡，闲逛，走走停停，磨蹭 thrashingn. 颠簸，抖动 asymptoticadj. 渐近线的，渐进的 shimmervi. 闪烁，发微光n. 微光，闪光 meatloafn. 烘肉卷 hyperthalamusn. 视丘下部 loben. 裂片，肺叶，耳垂，脑叶 dendriten. 树突，树枝石，模石树 axonn. 轴突 spinal cordn. 脊髓 myelinn. 髓磷脂 sheathn. 鞘，护套，叶鞘，紧身装v. 包，盖 insulationn. 绝缘，隔声，隔离，孤立 replicatevt. 复制，复写，重复，反复adj. 复制的，折叠的n. 复制品，八音间隔的反复音 dimadj. 暗淡的，昏暗的，不光明的，看不清的vt. 使变暗淡，使变模糊n. 笨蛋，傻子 stabvt. 刺，刺伤，将……刺入vi. 刺伤n. 尝试，突发的一阵，刺的伤口 fiddlen. 小提琴，桌面柜，胡扯，无聊vi. 拉小提琴vt. 拉小提琴 antagonistn. 敌手，反对者，对抗肌，对抗药 agonistn. 主动肌，兴奋剂，激动剂，促效药 curaren. 箭毒马鞍子，箭毒 goofyadj. 愚笨的，傻瓜的 exuberantadj. 生气勃勃的，充沛的，茂盛的adv. 生气勃勃地，……(可以形容人喝完酒的状态？) amphetaminen. 安非他明，苯基丙胺 norepinephrinen. 降肾上腺素，去甲肾上腺素 arousaln. 觉醒，激励 dopaminen. 多巴胺 serotoninn. 5-羟色胺 resilientadj. 能复原的，弹回的，有弹性的 grailn. 圣杯，鹅卵石，大盘 tunedadj. 调谐的，已调谐的 nutn. 螺母 boltn. 螺钉 disorganizedadj. 组织混乱的，杂乱无章的，混乱的，没有条理的 scrimmagen. 混战，并列争球 upfieldn. (足球等运动中)向前场的，高磁场 invasionn. 侵袭，入侵，侵略，侵害，侵犯 viaductn. 高架桥（通常有多孔） slopen. 斜率 plagiarismn. 抄袭，剽窃，剽窃物，抄袭物 churnvt. 搅拌，制造vi. 制造奶油等n. 搅乳桶 function getRandom() { let titles = document.querySelectorAll('h4'); let ps = document.querySelectorAll('p'); let len = titles.length; let rand = Math.floor(Math.random() * len); return { title: titles[rand].id, text: ps[rand+1].innerText } } function render(card) { let title = document.querySelector('#title'); let content = document.querySelector('#text-content'); title.innerText = card.title; content.innerText = card.text; } render(getRandom());]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++ 的笔记]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fcpp-learning%2F</url>
    <content type="text"><![CDATA[写在前面我觉得作为一个喜欢编程的人不会写C++好像有点说不过去。虽然我一直在写Java,然后也一直觉得C++写起来非常麻烦。不过就算是麻烦也应该先写一段时间再说对不对。至少C++是非常有趣，非常强大的，值得深入学习，虽然学不会。 这边是我记的Effective C++的笔记。有时间我再去看一看More Effective C++和C++ Primer, C++ Primer Plus。先记在计划里吧。 这本书里面介绍了55个守则，如果我们熟悉了这些守则，对我们在C++的开发是很有好处的，至少是前人总结的非常优秀的经验。我觉得一个写了三年多代码的人来看这本书还是比较轻松的，当然还是需要有一定的C++基础。Primer的书太厚了，一时半会儿看不完，有机会再看吧。 01: View C++ as a federation of languages 视C++为一个语言联邦这是一个非常有趣的东西。我们可以使用很多种方式来使用C++，比如面向对象或者函数式编程…等。 这本书里把C++总结为了4个次语言组成的联邦： C,也就是C++中C的部分 Object-Oriented C++ Template C++，我不是很懂这个。在Java里模板和面向对象是一起愉快使用的啊？ STL。是一个Template程序库 而我们在开发的时候总是选取了其中的某种次语言来进行，当我们在使用其中的某一个次语言的时候应该遵守相应的规范或者守则，尽管这可能会违背在另一个次语言中的规范。 02: Prefer consts, enums, and inlines to #defines 尽量以const, enum, inline替换#define这个条款大意是，我们应尽量把事情丢给编译器而不是预处理器，因为defines只是一个在预处理器中的简单的替换。 比如如下的代码： 1#define ASPECT_RATIO 1.653 每当使用ASPECT_RATIO的时候实际上进了编译器里都被替换为了1.653而不是同一个常量或者变量。 也就是编译器并不知道有一个记号名称叫ASPECT_RATIO。这里有一个记号表的概念我想是编译器里面的。有机会我应该会接触这个东西。 这个方式导致的问题可能是我们在获得一个编译错误的时候可能会感到很困惑，因为我们看见了一个没有名字的数值，这使人费解。 解决之道： 1const double AspectRatio = 1.653; 注意这里的命名方式，一个常量的命名方式竟然是双驼峰。大写则是宏里面常用的方式。 （我有一个问题，类名的命名方式是怎么样的） 这么做比起用宏还有一个好处，可能会使代码的量更少。可能一个浮点数使用的空间会比一个记号要来得更大一些，使用的浮点数宏越多，那么占用的空间也会越大。如果宏里面是一个更大的东西那就更不用说了。 03：Use const whenever possible 尽可能使用const04: Make sure that objects are initialized before they’re used 确定对象被使用前已先被初始化05: Know that functions C++ silently writes and calls 了解C++默默编写并调用哪些函数06: Expicitly disallow the use of compiler-generated functions you do not want 若不想使用编译器自动生成的函数，就该明确拒绝07: Declare destructors virtual in polymorphic base classes 为多态基类声明virtual析构函数08: Prevent exceptions from leaving destructors 别让异常逃离析构函数09: Never call virtual functions during constructino or destruction 绝不在构造和析构过程中调用virtual函数10: Have assignment operators return a reference to this 令operator=返回一个reference to this11: Handle assignment to self in operator= 在operator=中处理“自我赋值”12: Copy all parts of an object 复制对象时勿忘其每一个成分13: Use objects to manage resources 以对象管理资源14: Think carefully about copying behavior in resource-managing classes 在资源管理类中小心copying行为15: Provide access to raw resources in resource-managing classed 在资源管理类中提供对原始资源的访问16: use the same form in corresponding uses of new and delete 成对使用new和delete时要采取相同形式17: Store newed objects in smart pointers in standalone statements 以独立语句将newed对象置入智能指针18: Make interfaces easy to use correctly and hard to use incorrectly 让接口容易被正确使用，不易被误用19: Treat class design as type design 设计class犹如设计type20: Prefer pass-by-reference-to-const to pass-by-value 宁以pass-by-reference-to-const替换pass-by-value21: Don’t try to return a reference when you must return an object 必须返回对象时，别妄想返回其reference22: Declare data members private 将成员变量声明为private23: Prefer non-member non-friend functions to member functions 宁以non-member、non-friend替换member函数24: Declare non-member functions when type conversions should apply to all parameters 若所有参数皆需类型转换，请为此采用non-member函数25: Consider support for a noon-throwing swap 考虑写出一个不抛异常的swap函数艹, C++又把我看晕了]]></content>
      <categories>
        <category>编程</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>c++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的一些有趣的内容]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fjava-learning%2F</url>
    <content type="text"><![CDATA[enumenum也就是Java中的枚举类，我们可以声明一个类为如下的几个具体类型： class interface enum annotation(@interface) 那么enum中可以进行什么操作，enum是怎么实现的？ enum通常可以进行的操作通常我们会拿它来定义一些枚举值，比如 虽然我很想翻出几个java中自带的enum但是想了几个都是static final XXX什么的 还是随便来一个吧 123public enum Color &#123; GREEN, YELLOW, BLUE&#125; 也就是定义一些常量，然后我们可以给它们加一点属性… 1234567891011public enum Color &#123; GREEN("绿色", "#00ff00"), RED("红色", "#ff0000"), BLUE("蓝色", "0000ff"); Color(String description, String value) &#123; this.description = description; this.value = value; &#125; public String description; public String value;&#125; 再加一点方法… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public enum Color &#123; GREEN("绿色", 0, 255, 0) &#123; @Override public int getChannelValue(String original) &#123; return Integer.parseInt(original.substring(3, 5), 16); &#125; &#125;, RED("红色", 255, 0, 0) &#123; @Override public int getChannelValue(String original) &#123; return Integer.parseInt(original.substring(1, 3), 16); &#125; &#125;, BLUE("蓝色", 0, 0, 255) &#123; @Override public int getChannelValue(String original) &#123; return Integer.parseInt(original.substring(5, 7), 16); &#125; &#125;; Color(String description, int r, int g, int b) &#123; this.description = description; this.r = r; this.g = g; this.b = b; &#125; public String description; public int r; public int g; public int b; public String getValue() &#123; return "#" + toHexString(r) + toHexString(g) + toHexString(b); &#125; private String toHexString(int i) &#123; String hex = Integer.toHexString(i); if (hex.length() == 1) &#123; hex = "0" + hex; &#125; return hex; &#125; public abstract int getChannelValue(String original);&#125; 我们可以在里面放一些 属性 普通方法 抽象方法 构造函数 如果是构造函数或者是抽象方法，我们需要在每一个枚举值中进行重载，也就是下面这个写法： 123456BLUE("蓝色", 0, 0, 255) &#123; @Override public int getChannelValue(String original) &#123; return Integer.parseInt(original.substring(5, 7), 16); &#125;&#125;; 看起来就像实现一个匿名内部类一样（其实实际上也是的） 实现原理我们操作完上面的步骤，现在看看它是怎么实现的 实际上enum在Java1.5开始才加入Java中，我们定义的枚举类和里面的枚举值实际上是继承了java.lang.Enum的类和它的匿名内部类的实现。 即enum XXX实际上是abstract class XXX extends Enum&lt;XXX&gt; 而里面的每一个枚举值A,B,C是这个类的几个static final实例。 由于XXX是抽象类，所以每一个实例初始化都需要override构造方法和抽象方法，来实现一个匿名内部类，每一个枚举值都是抽象类里面的不同匿名内部类的实例。 这样就可以达到一个枚举的效果。 LocalDateTime@since 1.8java.time.LocalDateTime是Java8开始加入的类。 操作起来应该比较舒服了。 此外LocalDateTime是与时区无关的，它不能单独表示某一个确切的时间点。 （我们在数据库里存的DateTime呢） 最大和最小值LocalDateTime.MIN和LocalDateTime.MAX可以表示-999999999-01-01T00:00:00和+999999999-12-31T23:59:59.999999999。 也就是说如果使用LocalDateTime, 几乎没有需要担心有时间表示不了的情况。 一些方法LocalDateTime实际上是由LocalDate和LocalTime组成的。 可以用now(), of()等方法构造一个LocalDateTime 而LocalDateTime对象可以使用各种minus, plus方法来获得另一个时间，当然也可以使用with某个value的方法。 也就是说如果我们需要获得上一周时间，上一周开始时间，等等，都是可以很方便地操作的 这些方法的返回值是一个新的LocalDateTime对象，所以我们可以…..调用来拿到我们想要的时间。 （不过还是JodaTime的方便一些） LocalDate和LocalTimeLocalTime中的每一个field都是用一个单独的int来存储的。 （这个实现一点都不复杂） 收集一些待解决的问题 Java里面声明一个数字的时候可以用下划线分隔… 如123_123_123 所以不写访问权限的时候是可以从哪里访问来着… Objects.requireNonNull();似乎是用来抛出异常的]]></content>
      <categories>
        <category>编程</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Java</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三角级数相关]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Ftrigonometric-series%2F</url>
    <content type="text"><![CDATA[三角级数$\quad$一般地，以$A_k\sin(kx+\varphi_k)$为项作成的无穷级数 $$\sum\limits_{k=0}^{\infty}A_k\sin(kx+\varphi_k)$$ 称为三角级数.（所以首先三角级数都是无穷级数） 但是有时候也会取如下形式： $$\frac{a_0}{2}+\sum\limits_{k=1}^{\infty}(a_k\cos{kx}+b_k\sin{kx})。$$ 周期函数周期函数有初相,振幅,频率 正弦级数给三角级数中所有的$a_k$取$0$，可以得到如下的正弦级数: $$\sum\limits_{k=1}^{\infty}b_k\sin{kx}$$ 余弦级数类似的操作可以得到余弦级数 $$\frac{a_0}{2}+\sum\limits_{k=1}^{\infty}a_k\cos{kx}$$ 傅里叶级数$$\begin{split}A_n&amp;=\frac{1}{\pi}\int_0^{2\pi}f(x)\cos{nx}\mathtt{d}x \\B_n&amp;=\frac{1}{\pi}\int_0^{2\pi}f(x)\sin{nx}\mathtt{d}x\end{split}$$ 这里用的符号和上面不一样呢 应该打屁股]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
        <tag>级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曲线积分的意义]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fcurve-line-integral%2F</url>
    <content type="text"><![CDATA[曲线积分第一类曲线积分第一类曲线积分用来求一个曲线物体的质量.当物体的密度是一个常值时，只需要将密度乘以弧长就可以得到质量.当物体的密度不均匀时，我们将密度表示为函数$f$，并对函数在曲线上积分，称为第一类曲线积分或者对弧长的曲线积分,记为$\int_Cf(x,y)\mathtt{d}s$，即 $$\int_Cf(x,y)\mathtt{d}s=\lim_{\lambda\to{0}}\sum_{i=1}^nf(\xi_i,\eta_i)\Delta{s_i}$$ 其中$f(x,y)$称为被积函数,$C$称为积分曲线,$\mathtt{d}s$称为弧微分. 我们可以把这个概念扩展到三维空间或者更高维的空间中： $$\int_Cf(x,y,z)\mathtt{d}s=\lim_{\lambda\to{0}}\sum_{i=1}^nf(\xi_i,\eta_i,\zeta_i)\Delta{s_i}$$ 第二类曲线积分和第一类曲线积分不同，第二类曲线积分可以用来表示变力沿曲线做的功，是有方向的.第二类曲线积分记为: $$\int_CP(x,y)dx+Q(x,y)dy\quad或\quad\int_C\boldsymbol{F}(x,y)·\mathtt{d}\boldsymbol{r}$$ 特别地，还可以有对某个方向的曲线积分 沿曲线$C$对坐标$x$的曲线积分$$\int_CP(x,y)dx=\lim_{\lambda\to{0}}\sum_{i=1}^nP(\xi_i,\eta_i)\Delta{x_i}$$ 沿曲线$C$对坐标$y$的曲线积分$$\int_CQ(x,y)dy=\lim_{\lambda\to{0}}\sum_{i=1}^nQ(\xi_i,\eta_i)\Delta{y_i}$$ 既然如此，应该还可以对一个特定的方向积分，就是不知道怎么表示. 如果曲线$C$为闭曲线，则记第二类曲线积分为 $$\oint_CP(x,y)dx+Q(x,y)dy\quad或\quad\oint_C\boldsymbol{F}(x,y)·\mathtt{d}\boldsymbol{r}$$]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格林公式]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2FGreen-Formula%2F</url>
    <content type="text"><![CDATA[格林公式的定义和一些练习格林公式的定义，证明以及关于计算面积的一个应用。 简单闭曲线$\quad$设曲线$C$的参数方程为 $$\begin{cases}x=\varphi(t), \\y=\psi(t)\end{cases}\quad(\alpha\le{t}\le\beta).$$ 如果$\varphi,\psi$连续，且对不同的参数$t_1,t_2\in[\alpha,\beta]$(不妨设$t_1\le{t_2}$),$(\varphi(t_1),\psi(t_1))=(\varphi(t_2),\psi(t_2))$当且仅当$t_1=\alpha,t_2=\beta$,则称$C$为简单闭曲线 单连通区域$\quad$设有一个平面区域$D$,若$D$内的任意一条简单闭曲线所围的部分仍属于$D$，则称$D$为单连通区域，否则称为多连通区域. 格林公式$\quad$设有界闭区域$D$由逐段光滑曲线$C$围成，函数$P(x,y)$及$Q(x,y)$在$D$上具有一阶连续偏导数，则 $$\begin{split}\oint_C{P}\mathtt{d}x+Q\mathtt{d}y=\iint\limits_D\left(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}}\right)\mathtt{d}x\mathtt{d}y\end{split}$$ 用途通常这些东西总是有用的，我们观察上面的式子。 左边一部分是对光滑曲线$C$的第二类曲线积分，格林公式告诉我们它会与在由曲线围成的平面区域$D$上对两个方向的分量在另一个方向的偏导之差的积分相等. 证明为了加深理解，我们来看一下证明.证明格林公式的时候是拆开证的，也就是 $$\oint_CP\mathtt{d}x=-\iint\limits_D\frac{\partial{P}}{\partial{y}}\mathtt{d}x\mathtt{d}y, \quad\oint_CQ\mathtt{d}y=\iint\frac{\partial{Q}}{\partial{x}}\mathtt{d}x\mathtt{d}y$$ 分以下三种情况讨论: $D$由曲线$y=\varphi_1(x),y=\varphi_2(x)$，及直线$x=a,x=b$围成，即 $$D=\{(x,y)\mid\varphi_1(x)\le{y}\le\varphi_2(x),a\le{x}\le{b}\}$$ 我们假设区域的4个顶点从左下开始，以逆时针标记为A,B,C,E四个点。首先我们看看左边部分，因为左右两边是竖线，我们有: $$\begin{split}\oint_CP\mathtt{d}x&amp;=\int_{\overset{\frown}{AB}}P\mathtt{d}x+\int_{\overline{BC}}P\mathtt{d}x+\int_{\overset{\frown}{CE}}P\mathtt{d}x+\int_{\overline{EA}}P\mathtt{d}x\\&amp;=\int_{\overset{\frown}{AB}}P\mathtt{d}x+\int_{\overset{\frown}{CE}}P\mathtt{d}x\\&amp;=\int_a^bP(x,\varphi_1(x))\mathtt{d}x+\int_b^aP(x,\varphi_2(x))\mathtt{d}x\\&amp;=\int_a^bP(x,\varphi_1(x))-P(x,\varphi_2(x))\mathtt{d}x\\\end{split}$$ 而等式的右边有： $$\begin{split}-\iint\limits_D\frac{\partial{P}}{\partial{y}}\mathtt{d}x\mathtt{d}y&amp;=-\int_a^b\mathtt{d}x\int_{\varphi_1(x)}^{\varphi_2(x)}\frac{\partial{P}}{\partial{y}}\mathtt{d}y\\&amp;=-\int_a^bP(x,\varphi_2(x))-P(x,\varphi_1(x))\mathtt{d}x\\\end{split}$$ 可见两者相等。而在另一个方向上的证明也类似，略去。 $D$是单连通区域，且与某些与$y$轴平行的直线相交多于两点 如果某个单连通区域没有与某些与$y$轴平行的直线相交多于两点，我们直接把它切成上下两个部分就ok了。所以我们可以略过这一个情况。如果有相交多于两点的情况，我们可以把它进行切割，使得每个部分都是情况1中的情况来证明。 $D$是多连通区域 多连通区域也可以拆成上面的几个区域组成的部分，从而得证。 做题环节题目1求椭圆$x=a\cos\theta,y=b\sin\theta$所围图形面积. 解： 我们可以从格林公式中得到一个简单的应用： 当$P=-y,Q=x$时，公式就变成了 $$\begin{split}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y=2\iint\limits_D\mathtt{d}x\mathtt{d}y\end{split}$$ 也就是闭区域$D$的面积$A$为: $$\begin{split}A=\frac{1}{2}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y\end{split}$$ 那么求椭圆面积就变为了求解上述式子,有: $$\begin{split}A&amp;=\frac{1}{2}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y \\&amp;=\frac{1}{2}\int_0^{2\pi}{-b\sin\theta}\mathtt{d}{a\cos\theta}+a\cos\theta\mathtt{d}b\sin\theta \\&amp;=\frac{1}{2}\int_0^{2\pi}{ab\sin^2\theta}\mathtt{d}{\theta}+ab\cos^2\theta\mathtt{d}\theta \\&amp;=\frac{1}{2}ab·2\pi \\&amp;=ab\pi\end{split}$$]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
</search>
