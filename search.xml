<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Arduino怎么写呢]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2Farduino%2F</url>
    <content type="text"><![CDATA[但是这里是空的呀…… 空的就空的，这个东西好无聊的]]></content>
      <categories>
        <category>编程</category>
        <category>arduino</category>
      </categories>
      <tags>
        <tag>aruduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在c++中使用opengl]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2Fopengl%2F</url>
    <content type="text"><![CDATA[Shaders哪里放more,这里放more 如何偷懒，如何不偷懒关键字in和out是一个Shaders文件的输入和输出 vertex和fragment shader有一些不同 123in type in_variable_name;out type out_variable_name; 我们惊奇地发现，这个主题还支持glsl uniform是全局变量，后面的shader可以使用 1uniform type variable_name; Sampler通常在fragment shader中定义，是一个uniform类型的变量，但我不是很懂uniform了 取整和插值texelFetch1texelFetch(Sampler, vec2, lod); textureSizelod是什么意思呢level of detail, 有机会试试 百度百科： 多细节层次 LOG技术根据物体模型的节点在显示环境中所处的位置和重要度 给人一种放大缩小的感觉 12345uniform sampler2D texSlot;void main() &#123; vec2 texSize = textureSize(texSlot, 1);&#125; opengl很强]]></content>
      <categories>
        <category>编程</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>opengl</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习python]]></title>
    <url>%2Fblog%2F2018%2F10%2F16%2Flearning-py3%2F</url>
    <content type="text"><![CDATA[这个很难, python很难 Queue是一个线程安全的类吗 wrapper的一个用处，给函数打日志 12345678910111213141516171819import timefrom functools import wrapsdef log(func): @wraps(func) def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print("func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;".format(func.__name__, (args, kwargs), end_time - start_time, result)) return result return wrapper @logdef bar(): return "hello" if __name__ == '__main__': bar() 运行结果： 1func bar, param ((), &#123;&#125;), time 0.0, return hello function的属性 1__name__ 偏函数 Partial, 柯里化 Currying 补充一下刚才的代码 123456789101112131415161718192021222324252627import timefrom functools import wraps, partialdef logger(func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print("func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;".format(func.__name__, (args, kwargs), end - start, result)) return result return wrapper@loggerdef add(a, b): return a + badd3 = partial(add, 3)if __name__ == '__main__': print(add3.__class__) add3(2) 12&lt;class 'functools.partial'&gt;func add, param ((3, 2), &#123;&#125;), time 0.0, return 5 Uncurrying 1234567891011121314@loggerdef add(a): @logger def add(b): @logger def add(c): return a + b + c return add return addif __name__ == '__main__': print(add(1)(2)(3)) 1234func add, param ((1,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add at 0x0000001567C500D0&gt;func add, param ((2,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add.&lt;locals&gt;.add at 0x00000015678267B8&gt;func add, param ((3,), &#123;&#125;), time 0.0, return 66 如何写一个满足add(2)至无穷个括号的函数？0x0000001567C500D0是内存地址?可以操作内存吗? Generator 123456789a_generator = (item**2 for item in range(200))if __name__ == '__main__': print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) 12345014916 生成质数 1234567891011121314151617181920log_next = logger(next)def prime(): base = 2 while True: is_prime = True for j in range(2, int(math.sqrt(base)) + 1): if base % j == 0: is_prime = False break if is_prime: yield base base += 1if __name__ == '__main__': prime_generator = prime() for i in range(10): log_next(prime_generator) 12345678910func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 2func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 3func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 5func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 7func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 11func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 13func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 17func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 19func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 23func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 29 eval, compile,code ?]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp中的一些细节]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Ftcp%2F</url>
    <content type="text"><![CDATA[RTT(往返时延)RTT的估计和超时 tcp像很多其他的协议一样，超时的时候会重发，但是如何估计往返时间和设定超时时间是一个需要考虑的问题 估计往返时延segment里面有SampleRTT，计算方式是一个segment发出的时间，到ack收到的时间，对于重发的segment则不进行计算 显然这个值会因为网络状况产生一些波动，为了估计一个典型的RTT. TCP维护一个平均值，EstimatedRTT: $$\mathtt{EstimatedRTT}=(1-\alpha)·\mathtt{EstimatedRTT}+\alpha·\mathtt{SampleRTT}$$ 其中常用的$\alpha$值为$0.125$ DevRTTDevRTT是用来衡量SampleRTT波动程度的值，公式如下： $$\mathtt{DevRTT}=(1-\beta)·\mathtt{DevRTT}+\beta·\mid\mathtt{SampleRTT}-\mathtt{EstimatedRTT}\mid$$ EstimatedRTT和DevRTT都是一个EWMA(指数加权移动平均值) 计算重发间隔有了EstimateRTT和DevRTT，超时时间应当如何计算？首先它需要不小于EstimateRTT，但是又不能太大，防止延迟过高。所以设置方式通常是在EstimateRTT上加一个margin，这个margin的值需要根据SampleRTT的波动情况来设置。因此TCP采用的方式是: $$\mathtt{TimeoutInterval}=\mathtt{EstimatedRTT}+4·\mathtt{DevRTT}$$ 推荐使用的初始值则是1秒，当发生超时时，TimeoutInterval会倍增，直到它被重新计算。 可靠的数据传输TCP在IP协议的基础上提供了可靠的数据传输，解决了数据错误，丢包，重复和顺序错乱的问题。 TCP推荐只维护一个重发的计时器，尽管可能有很多还没有收到ACK的包 一个简化的模型123456789101112131415161718192021222324252627282930NextSeqNum=InitialSeqNumberSendBase=InitialSeqNumberloop (forever) &#123; switch(event) event: data received from application above create TCP segment with sequence number NextSeqNum if (timer currently not running) start timer pass segment to IP NextSeqNum=NextSeqNum+length(data) break; event: timer timeout retransmit not-yet-acknowledged segment with smallest sequence number start timer break; event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase = y if (there are currently any not-yet-acknowledged segments) &#123; start timer &#125; &#125; break;&#125; 有了上述的简化模型我们就可以进行一些场景模拟了 场景一 Host A向Host B发了一个包，seq=92, length=8 bytes, Host B向Host A发了一个ack=100,但是丢了 timer时间到了，Host A重发了这个包 Host B发现是收过的，直接给Host A发了ack=100 Host A收到，继续正常工作 场景二 Host A向Host B发了一个包，seq=92,length=8 bytes Host A向Host B发了一个包, seq=100,length=20 bytes Host B收到seq=92的包，发了一个ack=100 Host B收到seq=100的包，发了一个ack=120 两个ack包没能在超时前收到，Host A重发了seq=92的包 Host B收到seq=92的包，发了一个ack=120 Host A开始发seq=120的包，继续正常工作 场景三 Host A向Host B发了上述1.2.中的两个包 Host B发了一个ack=100，丢了 Host B发了一个ack=120 Host A在超时前收到了sck=120 Host A发送seq=120，继续正常工作 添加翻倍机制在上述的简化模型中，加入如下机制： 每当timeout重发时，将TimeoutInterval翻倍，可以在网络拥塞时产生一些效果 在CSMA/CD中你会看到类似的做法。 快速重传在简单的模型上进行修改，已达到如下效果： Host A向Host B连发了5个包 Host B收到了第一个包，并发送了ack=100 第二个包丢了 Host B在收到3,4,5时连发了三个ack=100 Host A的timer还没有超时，但收到三个duplicated ack了 Host A重发seq=100 12345678910111213event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase=y if (there are currently any not yet acknowledged segments) &#123; start timer &#125; &#125; else &#123; increment number of duplicate ACKs received for y if (number of duplicate ACKs received for y==3) &#123; resend segment with sequence number y &#125; &#125; break; 流控制(暂时略过)TCP连接管理这部分关注的是TCP连接的建立和断开 三次握手Step1客户端向服务端发起请求，带有SYN，并且随机选择一个Seq值x，把报文段发到服务端 Step2服务端收到报文段，分配TCP连接的缓冲区，初始化一些变量。服务端发送一个SYN报文给客户端，ack=x+1，seq为随机值y此报文称为SYNACK报文 Step3客户端收到SYNACK，分配缓冲区，初始化一些变量。向服务端发送ack=y+1,seq=x+1 四次挥手Step1客户端向服务端发送FIN报文 Step2服务端向客户端发送ACK报文 Step3服务端向客户端发送FIN报文 Step4客户端向服务端发送ACK报文。服务端收到ACK后将关闭，客户端等待一段时间后关闭 TCP的生命周期客户端]]></content>
      <tags>
        <tag>tcp</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法及应用]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fsort%2F</url>
    <content type="text"><![CDATA[占坑]]></content>
  </entry>
  <entry>
    <title><![CDATA[bochs的安装和使用]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fbochs%2F</url>
    <content type="text"><![CDATA[占坑]]></content>
  </entry>
  <entry>
    <title><![CDATA[java实现一个简单的apriori算法]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fapriori%2F</url>
    <content type="text"><![CDATA[占坑]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算PageRank]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fpage-rank%2F</url>
    <content type="text"><![CDATA[占坑]]></content>
  </entry>
  <entry>
    <title><![CDATA[奇异值分解的计算方式]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fsingular-value-decomposition%2F</url>
    <content type="text"><![CDATA[占坑]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何学习ruby]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fruby-learning%2F</url>
    <content type="text"><![CDATA[开发环境搭建]]></content>
      <tags>
        <tag>学习</tag>
        <tag>ruby</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习汉语]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fchinese-learning%2F</url>
    <content type="text"></content>
      <tags>
        <tag>学习</tag>
        <tag>汉语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习英语]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fenglish-learning%2F</url>
    <content type="text"><![CDATA[Redis在互联网公司一般有以下应用: String：缓存、限流、计数器、分布式锁、分布式Session Hash：存储用户信息、用户主页访问量、组合查询 List：微博关注人时间轴列表、简单队列 Set：赞、踩、标签、好友关系 Zset：排行榜]]></content>
      <tags>
        <tag>学习</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习算法]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Falgorithm-learning%2F</url>
    <content type="text"><![CDATA[我需要学习如下算法需要在45天内完成，那就11.14完成吧 快速排序 堆排序 归并排序 选择排序 并查集算法 图的遍历 有向图的DFS 无向图的DFS 最小生成树 图的最短路径 贪心算法 动态规划 NP完全问题 KMP算法 BM算法 近似匹配算法 传递闭包算法 中间值算法 对抗方法 分治算法 哈希算法]]></content>
      <tags>
        <tag>算法</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习c++]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fcpp-learning%2F</url>
    <content type="text"><![CDATA[to do list下面是我计划关注的方面 多态和继承 运算符重载 常用的库 函数模板和类模板 元编程 指针和引用 IO 网络编程 多线程 数据库 开发环境搭建打算使用windows上的能看文件结构的编辑器+在linux上编译执行 搭完了 最后还是用了mingw]]></content>
      <tags>
        <tag>学习</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习Java]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fjava-learning%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[如何学习后端]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fback-end-learning%2F</url>
    <content type="text"><![CDATA[我需要学习这些东西有时间做一个思维导图 数据库 hibernate redis 分布式 中间件 linux 网络协议 jvm 设计模式 消息队列]]></content>
      <tags>
        <tag>学习</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习前端]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Ffront-end-learning%2F</url>
    <content type="text"><![CDATA[我需要学习这些东西 CSS JS CSS3 H5 Ajax Grunt Gulp eslint Vue React React Native Angular babel Promise]]></content>
      <tags>
        <tag>前端</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三角级数相关]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Ftrigonometric-series%2F</url>
    <content type="text"><![CDATA[三角级数$\quad$一般地，以$A_k\sin(kx+\varphi_k)$为项作成的无穷级数 $$\sum\limits_{k=0}^{\infty}A_k\sin(kx+\varphi_k)$$ 称为三角级数.（所以首先三角级数都是无穷级数） 但是有时候也会取如下形式： $$\frac{a_0}{2}+\sum\limits_{k=1}^{\infty}(a_k\cos{kx}+b_k\sin{kx})。$$ 周期函数周期函数有初相,振幅,频率 正弦级数给三角级数中所有的$a_k$取$0$，可以得到如下的正弦级数: $$\sum\limits_{k=1}^{\infty}b_k\sin{kx}$$ 余弦级数类似的操作可以得到余弦级数 $$\frac{a_0}{2}+\sum\limits_{k=1}^{\infty}a_k\cos{kx}$$ 傅里叶级数$$\begin{split}A_n&amp;=\frac{1}{\pi}\int_0^{2\pi}f(x)\cos{nx}\mathtt{d}x \\B_n&amp;=\frac{1}{\pi}\int_0^{2\pi}f(x)\sin{nx}\mathtt{d}x\end{split}$$ 这里用的符号和上面不一样呢 应该打屁股]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
        <tag>级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曲线积分的意义]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fcurve-line-integral%2F</url>
    <content type="text"><![CDATA[曲线积分第一类曲线积分第一类曲线积分用来求一个曲线物体的质量.当物体的密度是一个常值时，只需要将密度乘以弧长就可以得到质量.当物体的密度不均匀时，我们将密度表示为函数$f$，并对函数在曲线上积分，称为第一类曲线积分或者对弧长的曲线积分,记为$\int_Cf(x,y)\mathtt{d}s$，即 $$\int_Cf(x,y)\mathtt{d}s=\lim_{\lambda\to{0}}\sum_{i=1}^nf(\xi_i,\eta_i)\Delta{s_i}$$ 其中$f(x,y)$称为被积函数,$C$称为积分曲线,$\mathtt{d}s$成为弧微分. 我们可以把这个概念扩展到三维空间或者更高维的空间中： $$\int_Cf(x,y,z)\mathtt{d}s=\lim_{\lambda\to{0}}\sum_{i=1}^nf(\xi_i,\eta_i,\zeta_i)\Delta{s_i}$$ 第二类曲线积分和第一类曲线积分不同，第二类曲线积分可以用来表示变力沿曲线做的功，是有方向的.第二类曲线积分记为: $$\int_CP(x,y)dx+Q(x,y)dy\quad或\quad\int_C\boldsymbol{F}(x,y)·\mathtt{d}\boldsymbol{r}$$ 特别地，还可以有对某个方向的曲线积分 沿曲线$C$对坐标$x$的曲线积分$$\int_CP(x,y)dx=\lim_{\lambda\to{0}}\sum_{i=1}^nP(\xi_i,\eta_i)\Delta{x_i}$$ 沿曲线$C$对坐标$y$的曲线积分$$\int_CQ(x,y)dy=\lim_{\lambda\to{0}}\sum_{i=1}^nQ(\xi_i,\eta_i)\Delta{y_i}$$ 既然如此，应该还可以对一个特定的方向积分，就是不知道怎么表示. 如果曲线$C$为闭曲线，则记第二类曲线积分为 $$\oint_CP(x,y)dx+Q(x,y)dy\quad或\quad\oint_C\boldsymbol{F}(x,y)·\mathtt{d}\boldsymbol{r}$$]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格林公式]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2FGreen-Formula%2F</url>
    <content type="text"><![CDATA[格林公式的定义和一些练习学习一下格林公式~ 简单闭曲线$\quad$设曲线$C$的参数方程为 $$\begin{cases}x=\varphi(t), \\y=\psi(t)\end{cases}\quad(\alpha\le{t}\le\beta).$$ 如果$\varphi,\psi$连续，且对不同的参数$t_1,t_2\in[\alpha,\beta]$(不妨设$t_1\le{t_2}$),$(\varphi(t_1),\psi(t_1))=(\varphi(t_2),\psi(t_2))$当且仅当$t_1=\alpha,t_2=\beta$,则称$C$为简单闭曲线 单连通区域$\quad$设有一个平面区域$D$,若$D$内的任意一条简单闭曲线所围的部分仍属于$D$，则称$D$为单连通区域，否则称为多连通区域. 格林公式$\quad$设有界闭区域$D$由逐段光滑曲线$C$围成，函数$P(x,y)$及$Q(x,y)$在$D$上具有一阶连续偏导数，则 $$\begin{split}\oint_C{P}\mathtt{d}x+Q\mathtt{d}y=\iint\limits_D\left(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}}\right)\mathtt{d}x\mathtt{d}y\end{split}$$ 用途通常这些东西总是有用的，我们观察上面的式子。 左边一部分是对光滑曲线$C$的第二类曲线积分，格林公式告诉我们它会与在由曲线围成的平面区域$D$上对两个方向的分量在另一个方向的偏导之差的积分相等. 证明为了加深理解，我们来看一下证明.证明格林公式的时候是拆开证的，也就是 $$\oint_CP\mathtt{d}x=-\iint\limits_D\frac{\partial{P}}{\partial{y}}\mathtt{d}x\mathtt{d}y, \quad\oint_CQ\mathtt{d}y=\iint\frac{\partial{Q}}{\partial{x}}\mathtt{d}x\mathtt{d}y$$ 分以下三种情况讨论: $D$由曲线$y=\varphi_1(x),y=\varphi_2(x)$，及直线$x=a,x=b$围成，即 $$D=\{(x,y)\mid\varphi_1(x)\le{y}\le\varphi_2(x),a\le{x}\le{b}\}$$ $D$是单连通区域，且与某些与$y$轴平行的直线相交多于两点 $D$是多联通区域 做题环节题目1求椭圆$x=a\cos\theta,y=b\sin\theta$所围图形面积. 解： 我们可以从格林公式中得到一个简单的应用： 当$P=-y,Q=x$时，公式就变成了 $$\begin{split}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y=2\iint\limits_D\mathtt{d}x\mathtt{d}y\end{split}$$ 也就是闭区域$D$的面积$A$为: $$\begin{split}A=\frac{1}{2}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y\end{split}$$ 那么求椭圆面积就变为了求解上述式子,有: $$\begin{split}A&amp;=\frac{1}{2}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y \\&amp;=\frac{1}{2}\int_0^{2\pi}{-b\sin\theta}\mathtt{d}{a\cos\theta}+a\cos\theta\mathtt{d}b\sin\theta \\&amp;=\frac{1}{2}\int_0^{2\pi}{ab\sin^2\theta}\mathtt{d}{\theta}+ab\cos^2\theta\mathtt{d}\theta \\&amp;=\frac{1}{2}ab·2\pi \\&amp;=ab\pi\end{split}$$]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
</search>
