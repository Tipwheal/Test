<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Three.js测试]]></title>
    <url>%2Fblog%2F2018%2F12%2F03%2Fthreejs-lab%2F</url>
    <content type="text"><![CDATA[#three-div { margin: 0 auto; width: 250px; padding: 0 !important; } #three-div br { display: none; } let scene = new THREE.Scene(); const height = 200; const width = 200; let camera = new THREE.PerspectiveCamera( 75, width/height, 0.1, 1000 ); let renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize( width, height ); renderer.setClearColor(0xffffff); document.querySelector('#three-div').appendChild( renderer.domElement ); //添加环境光 { var ambientLight = new THREE.AmbientLight( 0x707070 ); scene.add( ambientLight ); } //添加平行光 { var directionalLight = new THREE.DirectionalLight( 0xffffff ); directionalLight.position.set( 1, 0.75, 0.5 ).normalize(); scene.add( directionalLight ); } var axes = new THREE.AxesHelper(10); scene.add(axes); cube(); camera.position.z = 5; camera.position.x = 1; camera.position.y = 2; renderer.render( scene, camera ); function sphere() { let sphereGeo = new THREE.SphereGeometry(5, 40, 40); let sphereMat = new THREE.MeshLambertMaterial({ color:0x0000FF, wireframe:false }); let sphereMesh = new THREE.Mesh(sphereGeo, sphereMat); sphereMesh.position.set(3, 10, -15); scene.add(sphereMesh); } function cube() { let cube = new THREE.CubeGeometry(10, 10, 10, 1, 1, 1); let cubeMat = new THREE.MeshLambertMaterial({ color: 0xbbbbbb, wireframe: false }); let cubeMesh = new THREE.Mesh(cube, cubeMat); cubeMesh.position.set(-1, 5, -30); cubeMesh.rotation.y += 0.25 * Math.PI; cubeMesh.rotation.z += 0.15 * Math.PI; scene.add(cubeMesh); }]]></content>
      <tags>
        <tag>玩儿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebGL测试]]></title>
    <url>%2Fblog%2F2018%2F11%2F30%2Fwebgl-lab%2F</url>
    <content type="text"><![CDATA[#canvas-div { margin: 0 auto; width: 250px; padding: 0 !important; } #canvas-div br { display: none; } #canvas { margin: 0; } var cubeRotation = 0.0; main(); let mat4 = glMatrix.mat4; // // Start here // function main() { const canvas = document.querySelector('#canvas'); const gl = canvas.getContext('webgl'); // If we don't have a GL context, give up now if (!gl) { alert('Unable to initialize WebGL. Your browser or machine may not support it.'); return; } // Vertex shader program const vsSource = ` attribute vec4 aVertexPosition; attribute vec3 aVertexNormal; attribute vec2 aTextureCoord; uniform mat4 uNormalMatrix; uniform mat4 uModelViewMatrix; uniform mat4 uProjectionMatrix; varying highp vec2 vTextureCoord; varying highp vec3 vLighting; void main(void) { gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition; vTextureCoord = aTextureCoord; // Apply lighting effect highp vec3 ambientLight = vec3(0.3, 0.3, 0.3); highp vec3 directionalLightColor = vec3(1, 1, 1); highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75)); highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0); highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0); vLighting = ambientLight + (directionalLightColor * directional); } `; // Fragment shader program const fsSource = ` varying highp vec2 vTextureCoord; varying highp vec3 vLighting; uniform sampler2D uSampler; void main(void) { highp vec4 texelColor = texture2D(uSampler, vTextureCoord); gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a); } `; // Initialize a shader program; this is where all the lighting // for the vertices and so forth is established. const shaderProgram = initShaderProgram(gl, vsSource, fsSource); // Collect all the info needed to use the shader program. // Look up which attributes our shader program is using // for aVertexPosition, aVertexNormal, aTextureCoord, // and look up uniform locations. const programInfo = { program: shaderProgram, attribLocations: { vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'), vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'), textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'), }, uniformLocations: { projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'), modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'), normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'), uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'), }, }; // Here's where we call the routine that builds all the // objects we'll be drawing. const buffers = initBuffers(gl); const texture = loadTexture(gl, '/blog/images/avatar.jpg'); var then = 0; // Draw the scene repeatedly function render(now) { now *= 0.001; // convert to seconds const deltaTime = now - then; then = now; drawScene(gl, programInfo, buffers, texture, deltaTime); requestAnimationFrame(render); } requestAnimationFrame(render); } // // initBuffers // // Initialize the buffers we'll need. For this demo, we just // have one object -- a simple three-dimensional cube. // function initBuffers(gl) { // Create a buffer for the cube's vertex positions. const positionBuffer = gl.createBuffer(); // Select the positionBuffer as the one to apply buffer // operations to from here out. gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // Now create an array of positions for the cube. const positions = [ // Front face -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, // Back face -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, // Top face -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, // Bottom face -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, // Right face 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, // Left face -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, ]; // Now pass the list of positions into WebGL to build the // shape. We do this by creating a Float32Array from the // JavaScript array, then use it to fill the current buffer. gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW); // Set up the normals for the vertices, so that we can compute lighting. const normalBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer); const vertexNormals = [ // Front 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, // Back 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, // Top 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // Bottom 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, // Right 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // Left -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0 ]; gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW); // Now set up the texture coordinates for the faces. const textureCoordBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer); const textureCoordinates = [ // Front 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // Back 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // Top 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // Bottom 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // Right 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // Left 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, ]; gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW); // Build the element array buffer; this specifies the indices // into the vertex arrays for each face's vertices. const indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer); // This array defines each face as two triangles, using the // indices into the vertex array to specify each triangle's // position. const indices = [ 0, 1, 2, 0, 2, 3, // front 4, 5, 6, 4, 6, 7, // back 8, 9, 10, 8, 10, 11, // top 12, 13, 14, 12, 14, 15, // bottom 16, 17, 18, 16, 18, 19, // right 20, 21, 22, 20, 22, 23, // left ]; // Now send the element array to GL gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW); return { position: positionBuffer, normal: normalBuffer, textureCoord: textureCoordBuffer, indices: indexBuffer, }; } // // Initialize a texture and load an image. // When the image finished loading copy it into the texture. // function loadTexture(gl, url) { const texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); // Because images have to be download over the internet // they might take a moment until they are ready. // Until then put a single pixel in the texture so we can // use it immediately. When the image has finished downloading // we'll update the texture with the contents of the image. const level = 0; const internalFormat = gl.RGBA; const width = 1; const height = 1; const border = 0; const srcFormat = gl.RGBA; const srcType = gl.UNSIGNED_BYTE; const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel); const image = new Image(); image.onload = function() { gl.bindTexture(gl.TEXTURE_2D, texture); gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, image); // WebGL1 has different requirements for power of 2 images // vs non power of 2 images so check if the image is a // power of 2 in both dimensions. if (isPowerOf2(image.width) && isPowerOf2(image.height)) { // Yes, it's a power of 2. Generate mips. gl.generateMipmap(gl.TEXTURE_2D); } else { // No, it's not a power of 2. Turn of mips and set // wrapping to clamp to edge gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); } }; image.src = url; return texture; } function isPowerOf2(value) { return (value & (value - 1)) == 0; } // // Draw the scene. // function drawScene(gl, programInfo, buffers, texture, deltaTime) { gl.clearColor(1.0, 1.0, 1.0, 1.0); // Clear to black, fully opaque gl.clearDepth(1.0); // Clear everything gl.enable(gl.DEPTH_TEST); // Enable depth testing gl.depthFunc(gl.LEQUAL); // Near things obscure far things // Clear the canvas before we start drawing on it. gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Create a perspective matrix, a special matrix that is // used to simulate the distortion of perspective in a camera. // Our field of view is 45 degrees, with a width/height // ratio that matches the display size of the canvas // and we only want to see objects between 0.1 units // and 100 units away from the camera. const fieldOfView = 45 * Math.PI / 180; // in radians const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight; const zNear = 0.1; const zFar = 100.0; const projectionMatrix = mat4.create(); // note: glmatrix.js always has the first argument // as the destination to receive the result. mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar); // Set the drawing position to the "identity" point, which is // the center of the scene. const modelViewMatrix = mat4.create(); // Now move the drawing position a bit to where we want to // start drawing the square. mat4.translate(modelViewMatrix, // destination matrix modelViewMatrix, // matrix to translate [-0.0, 0.0, -6.0]); // amount to translate mat4.rotate(modelViewMatrix, // destination matrix modelViewMatrix, // matrix to rotate cubeRotation, // amount to rotate in radians [0, 0, 1]); // axis to rotate around (Z) mat4.rotate(modelViewMatrix, // destination matrix modelViewMatrix, // matrix to rotate cubeRotation * .7,// amount to rotate in radians [0, 1, 0]); // axis to rotate around (X) mat4.rotate(modelViewMatrix, // destination matrix modelViewMatrix, // matrix to rotate cubeRotation * .5,// amount to rotate in radians [1, 0, 0]); // axis to rotate around (X) const normalMatrix = mat4.create(); mat4.invert(normalMatrix, modelViewMatrix); mat4.transpose(normalMatrix, normalMatrix); // Tell WebGL how to pull out the positions from the position // buffer into the vertexPosition attribute { const numComponents = 3; const type = gl.FLOAT; const normalize = false; const stride = 0; const offset = 0; gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position); gl.vertexAttribPointer( programInfo.attribLocations.vertexPosition, numComponents, type, normalize, stride, offset); gl.enableVertexAttribArray( programInfo.attribLocations.vertexPosition); } // Tell WebGL how to pull out the texture coordinates from // the texture coordinate buffer into the textureCoord attribute. { const numComponents = 2; const type = gl.FLOAT; const normalize = false; const stride = 0; const offset = 0; gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord); gl.vertexAttribPointer( programInfo.attribLocations.textureCoord, numComponents, type, normalize, stride, offset); gl.enableVertexAttribArray( programInfo.attribLocations.textureCoord); } // Tell WebGL how to pull out the normals from // the normal buffer into the vertexNormal attribute. { const numComponents = 3; const type = gl.FLOAT; const normalize = false; const stride = 0; const offset = 0; gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal); gl.vertexAttribPointer( programInfo.attribLocations.vertexNormal, numComponents, type, normalize, stride, offset); gl.enableVertexAttribArray( programInfo.attribLocations.vertexNormal); } // Tell WebGL which indices to use to index the vertices gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices); // Tell WebGL to use our program when drawing gl.useProgram(programInfo.program); // Set the shader uniforms gl.uniformMatrix4fv( programInfo.uniformLocations.projectionMatrix, false, projectionMatrix); gl.uniformMatrix4fv( programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix); gl.uniformMatrix4fv( programInfo.uniformLocations.normalMatrix, false, normalMatrix); // Specify the texture to map onto the faces. // Tell WebGL we want to affect texture unit 0 gl.activeTexture(gl.TEXTURE0); // Bind the texture to texture unit 0 gl.bindTexture(gl.TEXTURE_2D, texture); // Tell the shader we bound the texture to texture unit 0 gl.uniform1i(programInfo.uniformLocations.uSampler, 0); { const vertexCount = 36; const type = gl.UNSIGNED_SHORT; const offset = 0; gl.drawElements(gl.TRIANGLES, vertexCount, type, offset); } // Update the rotation for the next draw cubeRotation += deltaTime; } // // Initialize a shader program, so WebGL knows how to draw our data // function initShaderProgram(gl, vsSource, fsSource) { const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource); const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource); // Create the shader program const shaderProgram = gl.createProgram(); gl.attachShader(shaderProgram, vertexShader); gl.attachShader(shaderProgram, fragmentShader); gl.linkProgram(shaderProgram); // If creating the shader program failed, alert if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) { alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram)); return null; } return shaderProgram; } // // creates a shader of the given type, uploads the source and // compiles it. // function loadShader(gl, type, source) { const shader = gl.createShader(type); // Send the source to the shader object gl.shaderSource(shader, source); // Compile the shader program gl.compileShader(shader); // See if it compiled successfully if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; } return shader; }]]></content>
      <tags>
        <tag>计算机图形学</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集一些变换矩阵]]></title>
    <url>%2Fblog%2F2018%2F11%2F29%2Ftransformation-metrix%2F</url>
    <content type="text"><![CDATA[下面的内容主要是收集一些二维/三维图形变换的矩阵，并尝试理解一下为什么。 二维图形变换显然，对一个二维图形做几何变换，就是对图形上的每一个点做相应的几何变换。虽然有时候实际上我们并不需要全部做，比如一个直线段我们只需要把端点变换过去然后连起来就可以了。 常见的二维图形几何变换有： 平移 缩放 旋转 二维齐次变换矩阵我们引入一个概念叫二位齐次变换矩阵，它可以用来进行二位图像的各种变换，如下： $$T_{2D}=\left(\begin{matrix}a &amp; d &amp; g \\b &amp; e &amp; h \\c &amp; f &amp; i \\\end{matrix}\right)$$ 我们可以从变换功能上把它分成四个部分: $$\left(\begin{matrix}a &amp; d \\b &amp; e \\\end{matrix}\right),\left(\begin{matrix}c &amp; f \\\end{matrix}\right),\left(\begin{matrix}g \\h \\\end{matrix}\right),\left(\begin{matrix}i \\\end{matrix}\right)$$ 其中：$\left(\begin{matrix}a &amp; d \\b &amp; e \\\end{matrix}\right)$是对图形进行比例、旋转、对称、错切等变换；$\left(\begin{matrix}c &amp; f \\\end{matrix}\right)$是对图形进行平移变换；$\left(\begin{matrix}g \\h \\\end{matrix}\right)$是对图形进行投影变换；$\left(\begin{matrix}i\end{matrix}\right)$是对图形整体做比例变换。 平移平移会用到的位置就是上述的$\left(\begin{matrix}c &amp; f \\\end{matrix}\right)$位置，然后其余部分按照单位矩阵补上就OK了，也就是： $$\boldsymbol{p’}=\left(\begin{matrix}x’ &amp; y’ &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}x &amp; y &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\T_x &amp; T_y &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}x+T_x &amp; y+T_y &amp; 1\end{matrix}\right)$$ $(x+T_x, y+T_y)$ $(x,y)$ let main = () => { let canvas = document.querySelector("#moveCanvas"); let ctx = canvas.getContext("2d"); ctx.beginPath(); ctx.moveTo(5, 100); ctx.lineTo(295, 100); ctx.stroke(); ctx.beginPath(); ctx.moveTo(30, 195); ctx.lineTo(30, 5); ctx.stroke(); ctx.setLineDash([3, 2]); ctx.strokeRect(25, 85, 60, 40); ctx.setLineDash([]); ctx.strokeRect(125, 35, 60, 40); ctx.beginPath(); ctx.arc(85,85,2,0,Math.PI*2,true); ctx.closePath(); ctx.fillStyle = "red"; ctx.fill(); ctx.beginPath(); ctx.arc(185,35,2,0,Math.PI*2,true); ctx.closePath(); ctx.fill(); } main(); 缩放缩放也很简单，只需要用到二维齐次变换矩阵中的$a,e$就可以了。 $$\boldsymbol{p’}=\left(\begin{matrix}x’ &amp; y’ &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}x &amp; y &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}S_x &amp; 0 &amp; 0 \\0 &amp; S_y &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}xS_x &amp; yS_y &amp; 1\end{matrix}\right)$$ $(xS_x, yS_y)$ $(x,y)$ main = () => { let canvas = document.querySelector("#scaleCanvas"); let ctx = canvas.getContext("2d"); ctx.beginPath(); ctx.moveTo(5, 100); ctx.lineTo(295, 100); ctx.stroke(); ctx.beginPath(); ctx.moveTo(30, 195); ctx.lineTo(30, 5); ctx.stroke(); ctx.setLineDash([3, 2]); ctx.strokeRect(25, 85, 60, 40); ctx.setLineDash([]); ctx.strokeRect(20, 70, 120, 80); ctx.beginPath(); ctx.arc(85, 85, 2, 0, Math.PI*2, true); ctx.closePath(); ctx.fillStyle = "red"; ctx.fill(); ctx.beginPath(); ctx.arc(140, 70, 2, 0, Math.PI*2, true); ctx.closePath(); ctx.fill(); } main(); 旋转旋转时，我们假设逆时针旋转了$\theta$，很容易可以得到如下关系： （用$x’=t\sin(\alpha+\theta)$这种方式或者 比较麻烦的方式） $$\boldsymbol{p’}=\left(\begin{matrix}x’ &amp; y’ &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}x &amp; y &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}\cos{\theta} &amp; \sin{\theta} &amp; 0 \\-\sin{\theta} &amp; \cos{\theta} &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)=\left(\begin{matrix}x\cos{\theta}-y\sin{\theta} &amp; x\sin{\theta}+y\cos{\theta} &amp; 1\end{matrix}\right)$$ $(x\cos\theta-y\sin\theta, x\sin\theta+y\cos\theta)$ $(x,y)$ $\theta$ main = () => { let canvas = document.querySelector("#rotateCanvas"); let ctx = canvas.getContext("2d"); ctx.beginPath(); ctx.moveTo(5, 180); ctx.lineTo(295, 180); ctx.stroke(); ctx.beginPath(); ctx.moveTo(30, 195); ctx.lineTo(30, 5); ctx.stroke(); ctx.setLineDash([7, 2]); ctx.beginPath(); ctx.moveTo(30, 180); ctx.lineTo(170, 125); ctx.stroke(); ctx.beginPath(); ctx.moveTo(30, 180); ctx.lineTo(122.69, 62.78); ctx.stroke(); ctx.setLineDash([3, 2]); ctx.beginPath(); ctx.moveTo(150, 150); ctx.lineTo(230, 140); ctx.lineTo(170, 125); ctx.lineTo(150, 150); ctx.stroke(); ctx.setLineDash([]); ctx.beginPath(); ctx.moveTo(118.02, 94.25); ctx.lineTo(181.7, 45.66); ctx.lineTo(122.69, 62.78); ctx.lineTo(118.02, 94.25); ctx.stroke(); ctx.beginPath(); ctx.arc(122.69, 62.78, 2, 0, Math.PI*2, true); ctx.closePath(); ctx.fillStyle = "red"; ctx.fill(); ctx.beginPath(); ctx.arc(170, 125, 2, 0, Math.PI*2, true); ctx.closePath(); ctx.fill(); } main(); 对称首先我们会讨论一下关于坐标轴或者某些简单的直线对称的变换矩阵，然后再通过变换的组合来完成对任意直线的对称变换。 关于坐标轴对称当一个图形关于$x$轴对称时，我们只需要将$y$变为原来的相反数即可，因此有以下矩阵： $$\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; -1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 关于$y$对称则是： $$\left(\begin{matrix}-1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 关于原点对称也就是两个坐标都取相反数： $$\left(\begin{matrix}-1 &amp; 0 &amp; 0 \\0 &amp; -1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 关于$y=x$或者$y=-x$对称关于$y=x$对称时，实际上是将$x$和$y$对调，即$y’=x,x’=y$，因此： $$\left(\begin{matrix}0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 那么如果是$y=-x$，我们有： $$\left(\begin{matrix}0 &amp; -1 &amp; 0 \\-1 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 关于直线$y=kx+b$对称上面提到的几个都比较容易理解…不过当对一条长得比较随意的直线对称的时候就没那么好直接写出来了。 我们可以把变换分解一下。 我们可以通过平移，旋转和简单的对称来组合成一个比较复杂的变化。 比如这条$y=kx+b$,截距是$b$,我们可以先将点在$y$轴上挪动$-y$,然后关于$y=kx$对称,结束后再往回挪动即可。 因此有： $$\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; -b &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}? &amp; ? &amp; 0 \\? &amp; ? &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; b &amp; 1 \\\end{matrix}\right)$$ 那么中间的一部分就是关于$y=kx$对称的矩阵，我们要如何得到它呢。 $y=kx$时我们假设直线与$x$轴的夹角为$\theta$，（从$x$轴开始两个方向旋转,$\theta$的范围是$(-\frac{\pi}{2},\frac{\pi}{2})$） 我们有$k=\tan{\theta}$,即$\theta=\arctan{k}$,可以知道$y=kx$是$x$轴旋转了$\theta$后得到的直线。 因此我么可以先将点旋转$-\theta$,再关于$x$轴对称，最后再旋转$\theta$即可，有： $$\left(\begin{matrix}\cos{\theta} &amp; -\sin{\theta} &amp; 0 \\\sin{\theta} &amp; \cos{\theta} &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; -1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)\left(\begin{matrix}\cos{\theta} &amp; \sin{\theta} &amp; 0 \\-\sin{\theta} &amp; \cos{\theta} &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 即 $$\left(\begin{matrix}\cos{2\theta} &amp; \sin{2\theta} &amp; 0 \\\sin{2\theta} &amp; -\cos{2\theta} &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}\right)$$ 是一个美美的式子呢。 我们再代回刚才的$?$号矩阵，可以得到： $$\left(\begin{matrix}\cos{2\theta} &amp; \sin{2\theta} &amp; 0 \\\sin{2\theta} &amp; -\cos{2\theta} &amp; 0 \\-b\sin{2\theta} &amp; b(\cos{2\theta}+1) &amp; 1 \\\end{matrix}\right)$$ 这就是我们的对称矩阵了，其中$\theta=\arctan{k}$ 三维图形变换 .canvas-div { position: relative; z-index: 1; margin: 0 auto; padding: 0; width: 300px; } .canvas-top { position: absolute; top: 0; margin: 0 auto; width: 300px; z-index: 99; font-size: 0.7rem; } #c1 { padding: 14px 0 0 130px; } #c2 { padding: 60px 0 0 60px; } #c3 { padding: 45px 0 0 110px; } #c4 { padding: 75px 0 0 90px; } #c5 { padding: 25px 0 0 90px; } #c6 { padding: 95px 0 0 140px; } #c7 { padding: 150px 0 0 50px; } .canvas-div br { display: none; }]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>矩阵</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件过程管理瞎复习中]]></title>
    <url>%2Fblog%2F2018%2F11%2F28%2Fgoupi5%2F</url>
    <content type="text"><![CDATA[假装没有东西 质量评价的方法我们可以通过实施度量和分析活动来进行质量评价 度量元 度量时间 度量缺陷 度量规模 CMM和CMMI他们是干嘛的呢 CMMCapability Maturity Model, 能力成熟度模型 五个等级 Initial 原始级别 Repeatable 可重复以前的主要经验 Defined 已定义级 Managed 已管理级 Optimizing 优化级 CMMICapability Maturity Model Integration, 能力成熟度模型集成 CMMI是一个过程改进的模型，不是开发模型 五个等级 Initial 原始级别 Managed 已经管理 Defined 已经定义 Quantitively Managed 定量管理 Optimizing 持续优化 A/FRA/FR是质检过失比，即质检质量成本/过失质量成本，用来测量在第一次编译前花在查找缺陷上的时间的相对值。 可以用复查时间/(编译+测试)时间来计算。 一些值当A/FR&lt;1时，程序测试一般会发现很多错误。当A/FR&gt;2时，过程产生无缺陷的可能性更大。 PQIPQI是5个数据的乘积 设计质量：设计的时间应该大于编码的时间 设计评审质量：设计评审的时间应该大于设计时间的50% 代码评审质量：代码评审时间应该大于编码时间的50% 代码质量：代码的编译缺陷密度应当小于10个/千行 程序质量：代码单元测试缺陷密度应当小于5个/千行 PQI越大，质量越高 Review Rate在PSP实践中，代码评审速度小于200LOC/小时，文档评审速度小于4Page/小时。 DRL 缺陷消除效率比缺陷消除效率比度量的是不同缺陷消除手段消除缺陷的效率。 计算方式是以某个测试阶段，一般是单元测试阶段，每小时发现的缺陷数为基础，其他阶段每小时发现的缺陷数与该测试阶段每小时发现的缺陷数的比值就是DRL。 YieldYield也是一个质量指标。 Yield用以度量每个阶段在消除缺陷方面的效率。 Phase Yield是某阶段发现的缺陷个数/(某阶段注入的缺陷个数+进入该阶段前遗留的缺陷个数)的百分比。 Process Yield是第一次编译前发现的缺陷个数/第一次编译前注入的缺陷个数。 PSP的质量策略 用缺陷管理来替代质量管理 高质量产品也就意味着要求组成软件产品的各个组件基本无缺陷 各个组件的高质量是通过高质量评审来实现的 GQM(Goal Question Measure)一个完整的GQM过程 先期调研 制定GQM目标 产生GQM计划 产生测量计划 收集整理数据 数据分析 打包 最能体现GQM思想的步骤 制定GQM目标 产生GQM计划 三个层 概念层(Goal) 操作层(Question) 量化层(Measure) 概念层目标是为某个特定对象定义的。这里的对象是指软件产品、软件过程以及相关的资源等。 操作层刻画上述目标是否达成或者达成的进展的模型，使用一系列问题来定义所研究的对象。 量化层试图以量化的方式回答上述操作层识别出来的问题。 产品组建集成策略 大爆炸 逐一添加 集簇集成 扁平化集成 大爆炸将所有已经完成的组件放在一起，进行一次集成 优点需要的测试用例最少 缺点需要待集成的组件具有较高的质量 逐一添加一次添加一个组件的集成 优点很容易定位缺陷的位置 缺点可能需要最多的测试用例 集簇集成把功能相关联的组件优先进行集成，形成可以工作的组件。 优点可以尽早获得可以工作的组件，有利于其他组件测试工作的开展 缺点过于关注个别组件，缺乏系统的整体观，不能尽早发现系统层面的缺陷 扁平化集成要求尽快构建一个可以工作的扁平化系统。优先集成高层的部件，然后逐步将各个组件、模块的真正实现加入系统。 优点有系统的整体观 缺点需要打大量的桩，提供伪实现。这种方式往往不能覆盖整个系统应该处理的多种状态。 PROBE估算流程概要设计 代理识别和代理规模 估算并调整程序规模 估算并调整资源 计算预测区间 计算预测区间 不好背啊 项目计划框架 客户需求 定义需求 概要设计 规模估算 资源估算 日程计划 开发产品 交付产品 规模历史数据 生产效率历史数据 团队资源水平 规模、资源、日程数据收集 过程分析 跟踪报告 管理层 质量保证活动 个人评审 团队评审 单元测试 集成测试 系统测试 验收测试 自主型团队含义软件工程师所从事的工作一般称之为复杂的知识工作。在这种性质的工作中，实现软件工程师自我管理往往可以获得最好的工作效率和质量水平。如果整个团队的所有成员都实现了自我管理，也就形成了所谓的自主团队。 特点 自行定义项目的目标 自行决定团队组成形式以及成员的角色 自行决定项目的开发策略 自行定义项目的开发过程 自行制定项目的开发计划 自行度量、管理和控制项目工作 必要性自主团队可以形成“胶冻状团队”。在这样的团队中存在一种神奇的力量，这种神奇力量弥漫于该团队的所有工作。团队成员互相支持，更为重要的是，团队成员在任何时刻都知道应该以怎样的方式帮助别人；团队成员相互信任，有强烈的归属感；团队在适当的时候会聚集在一起，研究现状，讨论策略。 不同人的观点和贡献Shewhart 质量改进的奠基人 提出过程控制概念 提出Plan-Do-See的概念，戴明将其发展为PDCA Deming 质量改进，提出质量改进的思想，被日本工业界采用 提出PCDA循环，(Plan, Do, Check, Action) 提出十四点原则 Juran 编写《质量控制手册》，被称为质量控制科学的圣经 奠定全面质量管理TQM的理论基础和基本方法做出了卓越的贡献，提出了Juran质量螺旋 Crosby 提出了零缺陷的概念，即第一次就把事情做对 发展质量成熟度的量化 Humphrey 将上述理论引入软件过程 提出了CMM软件能力成熟度模型 敏捷方法的特征精益精益生产，是衍生自丰田生产方式的一种管理哲学。 基本思想Just In Time 特征 追求零库存 追求快速反应，即快速应对市场的变化 企业内外环境的和谐统一 人本主义 库存是祸根 敏捷开发主要体现小周期迭代式持续交付 价值观 小周期迭代 快速响应变更 价值交付 自动化 敏捷开发宣言的4个简单的价值观 个体和交互 胜过 过程和工具 可以工作的软件 胜过 面面俱到的文档 客户合作 胜过 合同谈判 响应变化 胜过 遵循计划 IDEAL五个阶段 Initializing,开始 Diagonizing,诊断、评价 Establishing,建立 Acting,执行 Leveraging,调整]]></content>
      <tags>
        <tag>呵呵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件过程与管理Part4 PSP]]></title>
    <url>%2Fblog%2F2018%2F11%2F27%2Fgoupi4%2F</url>
    <content type="text"><![CDATA[假装没有东西 PSP 个人软件过程 PSP简介 流程 度量 PROBE估算方法讨论 PSP中的质量管理 PSP的渊源和作用 过程改进运动 TQM Humphrey早期工作 PSP/TSP 百度归来： 软件过程改进叫SPI(Software Process Improvement)TQM是Total Quality Management, 全面质量管理Watts Humphrey 1986年在软件过程中采用Crosby的成熟度量化，加入成熟度等级的概念。而Phil Crosby是在1980年**了发展质量成熟度的量化。Personal Software Process和Team Software Process。 软件过程改进 软件过程改进，就是在软件过程工程中为了更有效地达到优化软件过程的目的同时改善或改变其软件过程的一系列活动。 PSP的作用 个人级管理实践和过程估算和计划 承诺和拒绝承诺 理解和改进 工业水准的过程和规范 客观决策的数据 什么是PSPPSP的过程度量GQM是什么呢Goal, Question, Metric 但我不知道是干什么的 PSP基本度项 规模 时间 缺陷 日程(TSP) PSP的阶段PSP阶段是说我们用PSP开发的时候把我们的过程分成了几个阶段，如下： 策划 设计 编码 编译 单元测试 总结 万一我不需要编译呢 PSP中的日志时间日志时间日志需要记录一些东西 序号 所属阶段 开始时间 结束时间 中断时间 净时间 备注信息 缺陷日志 序号 发现日期 注入阶段 消除阶段 消除时间 关联缺陷 简要描述 规模度量的困境 精确的度量方式往往不便于早期规划 有助于早期规划的度量往往难以产生精确度量结果 Line of Code VS Function Point PROBE的作用 PROBE即Proxy Based Estimation 三种历史数据的处理方式 简单方法 正态分布 对数正态分布 简单方法基本思想是： 将每个方法的代码行数进行排序 选择最小值作为VS 选择最大值作为VL 选择中值作为M 选择VS与M的均值作为S 选择VL与M的均值作为L 正态分布均值作为$M$，所有数据的标准差为$\sigma$,有： $$\begin{split}S&amp;=M-\sigma \\VS&amp;=M-2\sigma \\L&amp;=M+\sigma \\VL&amp;=M+2\sigma \\\end{split}$$ 对数正态分布以$e$为底计算所有数据的自然对数，然后按照正态分布中的处理方式处理。 三种方法的对比 简单方法计算简单，但是不稳定 正态分布法相对稳定，在历史数据基本符合正态分布的情况下，可以给出非常好的相对大小矩阵 对数正态分布法更加符合人们对于程序的规模的直观感觉 相关性相关性描述的是两组变化的数据之间相互关联的程度。 在PSP中，为了确保估算质量，对于历史数据的相关性要求$r\le{0.7}$ $$r_{x,y}=\frac{n\left(\sum\limits_{i=1}^nx_iy_i\right)-\left(\sum\limits_{i=1}^nx_i\right)\left(\sum\limits_{i-1}^ny_i\right)}{\sqrt{\left[n\left(\sum\limits_{i=1}^nx_i^2\right)-\left(\sum\limits_{i=1}^nx_i\right)^2\right]\left[n\left(\sum\limits_{i=1}^ny_i^2\right)-\left(\sum\limits_{i=1}^ny_i\right)^2\right]}}$$ 显著性显著性描述的是两组数据的相关关系出现的偶然性，显著性越小越好。 在PSP中，要求显著性$s\le{0.05}$ PSP的不同级别PSP0 基本过程 时间日志 缺陷日志 缺陷类型标准 PSP0.1 编码规范 代码行统计规范 过程改进提案 PSP1 PROBE计算 测试报告 PSP1.1 任务计划 日程计划 PSP2 代码复查 设计复查 PSP2.1 设计模板 TSP(PSP3.0) 小组开发 通用计划框架客户需求-&gt;定义需求-&gt;概要设计-&gt;规模估算-&gt;资源估算-&gt;日程计划-&gt;开发产品-&gt;交付产品-&gt;回到客户需求 这是一个圈圈。除此之外还要干不少事情。 算了不会画图]]></content>
      <tags>
        <tag>呵呵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件过程与管理part3]]></title>
    <url>%2Fblog%2F2018%2F11%2F27%2Fgoupi3%2F</url>
    <content type="text"><![CDATA[假装没有东西 软件过程的历史演变和经典工作当前软件发展现状软件应用的典型特征 进一步服务化和网络化 用户需求多样性进一步凸显 软件产品和服务的地位变化 错综复杂的部署环境 近乎苛刻的用户期望 多： 功能丰富 快： 快速使用，及时更新 好： 稳定，可靠 省： 用户获得的成本低，最好免费 软件开发的典型特征 空前强大的开发和部署环境————XaaS IaaS PaaS SaaS,FaaS 盛行共享文化 潜在支撑获得了长足进步（AI, Bigdata, Cloud） 典型DevOps实践和方法 方法论基础是敏捷软件开发、精益思想以及看板Kanban方法 以领域驱动设计为指导的微服务架构方式 大量虚拟化技术的使用 一切皆服务XaaS(X as a service)的理念指导 构建了强大的工具链，支持高水平自动化]]></content>
      <tags>
        <tag>呵呵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神摸是隐马尔可夫模型(Hidden Markov Model)]]></title>
    <url>%2Fblog%2F2018%2F11%2F24%2Fhidden-markov-model%2F</url>
    <content type="text"><![CDATA[举个栗子隐马尔可夫模型可以描述很多场景。 里面大概有这么些东西： 一个可以观测到的可见状态链$X_0,\dots,X_{n-1},X_n$ 一个隐含状态链$Y_0,\dots,Y_{n-1},Y_n$ 几个隐含状态和它们之间的转换概率 从隐含状态到可见状态的发射概率 一个不好理解的例子一个不好理解的例子是，我们看到了一个序列[1, 2, 5, 7, 2, 3, 2],隐马尔可夫模型认为它有一个对应的隐含序列[a, c, b, c, a, c, b],我们观测到的序列，是在隐含序列以这样的顺序发生时，其中的每一个隐含状态以一个概率触发了对应的可见状态，而隐含状态之间的转换也有对应的概率。这里隐含状态的数量有$4$个，对应的转换概率我们没有说。 一个好一些的例子我们举一个好理解的例子是，一个人最近几天做的主要事情是： 逛街，浇花，在家看电视，散步，浇花，散步，在家看电视。 我们知道的是不同的天气下，人干出这些事情的概率是不一样的，所以我们可能会对一个隐含状态链感兴趣，也就是这几天的天气。(我们不知道或者忘记了天气，只知道这个人干了什么) 天晴的时候可能会有比较大的概率去浇花逛街散步，下雨的时候可能就是在家看电视，阴天又是另一个情况。 假设我们已经知道了，隐含状态有3种： 阴天、雨天、晴天。 我们也知道这三种天气下，一个人干这些事情的概率，这个就是从隐含状态到可见状态的发射概率。 我们还观察了天气变化的规律，统计出了不同的天气互相转换的概率(假设事情就是这样的)，那么这个就是隐含状态的转换概率。比如雨天有$50\%$的概率变成雨天,有$20\%$的概率变成晴天之类的。 当然天气的互相转换在这里是被简化过的，如果我们再加上一点复杂的东西，这个模型就更复杂了，暂时不考虑这个。 那么隐马尔可夫模型就是描述这样的一个模型，其中的隐含状态链又称为马尔可夫链。 在这个模型中主要关心的问题如下： HMM中的三种问题已知隐含状态数量，转换概率和可见状态链，求隐含状态链我们现在知道了不同天气的转换概率，和不同天气下人做不同事情的概率，现在看到一个人这几天做了这些事情，想知道这几天的天气最可能是怎么样的。 (然后我们会用一个$\mathrm{Viterbi}$算法来解决这个问题，如果有人想穷举并且感觉会炸然后毫无头绪的话可以了解一下这个做法) 当然我们是求不同情况产生这一个可见状态序列的概率，取其中最大的一个。 已知隐含状态数量，转换概率和可见状态链，求这个结果的概率我们现在知道了不同天气的转换概率，和不同天气下人做不同事情的概率，现在看到一个人这几天做了这些事情，开始想：总觉得我们的这个天气转换的概率是不对的，或者不同天气下人做这些事情的概率是有问题的。那么我们可以看看在我们已知的模型下，这个人可能做出这个结果的概率。如果这个概率很小，还有其他结果的概率比它大，甚至大得多，很可能是我们的模型出了问题。 这个问题可能在这个例子中没那么有必要，假设我们是在一个赌场赌博，怀疑人家的骰子有问题的时候也许就可以用上了。 已知隐含状态数量和可见状态链，求转换概率这个问题是…我们知道了有几个天气，不同天气下人做一些事情的概率，现在想知道天气之间互相转换的概率最可能是怎么样的… 这个问题有、复杂，也就是我们要看通过观测的序列来完善我们的模型。]]></content>
      <categories>
        <category>隐马尔可夫模型</category>
      </categories>
      <tags>
        <tag>隐马尔可夫模型</tag>
        <tag>自然语言处理</tag>
        <tag>HMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LSTM-CRF模型]]></title>
    <url>%2Fblog%2F2018%2F11%2F24%2Flstm-crf%2F</url>
    <content type="text"><![CDATA[介绍LSTM-CRF是一个用于命名实体识别的内嵌CRF的LSTM模型。 好处呢循环神经网络解决了传统神经网络只依赖于当前输入的问题。长短时记忆网络模型解决了循环神经网络由于梯度爆炸或消失只能学习到短周期的依赖关系问题。 记忆单元LSTM模型通过引入一组记忆单元使得神经网络具有学习遗忘历史信息的能力。 在时刻$t$，记忆单元$c_t$记录了当前时刻为止的所有历史信息，并受三个门的控制： 输入门$i_t$ 遗忘门$c_t$ 输出门$o_t$ 有下列一组计算公式，是peeholes convolutional LSTM的式子 $$\begin{split}i_t&amp;=\sigma(W_ix_t+U_ih_{t-1}+V_ic_{t-1}), \\f_t&amp;=\sigma(W_ix_t+U_fh_{t-1}+V_fc_{t-1}), \\o_t&amp;=\sigma(W_ox_t+U_oh_{t-1}+V_oc_{t}), \\\widetilde{c}_t&amp;=\tanh(W_cx_t+U_ch_{t-1}+b_c), \\c_t&amp;=f_t\odot{c}_{t-1}+i_t\odot\widetilde{c}_t, \\h_t&amp;=o_t\odot\tanh(c_t)\end{split}$$ 其中，$x_t$是当前时刻的输入，$\sigma$是$\mathrm{logistic}$函数，也就是$\mathrm{sigmoid}$(如下)，$V_i$,$V_f$,$V_o$是对角矩阵。 $$\sigma(x)=\frac{1}{1+e^{-x}}$$ $c_t$指cell在t时刻的状态，$\widetilde{c}_t$是对输入和上一时刻的状态进行处理后的值。 那么$W$和$U$又是什么呢？ $W$是对于输入值$x$的权重，$U$则是对于从输出返回来的输入$h$的权重。 我们先看一组简单一点的LSTM式子： $$\begin{split}i_t&amp;=\sigma(W_ix_t+U_ih_{t-1}+b_i), \\f_t&amp;=\sigma(W_ix_t+U_fh_{t-1}+b_f), \\o_t&amp;=\sigma(W_ox_t+U_oh_{t-1}+b_o), \\\widetilde{c}_t&amp;=\tanh(W_cx_t+U_ch_{t-1}+b_c), \\c_t&amp;=f_t\odot{c}_{t-1}+i_t\odot\widetilde{c}_t, \\h_t&amp;=o_t\odot\tanh(c_t)\end{split}$$ 我们可以看到输入门，遗忘门和输出门的值，都是由当前输入乘上输入权重，上一轮的输出乘上对应的权重，和一个偏置项的和，套上一层$\mathrm{sigmoid}$组成的。而计算Cell状态$c$时，引入的$\widetilde{c}_t$也有类似的权重加偏置项，然后使用$\tanh$激活。$c$的计算是对上一回$c$的状态和遗忘门使用madamard积，也就是将对应的位置乘起来，而我们的遗忘门经过了sigmoid之后是$(0,1)$之间的值，这么一乘就可以以一定的比例“遗忘”上一回的状态。除了遗忘之外，我们还需要将新的输入也加上，这一个项$i_t\odot\widetilde{c}_t$使用输入门和$\widetilde{c}_t$求madamard积获得。最后是这一层的输出$h$则是用输出门与$c_t$求madamard积。$c_t$可以使用$\tanh$激活，也可以不使用。 初始化时，$h_0$和$c_0$均为0。 我们根据上面的一通分析可以描述一下$\mathrm{LSTM}$的结构: 有一个Cell $c$,初始状态都是0,每一时刻的输入来自输入和自身在前一时刻的状态$c_{t-1}$经过的一些处理。 其中的输入来源有实际输入和上一次的输出。他们分别乘上对应的权重后，与一个偏置项求和，使用$\tanh$激活后再经过一层输入门，就成为了输入。 而自身上一次的状态则需要经过遗忘门。 最终这一个时刻的输出$h_t$则是由Cell状态$c$经过输出门得到的结果，而下一时刻输入门，输出门，遗忘门包括Cell再计算输入时，都会使用到这一个$h_t$。 因此这是一个循环的结构并且(如果训练得当)我们可以看出一次输出可能会受到很久以前的输入的影响，也许我应该看看为什么传统的RNN会产生梯度爆炸/消失而这个不会。 LSTM-CRF模型啊……哦……这里是空的。 我们看完了LSTM但并不知道如何在其中嵌入一个CRF模型]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>自然语言处理</tag>
        <tag>神经网络</tag>
        <tag>LSTM</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名实体识别]]></title>
    <url>%2Fblog%2F2018%2F11%2F24%2Fname-entities-recognition%2F</url>
    <content type="text"><![CDATA[收集一些命名实体识别相关的知识 收集一下名词 条件随机场CRF 召回率 F值 viterbi算法 序列标注任务 最大似然迭代算法 MEMM标记偏置 线性条件随机场 层叠条件随机场 前向后向算法 N-最短路径的切分排歧策略 互信息 二值特征函数 L-BGFS算法 牛顿方法 收集一些工具 CRF++ 收集一些言论文本信息抽取是自然语言处理及文本挖掘领域的一个研究热点。命名实体识别是信息抽取的子任务 主要任务 人名 地名 时间、日期 主要方法 基于规则的方法 基于统计的方法 基于神经网络的方法 语料库 《人民日报》语料库 基于规则的方法构建词规则及句法规则，采用匹配算法自动识别。 基于统计的方法 最大熵模型 隐马尔科夫模型 条件随机场模型 条件随机场模型条件随机场模型(Conditional Random Field,CRF)是一种概率无向图模型。属于判别模型。 摘抄一个 线性链条件随机场模型 在序列标注任务中，随机变量$X=X_1,\dots,X_{n-1},X_n$是观察序列，随机变量$Y=Y_1,\dots,Y_{n-1},Y_n$表示与观察序列相对应的标记序列。 引入两个函数$t_k$和$s_k$ $t_k(y_{i-1},y_i,x,i)$是从位置$i$到位置$i-1$的转移特征函数，$s_k(y_i,x,i)$是位置$i$的状态特征函数，$\lambda_k$、$\mu_k$是相应的权重。 下面一个是随机变量$Y$的链接条件概率分布： $$P(Y\vert{X})=\frac{1}{Z(x)}\exp\left(\sum\limits_i\sum\limits_k\lambda_kt_k(y_{i-1},y_i,x,i)+\sum\limits_i\sum\limits_k\mu_ks_k(y_i,x,i)\right)$$ 其中 $$Z(x)=\sum\limits_y\exp\left(\sum\limits_i\sum\limits_k\lambda_kt_k(y_{i-1},y_i,x,i)+\sum\limits_i\sum\limits_k\mu_ks_k(y_i,x,i)\right)$$ $\lambda_k$和$s_k$需要从训练样本中学习得出。 $Z(x)$是一个仅依赖于观测序列$X$的归一化函数。 在序列标注的过程中，条件随机场模型使用$\mathrm{Viterbi}$方法寻找使$P(Y\vert{X})$最大的$Y^*$,即$Y^*=\max_YP(Y\vert{X})$ 这两个东西看起来有一、复杂 依存句法分析依存句法分析（Dependency Parsing）是一种语言结构，它通过分析语言单位内成分之间的依存关系揭示其语法结构，描述句中词和词之间存在的支配与被支配的依存关系，鉴于依存分析可以找出句子各成分之间的语义修饰关系，因此，可以得到长距离的搭配信息，而且依存分析和句子成分的物理位置无关，更倾向于人的语言直觉，能够提供更精确的结果，因此，依存分析技术得到人们的广泛关注。 P,R,F的关系准确率$P$,就是$\frac{其中预测正确的数量}{预测是某个类型的实体的数量}$召回率$R$,就是$\frac{预测到的正确的数量}{所有的正确的数量}$$F$值,计算方式:$\frac{2\times{P}\times{R}}{P+R}$ 新词的发现方式主要有两类方法： 在大规模训练语料的基础上，使用统计方法确定新的单词边界，从而获得候选的单词 在缺乏大规模训练语料，对实验数据文本中的字符串进行频率统计，词频高于阈值的词语作为候选新词 条件随机场中的层叠模型和层次模型 层叠模型(CCRFs)是将多个模型进行线性组合 层次模型采用递归方式将低层模型嵌入高层模型 层次模型训练复杂度和解码复杂度远远高于层叠模型。 参考文献： [1]杨晓燕,徐戈,谢安,庄泽彬.基于词典与条件随机场的中文菜名识别研究[J].电脑知识与技术,2018,17:91-93.[2]周俊生,戴新宇,尹存燕,陈家骏.基于层叠条件随机场模型的中文机构名自动识别[J].电子学报,2006,5:804-809]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>自然语言处理</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假装复习软件过程管理]]></title>
    <url>%2Fblog%2F2018%2F11%2F23%2Fsoftware-process-management%2F</url>
    <content type="text"><![CDATA[下面是一堆垃圾内容 常见词汇和术语 软件项目管理 软件生命周期 软件过程 软件过程管理 敏捷软件开发 CMM 瀑布模型 什么是软件开发软件开发的本质困难 复杂性 不可见性 可变性 一致性 这些都是啥 课程目标 理解项目管理的基本概念，掌握项目管理的常用方法。例如估算和计划跟踪，配置管理，风险管理等。 掌握产品质量和过程质量的基本概念，理解通过过程质量管理来保障最终产品质量或服务质量的手段。 掌握软件过程的基本概念，了解常用软件过程方法。理解进行个人级、小组级和组织级软件过程的评价与改进方法。 面临复杂项目的时候，能够选择适用的软件过程，对其进行合理组合和裁剪，并在此基础上合理组织和管理项目开发，达到预先设定的质量要求。 内容安排 概述 基本概念 软件过程的历史演变和经典工作 软件开发和应用特征驱动 当前挑战和未来 不同阶段的经典（瀑布、CMM、敏捷） 技术热点ABC和DevOps 后面的东西 PSP/TSP 敏捷方法 XP、SCRUM DevOps CMM/CMMI 过程组合和裁剪 关键实践讨论 估算、计划和跟踪 质量管理 风险管理 这个内容安排 很乱 很垃圾 教材和参考书 《DevOps原理、方法与实践》机械工业出版社 《软件过程与管理》机械工业出版社 概述软件工程的核心问题软件工程的管理视角成功是否可以复制？ 软件工程的技术视角问题是否可以解决得更好？ 软件项目管理概念管理的三大关键要素 目标 状态 纠偏 软件项目管理 典型的三大目标： 成本、质量、工期 软件项目管理是应用方法、工具、技术以及人员能力来完成软件项目，实现项目目标的过程。 估算、计划、跟踪、风险管理、范围管理、人员管理、沟通管理，等等 软件项目管理的管理视角成功是否可以复制？ 软件过程 软件过程是为了实现一个或者多个事先定义的目标而建立起来的一组实践的集合 这组实践之间往往有一定的先后顺序，作为一个整体来实现事先定义的一个或多个目标。 生命周期模型 对软件过程的一种人为划分 广义软件过程理论基石：软件产品和服务的质量，很大程度上取决于生产和维护该软件或者服务的过程的质量。 广义软件过程包括技术、人员以及狭义过程 广义软件过程的同义词：软件开发方法、软件开发过程 包含以下内容： 净室Cleanroom方法、极限编程方法、SCRUM方法、Gate方法 而更一般的，敏捷软件过程/方法、轻量型过程/方法以及重型过程/方法等描述也是恰当的 生命周期模型与软件过程区别和联系 生命周期模型是对一个软件开发过程的人为划分 生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分 生命周期模型往往不包括技术实践 典型的生命周期模型 瀑布模型、迭代式模型、增量模型、螺旋模型、原型法等等 软件过程管理 管理对象是软件过程 管理的目的是为了让软件过程在开发效率、质量等方面有着更好性能绩效（preformance） 软件项目管理： 产品生产管理软件过程管理： 流水线的设计、建设、维护、优化以及升级改造 软件过程管理与软件过程改进两者意思接近 软件过程管理参考模型CMM/CMMI，SPICE等 软件过程改进参考模型PDCA，IDEAL 此处需要一张图 戴明的PCDA循环示意图 思考问题n 是否正确 软件过程管理是软件项目管理应该要实现目标。 在公司导入敏捷过程是我们今年过程改进的主要目标。 XP和CMM是对立的两种软件开发方法 CMM不适合当今互联网环境的项目管理需求 PCDA和IDEAL不适合在敏捷环境中使用 不同的软件开发过程应该使用不同的生命周期模型。反之呢 什么狗屁问题 软件过程的历史演变和经典工作（一）再读《没有银弹》这是一本书，好像讲了不错的东西 软件开发有很多困难，但本质难题是 不可见性 复杂性 可变性 一致性 进一步分析 三个本质难题因项目而异(哪三个) 四大本质难题相互促进 本质难题变化带动软件方法（过程）演变 软件发展三大阶段 软硬件一体化阶段（50年代~70年代） 软件完全依附于硬件 软件作坊 软件成为独立的产品（70年代~90年代） 网络化和服务化（90年代中期迄今） 软件完全依附于硬件软件应用典型特征 软件支持硬件完成计算任务 功能单一 复杂度有限 几乎不需要需求变更 软件开发典型特征 硬件太贵 团队以硬件工程师和数学家为主 典型软件过程和实践PPT很乱，存一些名词自己找吧。 SAGE Mesure twice, cut once. Code and fix. 软件作坊软件应用典型特征： 功能简单 规模小 软件开发典型特征 很多非专业领域的人员涌入软件开发领域 高级程序语言出现 质疑权威文化盛行 软件危机和软件工程“Code and fix”不适合大型软件项目开发。 软件成为独立产品软件应用特征 摆脱了硬件束缚(OS) 功能强大 规模和复杂度剧增 个人电脑出现-&gt;普通人成为软件用户 需求多变 兼容性要求 来自市场的压力 典型软件过程和实践 方法之一：形式化方法 方法之二：结构化程序设计和瀑布模型 （瀑布模型？） 那他们有什么问题和不足呢(效率和质量) 形式化在扩展性和可用性方面存在不足 瀑布模型成为一个重文档，慢节奏的过程 成熟度模型这个东西有五个等级： Level1: Initial Level2: Managed Level3: Defined Level4: Quantitatively Managed Level5: Optimizing 一些讨论 CMMI是过程改进模型而非软件过程或者软件过程模型 CMMI不是过程优劣的标准，也不适合用作公司之间的能力比较 CMMI VS. Agile是一个伪命题 网络化和服务化 软件应用特征 功能更复杂，规模更大 用户数量急剧增加（这会带来什么问题？） 快速演化和需求不确定 分发方式的变化（SaaS） 典型软件过程和实践迭代式： 大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步来完成交付。 雪鸟会议和敏捷宣言 个体和互动胜过流程和工具 可以工作的软件胜过详尽的文档 客户合作胜过合同谈判 响应变化胜过遵循计划 XP方法 偏重于一些工程实践的描述 SCRUM方法 管理框架和管理实践 Kanban方法 精益生产（丰田制造法）的具体实现 可视化工作流、限定WIP、管理周期时间 开源软件开发方法： 是一种基于并行开发模式的软件开发的组织与管理方式 linus定律： 如果有足够多的beta测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。 早发布，常发布，倾听用户的反馈 把你的用户当作合作开发者对待，如果想让代码质量快速提升并有效排错，这是最省心的途径 设计上的完美不是没有东西可以再加，而是没有东西可以再减 代码管理： 严格的代码提交社区审核制度 一些演化： 内部开源(Inner Source) 众包(Crowdsourcing) 思考上了从软件发展的三大历史阶段（我怎么忘了）以及软件过程的演变当中，我们可以总结出哪些有规律的东西？ 看到了，重复一下： 软硬件一体化阶段（50年代~70年代） 软件完全依附于硬件 软件作坊 软件成为独立的产品（70年代~90年代） 网络化和服务化（90年代中期迄今） 然后是不同阶段的实践可以整理。]]></content>
      <tags>
        <tag>呵呵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[余弦相似度计算]]></title>
    <url>%2Fblog%2F2018%2F11%2F23%2Fconsine-similarity%2F</url>
    <content type="text"><![CDATA[先来一段废话为了计算文本的相似度，我们需要一些算法，比如这个余弦相似度算法。 具体怎么算呢？ 简单一点就是如下: 分词 将所有的词放在一个集合中 根据集合位置给词编码 将两个语句化为向量，维度为所有词的数量，每个维度的数值为这个词在此句子中出现的次数 计算两个向量的余弦值，越大代表越接近 具体操作分词我们可以用jieba分词，因为它分得一定比我好 把所有的词放在集合中遍历一下即可 根据集合位置给词编码变为一个dict并且对应的位置置为数量 转向量先将分词结果替换为数字数组，数字为dict中的值。统计不同位置出现的次数，存在向量中。 计算余弦值使用如下式子计算： $$\cos(\theta)=\frac{\sum\limits_{i=1}^n(x_i\times{y_i})}{\sqrt{\sum\limits_{i=1}^n(x_i)^2}\times\sqrt{\sum\limits_{i=1}^n(y_i)^2}}$$ 其实就是点积和长度的乘积的比值。 具体影响： 如果两个句子相同的词越多，点积就会越大，相似度也会越高。如果两个句子在相同的词不变的情况下，句子长度越长，相似度则会越低。 如果动脑子想一想，确实还是有道理的，但是似乎有点太简单了一些。 举个栗子首先我们拿到两句话： 这里有一根比较长的棍子这里有一根比较短的棍子 使用jiaba分词的结果： 12[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;长&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;][&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;短&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;] (所以标点符号也算进去了) 然后我们变成这样的集合： 1[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;长&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;, &apos;短&apos;] 然后标个号: 1234567891011&#123; &apos;这里&apos;: 0, &apos;有&apos;: 1, &apos;一根&apos;: 2, &apos;比较&apos;: 3, &apos;长&apos;: 4, &apos;的&apos;: 5, &apos;棍子&apos;: 6, &apos;。&apos;: 7, &apos;短&apos; 8&#125; 然后我们变成两个向量： [1, 1, 1, 1, 1, 1, 1, 1, 0],[1, 1, 1, 1, 0, 1, 1, 1, 1], 最后求得余弦值为$0.875$ 此时我们再掏出一个句子： 这里有一根棍子，它有点长 分个词： 1[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;棍子&apos;, &apos;，&apos;, &apos;它&apos;, &apos;有点&apos;, &apos;长&apos;, &apos;。&apos;] 我们用第一个句子和第二个句子来计算相似度，那么我们得到的集合是: 1[&apos;这里&apos;, &apos;有&apos;, &apos;一根&apos;, &apos;比较&apos;, &apos;长&apos;, &apos;的&apos;, &apos;棍子&apos;, &apos;。&apos;, &apos;，&apos;, &apos;它&apos;, &apos;有点&apos;] 向量: 12[1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0][1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1] 余弦值约等于$0.707$ 结果也就是说，比较和第二，第三句的相似度，第一句和第二句的相似度是比较高的。 虽然它们结构上确实是……比较接近的 但是意思显然…不太对 一个可能有效的改进假设我们有一个反义词集，里面有记录 长/短 是一对反义词，那么我们似乎可以记录一个负值： 比如在计算前两句的相似度时，我们认为长和短在同一个维度，但方向相反，我们如下的位置集合： 1234567891011&#123; &apos;这里&apos;: [0, 1], &apos;有&apos;: [1, 1], &apos;一根&apos;: [2, 1], &apos;比较&apos;: [3, 1], &apos;长&apos;: [4, 1], &apos;的&apos;: [5, 1], &apos;棍子&apos;: [6, 1], &apos;。&apos;: [7, 1], &apos;短&apos; [4, -1]&#125; 那么我们在这个情况下，计算的两个向量为： [1, 1, 1, 1, 1, 1, 1, 1][1, 1, 1, -1, 1, 1, 1, 1] 余弦值只有$0.75$了…感觉总归是有一点效果的，对于当前这种，一个位置意思相反的情况。 要是冒出一个双重否定怎么办呢…也许我们需要加入一些结构分析 感觉会有人用了一些考虑了不同的词的相关性的算法…而不是这样简单粗暴地分成多个维度 或者只是加一个反向 不过暂时应该是够用了 代码实现没有实现]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>文本分析</tag>
        <tag>相似度计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常微分方程及解法]]></title>
    <url>%2Fblog%2F2018%2F11%2F15%2Fordinary-differential-equation%2F</url>
    <content type="text"><![CDATA[微分方程先整理一些在下面会出现的概念或者定义… 微分方程指一个表示未知函数、未知函数的导数以及自变量之间的关系的方程. 微分方程的阶指微分方程中出现的最高阶导数或偏导数的阶. 常微分方程指自变量个数只有一个的微分方程. 偏微分方程指自变量个数大于一个的微分方程. 举个栗子: $\frac{\partial^2{u}}{\partial{x^2}}+\frac{\partial^2{u}}{\partial{y^2}}+\frac{\partial^2{u}}{\partial{z^2}}=0$是一个二阶偏微分方程， 形如$$F(x,y,y’,…,y^{(n)})=0$$的等式称作一个以$x$为自变量,以$y(x)$为未知函数的n阶常微分方程 下面关注的是一些关于常微分方程和它的解法的内容,以及一些常见的问题.偏微分方程不会涉及. 解和通解微分方程有解和通解两个概念, 如果一个函数如$y=x^2+3$带入方程$\frac{\mathtt{d}y}{\mathtt{d}x}=2x$,可以使得方程恒成立，此时称$y=x^2+3$是该方程的一个解. 如果一个$n$阶微分方程有解$y=\varphi(x, C_1, C_2, …, C_n)$, 并且其中$C_1, C_2, … C_n$是相互独立的任意常数，我们称$y=\varphi(x,C_1,C_2,…,C_n)$为该方程的通解. 如果一个方程的通解需要使用隐函数来表示，那么我们称这个通解为方程的隐式通解或者通积分 然后我们看一下一阶微分方程的初等解法，出于方便下面描述中的微分方程均指常微分方程. 一阶微分方程的初等解法并不是所有的一阶方程都可以求得由初等函数表示的解,如 $$y’=x^2+y^2$$ 这个方程就不行，至于为什么不行，这个在1838年被刘维尔证明了. 在实际应用中有很多的微分方程都没有可以用初等函数表示的解，但我们还是要讨论一些能解的情况的解放，比如对于一些一阶微分方程我们可以用分离变量的方式来求解，对于一些不可以直接分离变量的方程，我们也可以把它化为可以分离变量的方式再求解……所以分离变量是一个比较有用的方法. 变量分离方程变量分离方程就是形如 $$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x)g(y)$$ 的微分方程，其中$f, g$都是连续函数. 对于这种形式的方程我们可以把与$x$和$y$有关的部分分别放到等号的两边，然后两边同时进行积分操作，就可以得到它的解. 具体如下: $$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x)g(y)$$交换一下x,y的位置$$\frac{\mathtt{d}y}{g(y)}=f(x)\mathtt{d}x$$两边积分$$\int{\frac{\mathtt{d}y}{g(y)}}=\int{f(x)\mathtt{d}x}+C$$ 我们得到的式子即为原方程的隐式通解或者通积分，如果我们能求出该式子确定的函数$y=\phi(x,C)$,那么$y=\phi(x,C)$是原方程的通解. 注意的是我们在第二行移项的时候将$g(y)$挪到了分母位置，如果有一个$y=y_0$使得$g(y_0)=0$,我们会发现它同样是方程的一个解,但不在上述的通解当中，我们应该将它补上. 也就是如果我们在运算过程中发现了一些使得某些函数定义域或者值域发生改变的情况，我们需要把这个被去除掉的部分补上. 可以化为变量分离方程的情况有一些情况虽然不是可以变量分离的形式，但经过一些简单的变换可以化为上述的$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x)g(y)$的形式, 比如下面的几个: 1. 形如$\frac{\mathtt{d}y}{\mathtt{d}x}=f(ax+by+c)$的微分方程这时候我们设$u=ax+by+c$,则有 $$\mathtt{d}u=a\mathtt{d}x+b\mathtt{d}y$$ 我们需要将$\mathtt{d}y$和$\mathtt{d}x$放在一起变为$\frac{\mathtt{d}y}{\mathtt{d}x}$的形式，然后把方程左边的$\frac{\mathtt{d}y}{\mathtt{d}x}$替换掉，从而使方程变为$u$和$x$的变量分离方程,因此有: $$\frac{\mathtt{d}u}{\mathtt{d}x}=a+b\frac{\mathtt{d}y}{\mathtt{d}x}$$ 即 $$\frac{\mathtt{d}u}{\mathtt{d}x}=a+bf(u)$$ 此时式子是一个变量分离方程，那么我们可以根据变量分离方程的方法试着求得通解，然后再将$u$替换为$ax+by+c$即可。比如我们求得通解$u=\varphi(x,C)$,则原方程的通解为$ax+by+c=\varphi(x,C)$ 2. 形如$\frac{\mathtt{d}y}{\mathtt{d}x}=f(\frac{y}{x})$的微分方程此时替换的是$\frac{y}{x}$,也就是令$u=\frac{y}{x}$,有: $$x\mathtt{d}u+u\mathtt{d}x=dy$$ 还是同样的套路，我们把上式化成: $$\frac{\mathtt{d}y}{\mathtt{d}x}=x\frac{\mathtt{d}u}{\mathtt{d}x}+u$$ 有 $$x\frac{\mathtt{d}u}{\mathtt{d}x}+u=f(u)$$ 我们也可以看出这个方程可以化为变量分离方程，如果我们可以得到通解$u=\varphi(x,C)$,那么原式通解为$\frac{y}{x}=\varphi(x,C)$ 3. 形如$\frac{\mathtt{d}y}{\mathtt{d}x}=f\left(\frac{a_1x+b_1x+c}{a_2x+b_2y+c}\right)$的微分方程一阶线性微分方程一阶线性微分方程指形如 $$\frac{\mathtt{d}y}{\mathtt{d}x}+P(x)y=Q(x)$$ 的方程 一阶齐次线性微分方程当$Q(x)\equiv0$时，成为一阶齐次线性方程. 一阶非齐次线性微分方程当然是$Q(x)\not\equiv0$时了 全微分方程与积分因子全微分方程我们可以将一阶微分方程$y’=f(x,y)$写成如下的形式 $$P(x,y)\mathtt{d}x+Q(x,y)\mathtt{d}y=0$$ 此时如果存在可微函数$\lambda(x,y)$使得$d\lambda(x,y)=P(x,y)\mathtt{d}x+Q(x,y)\mathtt{d}y$,则$P(x,y)\mathtt{d}x+Q(x,y)\mathtt{d}y=0$称为恰当微分,该方程称为全微分方程或恰当方程 积分因子有的方程虽然不是全微分方程，但在等式左右两边乘上一个连续可微函数$\mu(x,y)$,可以化为全微分方程,此时我们称这个$\mu(x,y)$为这个方程的积分因子. 解的存在唯一性定理我并没有看懂这一整个皮卡存在唯一性定理的证明 利普希兹(Lipschitz)条件我正在试图找一个函数绘图软件画一下… 利普希兹条件是指: 如果存在一个常数$L$，使得一个函数$f(x,y)$在区域$D$内,$\mid f(x,y_1)-f(x,y_2)\mid\le L\mid(y_1-y_2)\mid$对所有的$(x,y_1),(x,y_2)\in{D}$都成立. 我们称$L$是利普希兹常数，称$f(x,y)$在区域$D$上关于$y$满足利普希兹条件. 皮卡存在唯一性定理如果$f(x,y)$在闭区域$D$：$\mid x-x_0\mid\le{a},\mid y-y_0\mid\le{b}$上连续且关于$y$满足利普希兹条件，则方程$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x,y)$存在唯一的解$y=\phi(x)$,它在区间$\mid x-x_0\mid\le{h}$上连续，且满足初始条件$\phi(x_0)=y_0$,这里$h=\min(a,\frac{b}{M}),M=\max\limits_{(x,y)\in{D}}\mid f(x,y)\mid$. 上面的定理描述是针对一阶微分方程的,那么高阶的时候是否成立或者如何描述呢？ 证明起来步骤似乎很长，首先证明有解等价于一个式子，然后构造一个函数序列，证明对于每个n，函数都存在，然后证明函数序列一致收敛，求极限后等于我们要求的式子，最后再证明解的唯一性… 定理的证明我们分五个引理来证明这个定理。方便起见区间$\mid x-x_0\mid\le{h}$取$x_0\le{x}\le{x_0+h}$部分来证明. 引理1$y=\phi(x)$是方程$\frac{\mathtt{d}y}{\mathtt{d}x}=f(x,y)$定义在区间$x_0\le{x}\le{x_0+h}$上,且满足初始条件$\phi(x_0)=y_0$的解，当且仅当$y=\phi(x)$在$x_0\le{x}\le{x_0+h}$上连续且满足 $$\phi(x)=y_0+\int_{x_0}^xf(x,y)\mathtt{d}x,(x_0\le{x}\le{x_0+h})$$ (看起来是这样，既满足初始条件，求个导也是$f(x,y)$) 证明: 由于$y=\phi(x)$是方程的解，有: $$\frac{\mathtt{d}\phi(x)}{\mathtt{d}x}=f(x,\phi(x))$$ (直接写y不好吗)那么我们对两边从$x_0$到$x$求定积分就可以得到: $$\phi(x)-\phi(x_0)=\int_{x_0}^xf(x,\phi(x))\mathtt{d}x,(x_0\le{x}\le{x_0+h})$$ 整理一下就是上面写的式子了. 反过来我们对$\phi(x)=y_0+\int_{x_0}^xf(x,y)\mathtt{d}x,(x_0\le{x}\le{x_0+h})$两边求导,可得 $$\frac{\mathtt{d}\phi(x)}{\mathtt{d}x}=f(x,\phi(x))$$ (所以$y$和$\phi$混着写令人非常难受)证明了这个引理就是告诉我们在这个区间上，有解和这个条件是等价的，那我们后面需要证这个条件就可以得出有解. 引理2我们首先构造一个皮卡逐步逼近函数序列: $$\begin{cases}\phi_0(x)=y_0 \\\phi_n(x)=y_0+\int_{x_0}^xf(t,\phi_{n-1}(t))\mathtt{d}t,(x_0\le{x}\le{x_0+h})\end{cases}$$ 引理2的内容是： 对于所有的$n$，式中的函数$\phi_n(x)$在区间$x_0\le{x}\le{x_0+h}$都有定义且满足: $$\mid{\phi_n(x)-y_0}\mid\le{b}$$ 证明： 我们用数学归纳法可以证明。当$n=1$时，$\phi_1(x)=y_0+\int_{x_0}^xf(t,y_0)\mathtt{d}t$，易见这个函数在$x_0\le{x}\le{x_0+h}$上有定义，连续且有: $$\begin{split}\mid\phi_1(x)-y_0\mid&amp;=\left\vert\int_{x_0}^xf(t,y_0)\mathtt{d}t\right\vert \\&amp;\le\int_{x_0}^x\vert{f(t,y_0)}\vert\mathtt{d}t \\&amp;\le{M(x-x_0)}\le{Mh}\le{b}\end{split}$$ 引理3引理4引理5高阶微分方程这一部分主要是二阶齐次和非齐次微分方程，有时候虽然不好解，但我们的问题可能只是需要一个解，或者由一些条件来计算通解.因此这里是一些性质和定理，可以直接使用. 应用举例emmm,似乎没有那么必要]]></content>
      <categories>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
        <tag>常微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿和素材]]></title>
    <url>%2Fblog%2F2018%2F11%2F06%2Fdraft%2F</url>
    <content type="text"><![CDATA[Docker命令相关创建一个网络1docker networt create --subnet=172.18.0.0/16 mynetwork 列出网络1docker network ls 查看镜像信息1docker inspect imageid docker内网访问的问题在一个容器中使用反向代理，代理到其它容器的服务，此容器使用公网，其他容器只能在内网访问。 即比如有如下三个容器A, B, C 然后A容器暴露80端口到公网 B和C暴露各自的服务端口如8080或3000等到内网 然后在A容器中使用反向代理，代理容器B和C中的服务，使得公网可以通过访问A来访问B和C的服务 方案A容器A: 0.0.0.0:80:80容器B: 172.17.0.1:8080:8080容器C: 172.17.0.1:8081:8080 这个方案是可以的 方案B使用172.18.0.0/16网络，分配固定ip，并直接访问也是可以的。比如容器A依旧是 0.0.0.0:80:80容器B使用ip和端口: 172.18.0.10:8080这时也是可以使用的 尝试-p参数-p参数的作用是什么呢，可以的选项是什么呢？0.0.0.0可以用，那么127.0.0.1呢我需要搞清楚这个 如果指派一个ip给容器，就不能再把对应的ip用来映射了比如172.18.0.10:5000:5000 还同时把172.18.0.10分配给一个容器，这是不行的 EXPOSE的作用（去搜索） EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务 –摘自https://yeasy.gitbooks.io/docker_practice/image/dockerfile/expose.html 所以它实际上并不能暴露端口。 如果EXPOSE和-P参数一起使用，则会使用随机映射的策略进行映射，这估计是EXPOSE的唯一作用。 -p 参数则用于手动指定端口映射。 格式大致如ip:宿主机port:容器port 那么这个ip的限制呢？ –link这个命令似乎有神奇的作用，但是我们需要 啊 我只是想让某个docker服务只暴露在内网，为何总是无法访问 难道我需要iptables吗 对应的文档或者源码能不能看一下呢 -p的原理使用iptables可以查看实际上的操作 看起来docker里面应该填网络名。先使用iptables看看效果 Docker的笔记 Docker使用Go语言开发，对进程进行封装隔离，属于操作系统层面的虚拟化技术。比虚拟机技术更加轻便，快捷。 和虚拟机的区别 虚拟机技术在所有在虚拟机之上使用Hypervisor，然后每一个虚拟机包含了应用，库文件以及整个操作系统 Docker技术则使用Docker Engine对所有的容器进行管理，每一个容器中只有应用的库文件 Docker的好处 更高效地利用系统资源（不需要完整的操作系统） 更快的启动时间（比起虚拟机，不需要一个操作系统，所以很快） 一致的运行环境（同样的Dockerfile，不用担心换环境导致错误） 持续交付和部署（使用Dockerfile，CI/CD） 轻松迁移（保证执行环境的一致性） 更轻松的维护和扩展（什么是分层存储和镜像技术？）（有很多官方镜像可以使用） 镜像，容器和仓库镜像Docker镜像相当于一个root文件系统。Linux内核启动后会挂载root文件系统为其提供用户空间支持。 不是很懂这个 分层存储 分层存储利用了Union FS技术,docker的镜像并不是一个单一的文件，而是由一组文件组成。 镜像构建时会一层一层地构建。而在后面的层将无法改动前面的层，删除上一层的文件的操作实际上是将其标志为删除。 好处是在镜像复用或者定制时更加容易。 容器一个镜像可以有多个容器实例，就像面向对象的类和实例的关系一样。 容器可以进行的操作有： 创建 启动 停止 删除 暂停 跟虚拟机可以进行的操作很类似。 特性： 容器的实质是进程，这个进程运行于独立的命名空间 每一个容器运行时，会在镜像上面创建一层容器存储层，最佳实践推荐不要向存储层写入任何数据。 文件操作： 应该使用数据卷或者绑定宿主目录的方式对宿主进行读写，在这种操作方式下，容器消亡时数据并不会消亡。 仓库Docker Registry是一个集中存储、分发镜像的服务 一个Registry里面可以包含多个仓库(Repository),每个仓库可以包含多喝标签(tag); 每个标签对应一个镜像。 比如: ubuntu:16.04 ubuntu:latest 如果在docker pull时不指定标签，使用默认标签latest 常用的公开registry服务： Docker Hub Quay.io Google Container Registry 常见的加速器(Registry Mirror): 阿里云加速器 DaoCloud加速器 (配置方式呢) Dockerfile的操作 每一个指令，都会建立一层存储 FROM选择基础镜像，如果从空白开始则是FROM scratch 使用Go开发的应用很多会使用这种方式来制作镜像，体积更加小巧 RUN用于执行命令行命令，注意进行一个完整的操作时应该将命令行命令写在同一个RUN中，用\换行 举例如下: (摘自 https://yeasy.gitbooks.io/docker_practice/image/build.html) 1234567891011121314FROM debian:jessieRUN buildDeps='gcc libc6-dev make' \ &amp;&amp; apt-get update \ &amp;&amp; apt-get install -y $buildDeps \ &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" \ &amp;&amp; mkdir -p /usr/src/redis \ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \ &amp;&amp; make -C /usr/src/redis \ &amp;&amp; make -C /usr/src/redis install \ &amp;&amp; rm -rf /var/lib/apt/lists/* \ &amp;&amp; rm redis.tar.gz \ &amp;&amp; rm -r /usr/src/redis \ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 这样可以避免出无意义的层并且增加镜像的体积(因为后面的层无法真正地删除前面的层的文件) COPYADDCMDENTRYPOINTENVARGVOLUMEEXPOSEWORKDIRUSERHEALTHCHECKONBUILD Docker依旧是一种虚拟化的方式 curl的笔记1curl -X POST http://balabala.com/balabala -d &#123;\"param1\":\"value\"&#125; -X可以指定请求方式，比如POST或者GET. -d可以指定参数，但是似乎默认的参数格式是&quot;a=sss&amp;b=c&quot;这种格式 似乎需要额外的参数指定json格式呢 找到了 1curl -H "Content-Type:application/json" -X POST http://balabala.com/balabala -d &#123;\"param1\":\"value\"&#125; DevOps Development and Operations 特点？好处都有啥？缺点？采用的技术？啊容器和虚拟机是不一样的，曾经有人问我他们的区别 VSCode很好，vscode很好vscode很奇怪 不是很好 材料 md编辑时打开preview关闭很迷 terminal放到右边时如何回到下方 草稿需要的时候从草稿中取出素材已经学过的东西需要被记录 反复反复记录阅读反复阅读记录阅读强化 等待，我总是在等待 我需要把所有的额外的东西先打包一个docker image,而不是每次都操作一次,这太蠢了 人在等待的时候应该做什么 零样本学习pycryptodome什么是pycryptodome呢 源码为什么不看一看源码呢 iptables1iptables -t nat -nL iptables好像很有趣 收藏一个关于docker的gitbook: https://yeasy.gitbooks.io/docker_practice/ gitbook?#的作用比如#test可以访问这里 docker的网络模型导出word的方案telnet使用Spring boot中使用redis做缓存一篇文章： https://www.cnblogs.com/gdpuzxs/p/7222309.html另一篇： https://www.cnblogs.com/badboyf/p/6995202.html?utm_source=itdadao&amp;utm_medium=referral 读读书，涨涨姿势中文文案排版指南https://github.com/mzlogin/chinese-copywriting-guidelines#%E8%B0%81%E5%9C%A8%E8%BF%99%E6%A0%B7%E5%81%9A Go方法以及简单的Hello World1234567package mainimport "fmt"func main() &#123; fmt.Println("Hello, World!")&#125; 用scratch来制作一个go应用镜像摘自菜鸟教程。 package main代表是一个可独立执行的程序。 fmt是一个IO库。 Println竟然是大写 {的位置1234func main()&#123; fmt.Println("Hello, Wolrd")&#125; 这样写会报错。。。。真的有这个必要吗 for循环12345var list = []int32&#123;1, 2, 3&#125;for i := 0; i &lt; len(list); i++ &#123; fmt.Println(i)&#125; 变量命名使用单驼峰命名方式，不是下划线或者双驼峰 调试1go run filename.go 新问题在docker里面启动的东西能不能把命令行的日志放到日志文件里啊 试一下吧 docker启动一个redis12docker pull redisdocker run -d --name myredis -p 16379:6379 redis --requirepass "mypassword" Arduino注释可以使用 舵机使用Servo控制舵机 Serial1Serial.begin(); （Arduino高亮是不是有bug） css3动画真好玩 vue中操作cookieaxios默认不允许请求携带cookie 需要使用 1axios.defaults.withCredetials = true; 接收不到cookie不要使用mock即可 RedisRedis在互联网公司一般有以下应用: String：缓存、限流、计数器、分布式锁、分布式Session Hash：存储用户信息、用户主页访问量、组合查询 List：微博关注人时间轴列表、简单队列 Set：赞、踩、标签、好友关系 Zset：排行榜 Ant DesignKite安装先翻个墙： 123go get -u github.com/gpmgo/gopmgopm get -g -v github.com/koding/kite 创建Project如果使用goland,不要把目录放在GOROOT下面 哈夫曼编码glsl点乘是dot 叉乘是cross 圈乘$\otimes$是把对应位置乘起来，可以用matrixCompMult 叉乘假设有向量$\mathrm{A}=(x_1,y_1,z_1),\mathrm{B}=(x_2,y_2,z_2)$,那么 $$\mathrm{A}\times\mathrm{B}=(y_1\times{z_2}-y_2\times{z_1},z_1\times{x_2}-z_2\times{x_1},x_1\times{y_2}-x_2\times{y_1})$$ 酷Q docker测试一下 123docker pull coolq/wine-coolqmkdir /root/coolq-datadocker run --name=coolq -d -p 8080:9000 -v /root/coolq-data:/home/user/coolq -e VNC_PASSWD=12345678 -e COOLQ_ACCOUNT=123456 coolq/wine-coolq 访问对应的端口输入密码即可操作 进入/root/cooq-data/conf,编辑CQP.cfg,添加 12[Debug]DeveloperMode=1 把开发好的应用拉下来试试（ 接下来开始开发请求模式的机器人 先启动一个docker版flask或者django试试？ 使用HardSourcePlugin加快webpack速度1npm install --save hard-source-webpack-plugin]]></content>
      <categories>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>草稿</tag>
        <tag>素材</tag>
        <tag>乱贴标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git分支操作笔记]]></title>
    <url>%2Fblog%2F2018%2F11%2F05%2Fgit-branch%2F</url>
    <content type="text"><![CDATA[创建本地分支1git checkout -b issn 相当于 12git branch issngit checkout issn 提交更改到分支12git add .git commit -m "message" 回到主分支1git checkout master 合并分支1git merge issn]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$\mathtt{B\acute{e}zier}$曲线]]></title>
    <url>%2Fblog%2F2018%2F10%2F26%2Fbezier-curve%2F</url>
    <content type="text"><![CDATA[$\mathtt{B\acute{e}zier}$曲线的定义$$P(t)=\sum_{i=0}^nB_{i,n}(t)P_i,0\le{t}\le{1}$$ 其中， $$B_{i,n}(t)=C_n^it^i(1-t)^{n-i}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i},i=0,1,\dots,n$$ 当$n=1$时,式子成为 $$\begin{split}P(t)&amp;=B_{0,1}(t)P_0+B_{1,1}(t)P_1,0\le{t}\le{1} \\&amp;=(1-t)P_0+tP_1 \\&amp;=\begin{pmatrix}t &amp; 1 \\\end{pmatrix}\begin{pmatrix}-1 &amp; 1 \\1 &amp; 0 \\\end{pmatrix}\begin{pmatrix}P_0 \\P_1 \\\end{pmatrix}\end{split}$$ 这个式子意味着这是一条从$P_0$连到$P_1$的直线段. 当$n=2$时,式子成为 $$\begin{split}P(t)&amp;=(1-t)^2P_0+2t(1-t)P_1+t^2P_2 \\&amp;=\begin{pmatrix}t^2 &amp; t &amp; 1 \\\end{pmatrix}\begin{pmatrix}1 &amp; -2 &amp; 1 \\-2 &amp; 2 &amp; 0 \\1 &amp; 0 &amp; 0 \\\end{pmatrix}\begin{pmatrix}P_0 \\P_1 \\P_2 \\\end{pmatrix}\end{split}$$ 这次是一个抛物线. 当$n=3$时，式子成为 $$\begin{split}P(t)&amp;=(1-t)^3P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3 \\&amp;=\begin{pmatrix}t^3 &amp; t^2 &amp; t &amp; 1 \\\end{pmatrix}\begin{pmatrix}-1 &amp; 3 &amp; -3 &amp; 1 \\3 &amp; -6 &amp; 3 &amp; 0 \\-3 &amp; 3 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 0 \\\end{pmatrix}\begin{pmatrix}P_0 \\P_1 \\P_2 \\P_3 \\\end{pmatrix}\end{split}$$ 曲线的性质]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker搭建jenkins]]></title>
    <url>%2Fblog%2F2018%2F10%2F25%2Fjenkins%2F</url>
    <content type="text"><![CDATA[记录一下在CentOS7中使用docker运行一个jenkins… 环境使用CentOS7 前置条件 需要有tomcat 123docker pull jenkinsmkdir /home/jenkinsdocker run -d --name myjenkins -p 15000:50000 -p 18080:8080 -v /home/jenkins:/home/jenkins jenkins -v和使用copy的效果是如何不同的此处占坑 然后需要找密码了，访问服务器的10080端口可以看到jenkins的登陆界面。该界面会告诉我们密码放在/var/jenkins_home/secrets/initialAdminPassword里面，但我们的jenkins是在docker容器中启动的，所以我们需要到容器内对应的路径去找。 12docker exec -it myjenkins /bin/bash # 进入容器cat /var/jenkins_home/secrets/initialAdminPassword 拿到密码a704538e730d4acda43343383718377c 退出容器 1logout 登陆进去选插件，发现有一堆安装失败了pipeline 后续操作并没有学会…… 自己写一个吧]]></content>
      <categories>
        <category>持续集成</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Spring Cloud]]></title>
    <url>%2Fblog%2F2018%2F10%2F24%2Fspringngcloud%2F</url>
    <content type="text"><![CDATA[Eureka结构有服务注册中心、服务生产者和服务消费者 流程 服务生产者启动时，向服务注册中心注册服务 服务消费者(启动时？)向服务注册中心订阅服务 服务注册中心向服务消费者返回服务生产者的地址 服务消费者调用所需服务 用途 这是一段话所以注册的服务只是告诉注册中心自己的地址，让注册中心转告给消费者？ 启动方式服务注册中心是一个eureka-server建议禁用client功能 服务生产者是一个eureka-client bus Spring Cloud Bus被翻译为消息总线看起来可以在多个服务中互相传递消息 用途 这也是一段用途，但他不能教我数学 结构 服务A启动，连接总线 服务B启动，连接总线 服务C启动，连接总线 服务A发送消息 服务B、C收到消息 举个栗子 ActiveMQ Kafka RabbitMQ RocketMQ 比较吗？需要比较一下吗？ 使用RabiitMQzuul zuul是一个网关 配置中心spring cloud config/ zoo keeperredis断路器/熔断/Hystrixdevops和aiopsdubbo/zookeeper读论文 我们需要读论文学习]]></content>
      <categories>
        <category>编程</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arduino怎么写呢]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2Farduino%2F</url>
    <content type="text"><![CDATA[整理一些简单语法… 疑问 为什么打开Arduino放着不动，cpu占用率高达30%? Hexo的Arduino高亮似乎有问题 Arduino是垃圾吗？ 声明变量12int xxx = 1;boolean yyy = false; 舵机控制使用Servo控制舵机 12345678#include&lt;Servo.h&gt;Servo servo;void setup() &#123; servo.attatch(portNum); servo.write(angle);&#125; 一个简单程序的结构1234567void setup() &#123;&#125;void loop() &#123;&#125; setup会在初始化时执行，loop会持续执行 信号的IO123analogRead(portNum);digitalRead(portNum);digitalWrite(portNum, LOW); 设置输出端口1pinMode(portNum); 串口调试1234567void setup() &#123; Serial.begin(9600); //频率&#125;void loop() &#123; Serial.println(&quot;sdasdas&quot;);&#125;]]></content>
      <categories>
        <category>编程</category>
        <category>arduino</category>
      </categories>
      <tags>
        <tag>aruduino</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在c++中使用opengl]]></title>
    <url>%2Fblog%2F2018%2F10%2F21%2Fopengl%2F</url>
    <content type="text"><![CDATA[Shaders哪里放more,这里放more 如何偷懒，如何不偷懒关键字in和out是一个Shaders文件的输入和输出 vertex和fragment shader有一些不同 123in type in_variable_name;out type out_variable_name; 我们惊奇地发现，这个主题还支持glsl uniform是全局变量，后面的shader可以使用 1uniform type variable_name; Sampler通常在fragment shader中定义，是一个uniform类型的变量，但我不是很懂uniform了 取整和插值texelFetch1texelFetch(Sampler, vec2, lod); textureSizelod是什么意思呢level of detail, 有机会试试 百度百科： 多细节层次 LOG技术根据物体模型的节点在显示环境中所处的位置和重要度 给人一种放大缩小的感觉 12345uniform sampler2D texSlot;void main() &#123; vec2 texSize = textureSize(texSlot, 1);&#125; opengl很强]]></content>
      <categories>
        <category>编程</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>opengl</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习python]]></title>
    <url>%2Fblog%2F2018%2F10%2F16%2Flearning-py3%2F</url>
    <content type="text"><![CDATA[这个很难, python很难 Queue是一个线程安全的类吗 wrapper的一个用处，给函数打日志 12345678910111213141516171819import timefrom functools import wrapsdef log(func): @wraps(func) def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print("func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;".format(func.__name__, (args, kwargs), end_time - start_time, result)) return result return wrapper @logdef bar(): return "hello" if __name__ == '__main__': bar() 运行结果： 1func bar, param ((), &#123;&#125;), time 0.0, return hello function的属性 1__name__ 偏函数 Partial, 柯里化 Currying 补充一下刚才的代码 123456789101112131415161718192021222324252627import timefrom functools import wraps, partialdef logger(func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print("func &#123;&#125;, param &#123;&#125;, time &#123;&#125;, return &#123;&#125;".format(func.__name__, (args, kwargs), end - start, result)) return result return wrapper@loggerdef add(a, b): return a + badd3 = partial(add, 3)if __name__ == '__main__': print(add3.__class__) add3(2) 12&lt;class 'functools.partial'&gt;func add, param ((3, 2), &#123;&#125;), time 0.0, return 5 Uncurrying 1234567891011121314@loggerdef add(a): @logger def add(b): @logger def add(c): return a + b + c return add return addif __name__ == '__main__': print(add(1)(2)(3)) 1234func add, param ((1,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add at 0x0000001567C500D0&gt;func add, param ((2,), &#123;&#125;), time 0.0, return &lt;function add.&lt;locals&gt;.add.&lt;locals&gt;.add at 0x00000015678267B8&gt;func add, param ((3,), &#123;&#125;), time 0.0, return 66 如何写一个满足add(2)至无穷个括号的函数？0x0000001567C500D0是内存地址?可以操作内存吗? Generator 123456789a_generator = (item**2 for item in range(200))if __name__ == '__main__': print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) print(next(a_generator)) 12345014916 生成质数 1234567891011121314151617181920log_next = logger(next)def prime(): base = 2 while True: is_prime = True for j in range(2, int(math.sqrt(base)) + 1): if base % j == 0: is_prime = False break if is_prime: yield base base += 1if __name__ == '__main__': prime_generator = prime() for i in range(10): log_next(prime_generator) 12345678910func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 2func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 3func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 5func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 7func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 11func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 13func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 17func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 19func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 23func next, param ((&lt;generator object prime at 0x000000450FF4A728&gt;,), &#123;&#125;), time 0.0, return 29 eval, compile,code ?]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcp中的一些细节]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Ftcp%2F</url>
    <content type="text"><![CDATA[RTT(往返时延)RTT的估计和超时 tcp像很多其他的协议一样，超时的时候会重发，但是如何估计往返时间和设定超时时间是一个需要考虑的问题 估计往返时延segment里面有SampleRTT，计算方式是一个segment发出的时间，到ack收到的时间，对于重发的segment则不进行计算 显然这个值会因为网络状况产生一些波动，为了估计一个典型的RTT. TCP维护一个平均值，EstimatedRTT: $$\mathtt{EstimatedRTT}=(1-\alpha)·\mathtt{EstimatedRTT}+\alpha·\mathtt{SampleRTT}$$ 其中常用的$\alpha$值为$0.125$ DevRTTDevRTT是用来衡量SampleRTT波动程度的值，公式如下： $$\mathtt{DevRTT}=(1-\beta)·\mathtt{DevRTT}+\beta·\mid\mathtt{SampleRTT}-\mathtt{EstimatedRTT}\mid$$ EstimatedRTT和DevRTT都是一个EWMA(指数加权移动平均值) 计算重发间隔有了EstimateRTT和DevRTT，超时时间应当如何计算？首先它需要不小于EstimateRTT，但是又不能太大，防止延迟过高。所以设置方式通常是在EstimateRTT上加一个margin，这个margin的值需要根据SampleRTT的波动情况来设置。因此TCP采用的方式是: $$\mathtt{TimeoutInterval}=\mathtt{EstimatedRTT}+4·\mathtt{DevRTT}$$ 推荐使用的初始值则是1秒，当发生超时时，TimeoutInterval会倍增，直到它被重新计算。 可靠的数据传输TCP在IP协议的基础上提供了可靠的数据传输，解决了数据错误，丢包，重复和顺序错乱的问题。 TCP推荐只维护一个重发的计时器，尽管可能有很多还没有收到ACK的包 一个简化的模型123456789101112131415161718192021222324252627282930NextSeqNum=InitialSeqNumberSendBase=InitialSeqNumberloop (forever) &#123; switch(event) event: data received from application above create TCP segment with sequence number NextSeqNum if (timer currently not running) start timer pass segment to IP NextSeqNum=NextSeqNum+length(data) break; event: timer timeout retransmit not-yet-acknowledged segment with smallest sequence number start timer break; event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase = y if (there are currently any not-yet-acknowledged segments) &#123; start timer &#125; &#125; break;&#125; 有了上述的简化模型我们就可以进行一些场景模拟了 场景一 Host A向Host B发了一个包，seq=92, length=8 bytes, Host B向Host A发了一个ack=100,但是丢了 timer时间到了，Host A重发了这个包 Host B发现是收过的，直接给Host A发了ack=100 Host A收到，继续正常工作 场景二 Host A向Host B发了一个包，seq=92,length=8 bytes Host A向Host B发了一个包, seq=100,length=20 bytes Host B收到seq=92的包，发了一个ack=100 Host B收到seq=100的包，发了一个ack=120 两个ack包没能在超时前收到，Host A重发了seq=92的包 Host B收到seq=92的包，发了一个ack=120 Host A开始发seq=120的包，继续正常工作 场景三 Host A向Host B发了上述1.2.中的两个包 Host B发了一个ack=100，丢了 Host B发了一个ack=120 Host A在超时前收到了sck=120 Host A发送seq=120，继续正常工作 添加翻倍机制在上述的简化模型中，加入如下机制： 每当timeout重发时，将TimeoutInterval翻倍，可以在网络拥塞时产生一些效果 在CSMA/CD中你会看到类似的做法。 快速重传在简单的模型上进行修改，已达到如下效果： Host A向Host B连发了5个包 Host B收到了第一个包，并发送了ack=100 第二个包丢了 Host B在收到3,4,5时连发了三个ack=100 Host A的timer还没有超时，但收到三个duplicated ack了 Host A重发seq=100 12345678910111213event: ACK received, with ACK field value of y if (y &gt; SendBase) &#123; SendBase=y if (there are currently any not yet acknowledged segments) &#123; start timer &#125; &#125; else &#123; increment number of duplicate ACKs received for y if (number of duplicate ACKs received for y==3) &#123; resend segment with sequence number y &#125; &#125; break; 流控制(暂时略过)TCP连接管理这部分关注的是TCP连接的建立和断开 三次握手Step1客户端向服务端发起请求，带有SYN，并且随机选择一个Seq值x，把报文段发到服务端 Step2服务端收到报文段，分配TCP连接的缓冲区，初始化一些变量。服务端发送一个SYN报文给客户端，ack=x+1，seq为随机值y此报文称为SYNACK报文 Step3客户端收到SYNACK，分配缓冲区，初始化一些变量。向服务端发送ack=y+1,seq=x+1 四次挥手Step1客户端向服务端发送FIN报文 Step2服务端向客户端发送ACK报文 Step3服务端向客户端发送FIN报文 Step4客户端向服务端发送ACK报文。服务端收到ACK后将关闭，客户端等待一段时间后关闭 TCP的生命周期客户端]]></content>
      <tags>
        <tag>tcp</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法及应用]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fsort%2F</url>
    <content type="text"><![CDATA[选择排序选择排序的原理非常简单，就是从数组里找到最大的数或者最小的数，把它放在数组的开头，然后再从剩下的部分继续找，直到结束. 使用go实现如下： 12345678910111213141516171819202122232425262728import "fmt"func main() &#123; var first = []int32&#123;1, 23, 4, 3, 212, 34&#125; var result = selectSort(first) for i := 0; i &lt; len(result); i += 1 &#123; fmt.Println(result[i]) &#125;&#125;func selectSort(originalList []int32) []int32 &#123; for i := 0; i &lt; len(originalList); i += 1 &#123; var max = originalList[i] var maxP = i for j := i; j &lt; len(originalList); j += 1 &#123; if originalList[j] &gt; max &#123; max = originalList[j] maxP = j &#125; &#125; if maxP != i &#123; var temp = originalList[i] originalList[i] = max originalList[maxP] = temp &#125; &#125; return originalList&#125; 冒泡排序冒泡排序的思想是，（假设需要升序排列）从第一个数开始，不停比较相邻的两个数，将大的放在右边，一轮过后最大的数会到数组的最右边。第二轮则是从第一个数到倒数第二个数…… 如果需要加快一下跳出可以加上一个flag, 如果一轮中没有出现交换，说明排序已经完成了，可以不再继续. 下面是一个go的版本:(只留function) 12345678910111213141516func bubbleSort(originalList []int32) &#123; for i := 0; i &lt; len(originalList)-1; i += 1 &#123; switched := false for j := 0; j &lt; len(originalList)-i-1; j += 1 &#123; if originalList[j] &gt; originalList[j+1] &#123; temp := originalList[j+1] originalList[j+1] = originalList[j] originalList[j] = temp switched = true &#125; &#125; if ! switched &#123; break &#125; &#125;&#125; 插入排序插入排序的思想是将数据插入到已经排序的数组当中，至于如何在数组中查找对应的位置还可以再分一下. 直接插入排序1234567891011121314func directInsertSort(originalList []int32) &#123; for i := 0; i &lt; len(originalList)-1; i += 1 &#123; current := originalList[i+1] for j := 0; j &lt;= i; j++ &#123; if current &lt; originalList[j] &#123; for k := i + 1; k &gt; j; k-- &#123; originalList[k] = originalList[k-1] &#125; originalList[j] = current break &#125; &#125; &#125;&#125; 二分插入排序希尔排序快速排序]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bochs的安装和使用]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fbochs%2F</url>
    <content type="text"><![CDATA[占坑]]></content>
  </entry>
  <entry>
    <title><![CDATA[java实现一个简单的apriori算法]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fapriori%2F</url>
    <content type="text"><![CDATA[占坑]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算PageRank]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fpage-rank%2F</url>
    <content type="text"><![CDATA[核心思想PageRank的核心思想： 如果一个网页被很多其他网页链接到，说明这个网页比较重要，PageRank值相对也会比较高. 如果一个PageRank值很高的网页链接到一个其他的网页，那么被链接到的网页PageRank值也会相应提高. 计算公式一般情况下,一个网页的PR值的计算公式如下： $$PR(p_i)=\alpha\sum\limits_{Pj\in{M_{p_i}}}\frac{PR(p_j)}{L(P_j)}+\frac{1-\alpha}{N}$$ 计算公式一般情况下,一个网页的PR值的计算公式如下： $$PR(p_i)=\alpha\sum\limits_{Pj\in{M_{p_i}}}\frac{PR(p_j)}{L(P_j)}+\frac{1-\alpha}{N}$$ 算法举例PageRank的值物理意义上是一个网页被访问的概率，因此通常对$N$个网页计算时，将每个网页的初始值设为$\frac{1}{N}$. 假设有4个网页A, B, C, D A有1个出链到D,B有2个出链到A和DC有1个出链到AD有2个出链到B和C 然后我们开始算第一轮: $$\begin{split}PR(A)&amp;=\alpha\left(\frac{PR(B)}{L(B)}+\frac{PR(C)}{L(C)}\right)+\frac{1-\alpha}{N} \\&amp;=\alpha\left(\frac{\frac{1}{4}}{2}+\frac{\frac{1}{4}}{1}\right)+\frac{1-\alpha}{N} \\&amp;=\frac{17}{20}\times\frac{3}{8}+\frac{3}{80} \\&amp;=\frac{57}{160} \\\end{split}$$$$\begin{split}PR(B)&amp;=\alpha\frac{PR(D)}{L(D)}+\frac{1-\alpha}{N} \\&amp;=\frac{23}{160} \\\end{split}$$$$\begin{split}PR(C)&amp;=\alpha\frac{PR(D)}{L(D)}+\frac{1-\alpha}{N} \\&amp;=\frac{23}{160} \\\end{split}$$$$\begin{split}PR(D)&amp;=\alpha\left(\frac{PR(A)}{L(A)}+\frac{PR(B)}{L(B)}\right)+\frac{1-\alpha}{N} \\&amp;=\alpha\left(\frac{\frac{57}{160}}{1}+\frac{\frac{23}{160}}{2}\right)+\frac{1-\alpha}{N} \\&amp;=\frac{17}{20}\times\frac{137}{320}+\frac{3}{80} \\&amp;=\frac{2569}{6400} \\\end{split}$$ 然后再从$PR(A)$开始计算……直到趋于平稳为止. 注意 当一个网页没有出链时认为对所有网页都有出链 为了限制一个网页只有指向自己的出链或者几个出链形成一个圈的情况，我们假定有一个概率$\alpha$，用户在浏览网页时会有一个这样的概率直接跳转到一个随机的网页，而每个网页的概率是相等的. $\alpha$值通常取$0.85$]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>学习</tag>
        <tag>PageRank</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇异值分解的计算方式]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fsingular-value-decomposition%2F</url>
    <content type="text"><![CDATA[特征值方阵$A$,向量$v$,值$\lambda$有如下关系 $$Av=\lambda v$$ 此时称$v$为方阵$A$的特征向量,$\lambda$则是此特征向量对应的特征值。 奇异值分解]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何学习ruby]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fruby-learning%2F</url>
    <content type="text"><![CDATA[开发环境搭建windows下的安装这个不难，有时候installer可能被墙 CentOS7我需要一个消息队列拯救服务器记笔记一个类1234567class Demo def initialize end def func1 endend]]></content>
      <categories>
        <category>编程</category>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>ruby</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集古诗文]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fchinese-learning%2F</url>
    <content type="text"><![CDATA[大学12大学之道，在明明德，在亲民，在止於至善。知止而後有定，定而後能静，静而後能安，安而後能虑，虑而後能得。物有本末，事有终始，知所先後，则近道矣…… 好事近·梦中作春路雨添花，花动一山春色。行到小溪深处，有黄鹂千百。飞云当面化龙蛇，夭矫转空碧。醉卧古藤阴下，了不知南北。 宫怨李益 露湿晴花春殿香，月明歌吹在昭阳。似将海水添宫漏，共滴长门一夜长。]]></content>
      <categories>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>汉语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集英语单词]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fenglish-learning%2F</url>
    <content type="text"><![CDATA[如何扩大单词量 如何提高听力 太难了 收集一些翻到的英语词汇perpendicularadj. 垂直的，成直角的n. 垂直线，垂直面 namelyadv. 即，也就是说 coordinatevt. 使协调，使调和vi. 协调，协同adj. 同等的;带有同等性质的 regardless of不管，不顾 obscureadj. 昏暗的，朦胧的;晦涩的，不清楚的vt. 使…模糊不清n. 某种模糊的或不清楚的东西 perspectiven. 透镜，望远镜;观点，看法adj. (按照)透视画法的;透视的 distortionn. 扭曲，变形;失真，畸变 interpolationn. 篡改，添写，插补，插值 revisevt. 修订，修正，改变，复习vi. 修订，校订 permeatevt. 渗透，渗入，弥漫，遍布vi. 贯穿，感染，传播，渗入，遍及，穿透某物 photonn. 光子，光量子 strikingadj. 引人注目的，显著的v. 击，打(现在分词);敲响;报时 comprisevt. 包含，包括;由…组成 squishn. 咯吱声，果酱v. 压扁，压烂，咯吱吱地走]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习算法]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Falgorithm-learning%2F</url>
    <content type="text"><![CDATA[我需要学习如下算法需要在45天内完成，那就11.14完成吧 完了 时间已经快到了 快速排序 堆排序 归并排序 选择排序 并查集算法 图的遍历 有向图的DFS 无向图的DFS 最小生成树 图的最短路径 贪心算法 动态规划 NP完全问题 KMP算法 BM算法 近似匹配算法 传递闭包算法 中间值算法 对抗方法 分治算法 哈希算法 快速排序顺便学习C 并查集]]></content>
      <tags>
        <tag>算法</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习c++]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fcpp-learning%2F</url>
    <content type="text"><![CDATA[to do list下面是我计划关注的方面 多态和继承 运算符重载 常用的库 函数模板和类模板 元编程 指针和引用 IO 网络编程 多线程 数据库 开发环境搭建打算使用windows上的能看文件结构的编辑器+在linux上编译执行 搭完了 最后还是用了mingw]]></content>
      <tags>
        <tag>学习</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习Java]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fjava-learning%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[如何学习后端]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fback-end-learning%2F</url>
    <content type="text"><![CDATA[我需要学习这些东西有时间做一个思维导图 数据库 hibernate redis 分布式 中间件 linux 网络协议 jvm 设计模式 消息队列]]></content>
      <tags>
        <tag>学习</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何学习前端]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Ffront-end-learning%2F</url>
    <content type="text"><![CDATA[我需要学习这些东西 CSS JS CSS3 H5 Ajax Grunt Gulp eslint Vue React React Native Angular babel Promise]]></content>
      <tags>
        <tag>前端</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三角级数相关]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Ftrigonometric-series%2F</url>
    <content type="text"><![CDATA[三角级数$\quad$一般地，以$A_k\sin(kx+\varphi_k)$为项作成的无穷级数 $$\sum\limits_{k=0}^{\infty}A_k\sin(kx+\varphi_k)$$ 称为三角级数.（所以首先三角级数都是无穷级数） 但是有时候也会取如下形式： $$\frac{a_0}{2}+\sum\limits_{k=1}^{\infty}(a_k\cos{kx}+b_k\sin{kx})。$$ 周期函数周期函数有初相,振幅,频率 正弦级数给三角级数中所有的$a_k$取$0$，可以得到如下的正弦级数: $$\sum\limits_{k=1}^{\infty}b_k\sin{kx}$$ 余弦级数类似的操作可以得到余弦级数 $$\frac{a_0}{2}+\sum\limits_{k=1}^{\infty}a_k\cos{kx}$$ 傅里叶级数$$\begin{split}A_n&amp;=\frac{1}{\pi}\int_0^{2\pi}f(x)\cos{nx}\mathtt{d}x \\B_n&amp;=\frac{1}{\pi}\int_0^{2\pi}f(x)\sin{nx}\mathtt{d}x\end{split}$$ 这里用的符号和上面不一样呢 应该打屁股]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
        <tag>级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曲线积分的意义]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2Fcurve-line-integral%2F</url>
    <content type="text"><![CDATA[曲线积分第一类曲线积分第一类曲线积分用来求一个曲线物体的质量.当物体的密度是一个常值时，只需要将密度乘以弧长就可以得到质量.当物体的密度不均匀时，我们将密度表示为函数$f$，并对函数在曲线上积分，称为第一类曲线积分或者对弧长的曲线积分,记为$\int_Cf(x,y)\mathtt{d}s$，即 $$\int_Cf(x,y)\mathtt{d}s=\lim_{\lambda\to{0}}\sum_{i=1}^nf(\xi_i,\eta_i)\Delta{s_i}$$ 其中$f(x,y)$称为被积函数,$C$称为积分曲线,$\mathtt{d}s$成为弧微分. 我们可以把这个概念扩展到三维空间或者更高维的空间中： $$\int_Cf(x,y,z)\mathtt{d}s=\lim_{\lambda\to{0}}\sum_{i=1}^nf(\xi_i,\eta_i,\zeta_i)\Delta{s_i}$$ 第二类曲线积分和第一类曲线积分不同，第二类曲线积分可以用来表示变力沿曲线做的功，是有方向的.第二类曲线积分记为: $$\int_CP(x,y)dx+Q(x,y)dy\quad或\quad\int_C\boldsymbol{F}(x,y)·\mathtt{d}\boldsymbol{r}$$ 特别地，还可以有对某个方向的曲线积分 沿曲线$C$对坐标$x$的曲线积分$$\int_CP(x,y)dx=\lim_{\lambda\to{0}}\sum_{i=1}^nP(\xi_i,\eta_i)\Delta{x_i}$$ 沿曲线$C$对坐标$y$的曲线积分$$\int_CQ(x,y)dy=\lim_{\lambda\to{0}}\sum_{i=1}^nQ(\xi_i,\eta_i)\Delta{y_i}$$ 既然如此，应该还可以对一个特定的方向积分，就是不知道怎么表示. 如果曲线$C$为闭曲线，则记第二类曲线积分为 $$\oint_CP(x,y)dx+Q(x,y)dy\quad或\quad\oint_C\boldsymbol{F}(x,y)·\mathtt{d}\boldsymbol{r}$$]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格林公式]]></title>
    <url>%2Fblog%2F2018%2F10%2F09%2FGreen-Formula%2F</url>
    <content type="text"><![CDATA[格林公式的定义和一些练习学习一下格林公式~ 简单闭曲线$\quad$设曲线$C$的参数方程为 $$\begin{cases}x=\varphi(t), \\y=\psi(t)\end{cases}\quad(\alpha\le{t}\le\beta).$$ 如果$\varphi,\psi$连续，且对不同的参数$t_1,t_2\in[\alpha,\beta]$(不妨设$t_1\le{t_2}$),$(\varphi(t_1),\psi(t_1))=(\varphi(t_2),\psi(t_2))$当且仅当$t_1=\alpha,t_2=\beta$,则称$C$为简单闭曲线 单连通区域$\quad$设有一个平面区域$D$,若$D$内的任意一条简单闭曲线所围的部分仍属于$D$，则称$D$为单连通区域，否则称为多连通区域. 格林公式$\quad$设有界闭区域$D$由逐段光滑曲线$C$围成，函数$P(x,y)$及$Q(x,y)$在$D$上具有一阶连续偏导数，则 $$\begin{split}\oint_C{P}\mathtt{d}x+Q\mathtt{d}y=\iint\limits_D\left(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}}\right)\mathtt{d}x\mathtt{d}y\end{split}$$ 用途通常这些东西总是有用的，我们观察上面的式子。 左边一部分是对光滑曲线$C$的第二类曲线积分，格林公式告诉我们它会与在由曲线围成的平面区域$D$上对两个方向的分量在另一个方向的偏导之差的积分相等. 证明为了加深理解，我们来看一下证明.证明格林公式的时候是拆开证的，也就是 $$\oint_CP\mathtt{d}x=-\iint\limits_D\frac{\partial{P}}{\partial{y}}\mathtt{d}x\mathtt{d}y, \quad\oint_CQ\mathtt{d}y=\iint\frac{\partial{Q}}{\partial{x}}\mathtt{d}x\mathtt{d}y$$ 分以下三种情况讨论: $D$由曲线$y=\varphi_1(x),y=\varphi_2(x)$，及直线$x=a,x=b$围成，即 $$D=\{(x,y)\mid\varphi_1(x)\le{y}\le\varphi_2(x),a\le{x}\le{b}\}$$ $D$是单连通区域，且与某些与$y$轴平行的直线相交多于两点 $D$是多联通区域 做题环节题目1求椭圆$x=a\cos\theta,y=b\sin\theta$所围图形面积. 解： 我们可以从格林公式中得到一个简单的应用： 当$P=-y,Q=x$时，公式就变成了 $$\begin{split}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y=2\iint\limits_D\mathtt{d}x\mathtt{d}y\end{split}$$ 也就是闭区域$D$的面积$A$为: $$\begin{split}A=\frac{1}{2}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y\end{split}$$ 那么求椭圆面积就变为了求解上述式子,有: $$\begin{split}A&amp;=\frac{1}{2}\oint_C{-y}\mathtt{d}x+x\mathtt{d}y \\&amp;=\frac{1}{2}\int_0^{2\pi}{-b\sin\theta}\mathtt{d}{a\cos\theta}+a\cos\theta\mathtt{d}b\sin\theta \\&amp;=\frac{1}{2}\int_0^{2\pi}{ab\sin^2\theta}\mathtt{d}{\theta}+ab\cos^2\theta\mathtt{d}\theta \\&amp;=\frac{1}{2}ab·2\pi \\&amp;=ab\pi\end{split}$$]]></content>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
</search>
